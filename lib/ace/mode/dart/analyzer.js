define(function(require, exports, module) {

var main;
function dartMainRunner(fn) {
    main = fn;
}

var errorList = {
    set$errors : function(errors) {
        this.errors = errors;
    }
};

exports.run = function(src) {
    main([src, errorList]);
    return errorList.errors;
};

// Generated by dart2js, the Dart to JavaScript compiler version: 1.6.0.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].

(function($) {
function dart(){ this.x = 0 }var A = new dart;
delete A.x;
var B = new dart;
delete B.x;
var C = new dart;
delete C.x;
var D = new dart;
delete D.x;
var E = new dart;
delete E.x;
var F = new dart;
delete F.x;
var G = new dart;
delete G.x;
var H = new dart;
delete H.x;
var J = new dart;
delete J.x;
var K = new dart;
delete K.x;
var L = new dart;
delete L.x;
var M = new dart;
delete M.x;
var N = new dart;
delete N.x;
var O = new dart;
delete O.x;
var P = new dart;
delete P.x;
var Q = new dart;
delete Q.x;
var R = new dart;
delete R.x;
var S = new dart;
delete S.x;
var T = new dart;
delete T.x;
var U = new dart;
delete U.x;
var V = new dart;
delete V.x;
var W = new dart;
delete W.x;
var X = new dart;
delete X.x;
var Y = new dart;
delete Y.x;
var Z = new dart;
delete Z.x;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = {};

(function(reflectionData) {
  "use strict";
  function map(x) {
    x = {x: x};
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    add$1: function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      return receiver.splice(index, 1)[0];
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$a(collection); t1.moveNext$0();)
        this.add$1(receiver, t1._current);
    },
    forEach$1: function(receiver, f) {
      return H.IterableMixinWorkaround_forEach(receiver, f);
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, receiver.length, 0, null), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      receiver[index] = value;
    },
    $isJSArray: true,
    $isList: true
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    $is$double: true,
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    $is$double: true,
    $isnum: true
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      return receiver.charCodeAt(index);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(P.ArgumentError$(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    trim$0: function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    indexOf$2: function(receiver, pattern, start) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      return receiver.indexOf(pattern, start);
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    contains$2: function(receiver, other, startIndex) {
      startIndex.$lt(0, 0);
      startIndex.$gt(0, receiver.length);
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $isString: true,
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          if (index >= t1)
            H.throwExpression(P.RangeError$value(index));
          codeUnit = string.charCodeAt(index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var t1, index0, codeUnit;
        for (t1 = string.length; index > 0; index = index0) {
          index0 = index - 1;
          if (index0 >= t1)
            H.throwExpression(P.RangeError$value(index0));
          codeUnit = string.charCodeAt(index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }

      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$as(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          t1.$index(msg, "port").send$1(t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  },
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    replyTo.send$1(["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused === true) {
      context.addPause$2(t3, t3);
      init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t2, "start isolate"));
    } else
      t2.call$0();
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:11;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    }
  },
  startRootIsolate_closure0: {
    "^": "Closure:11;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    }
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      t2 = H._IsolateEvent;
      t3 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t2]);
      t3.ListQueue$1(null, t2);
      this.topEventLoop = new H._EventLoop(t3, 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t1);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log) {
              self.console.log(object);
            } else {
              self.postMessage(serialize(object));
            }
          };
        }(H._Manager__serializePrintMessage);
      }
    },
    static: {_Manager__serializePrintMessage: function(object) {
        return H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null));
      }}
  },
  _IsolateContext: {
    "^": "Object;id,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized,isPaused,delayedEvents,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._collection$_table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._collection$_tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$as(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$a(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      t1 = J.getInterceptor(pingType);
      if (!t1.$eq(pingType, 0))
        t2 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        responsePort.send$1(null);
        return;
      }
      t2 = new H._IsolateContext_handlePing_respond(responsePort);
      if (t1.$eq(pingType, 2)) {
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(this, t2, "ping"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
        t1.ListQueue$1(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(t2);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      t1 = J.getInterceptor(priority);
      if (!t1.$eq(priority, 0))
        t2 = t1.$eq(priority, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        this.kill$0();
        return;
      }
      if (t1.$eq(priority, 2)) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1.events._add$1(new H._IsolateEvent(this, t2, "kill"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
        t1.ListQueue$1(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(this.get$kill());
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (this.errorsAreFatal === true && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = init;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : J.toString$0(stackTrace);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        t1._collection$_current.send$1(message);
    },
    eval$1: function(code) {
      var old, result, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.handleUncaughtError$2(e, s);
        if (this.errorsAreFatal === true) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      }
 finally {
        this._isExecutingEvent = false;
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2, t3;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(), t3 = t2._iterable, t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, t3.get$iterator(t3), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2._current._close$0();
      if (t1._collection$_length > 0) {
        t1._last = null;
        t1._first = null;
        t1._rest = null;
        t1._nums = null;
        t1._strings = null;
        t1._collection$_length = 0;
        t1._modifications = t1._modifications + 1 & 67108863;
      }
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._current.send$1(null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 4],
    $is_IsolateContext: true
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:4;responsePort_0",
    call$0: function() {
      this.responsePort_0.send$1(null);
    }
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._collection$_tail)
        return;
      return t1.removeFirst$0();
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:4;this_0",
    call$0: function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    }
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.isPaused) {
        t1.delayedEvents.push(this);
        return;
      }
      t1.eval$1(this.fn);
    },
    $is_IsolateEvent: true
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:11;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    }
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:4;topLevel_0,args_1,message_2,isSpawnUri_3,context_4",
    call$0: function() {
      var t1, t2, t3;
      this.context_4.initialized = true;
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    }
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this._receivePort;
      if (t3.get$_isClosed())
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (isolate.get$controlPort() === t3) {
        t1 = t1.msg_0;
        t2 = J.getInterceptor$as(t1);
        switch (t2.$index(t1, 0)) {
          case "pause":
            isolate.addPause$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "resume":
            isolate.removePause$1(t2.$index(t1, 1));
            break;
          case "add-ondone":
            isolate.addDoneListener$1(t2.$index(t1, 1));
            break;
          case "remove-ondone":
            isolate.removeDoneListener$1(t2.$index(t1, 1));
            break;
          case "set-errors-fatal":
            isolate.setErrorsFatal$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "ping":
            isolate.handlePing$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "kill":
            isolate.handleKill$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "getErrors":
            t1 = t2.$index(t1, 1);
            isolate.errorPorts.add$1(0, t1);
            break;
          case "stopErrors":
            t1 = t2.$index(t1, 1);
            isolate.errorPorts.remove$1(0, t1);
            break;
        }
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_NativeJsSendPort && J.$eq(this._receivePort, other._receivePort);
    },
    get$hashCode: function(_) {
      return this._receivePort.get$_id();
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:11;box_0,this_1,shouldSerialize_2",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1._receivePort;
      if (!t1.get$_isClosed()) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(this.box_0.msg_0);
      }
    }
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_WorkerSendPort && J.$eq(this._workerId, other._workerId) && J.$eq(this._isolateId, other._isolateId) && J.$eq(this._receivePortId, other._receivePortId);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = this._workerId;
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = this._isolateId;
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 << 16 ^ t2 << 8 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;_id<,_handler,_isClosed<",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    _close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    $isRawReceivePortImpl: true,
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x._id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x._receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x._id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$as(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$as(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function() {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function() {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0();
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, i;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$as(list);
      len = t1.get$length(list);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (i = 0; i < len; ++i)
        copy[i] = this._dispatch$1(t1.$index(list, i));
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      map.forEach$1(0, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:12;box_0,this_1",
    call$2: function(key, val) {
      var t1 = this.this_1;
      J.$indexSet$a(this.box_0.copy_0, t1._dispatch$1(key), t1._dispatch$1(val));
    }
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1, t2, keys;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      t2 = map.get$keys();
      keys = this._serializeList$1(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)));
      t2 = map.get$values();
      return ["map", t1, keys, this._serializeList$1(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$as(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      for (i = 0; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$as(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$as(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$as(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$as(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$as(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$as(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = self.setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:4;this_0,callback_1",
    call$0: function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    }
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:4;this_2,callback_3",
    call$0: function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    }
  },
  CapabilityImpl: {
    "^": "Object;_id<",
    get$hashCode: function(_) {
      var hash = this._id;
      if (typeof hash !== "number")
        return hash.$shr();
      hash = C.JSNumber_methods._shrOtherPositive$1(hash, 0) ^ C.JSNumber_methods._tdivFast$1(hash, 4294967296);
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this._id;
        t2 = other._id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__throwFormatException: [function(string) {
    throw H.wrapException(P.FormatException$(string, null, null));
  }, "call$1", "Primitives__throwFormatException$closure", 2, 0, 0],
  Primitives_parseInt: function(source, radix, handleError) {
    var match, t1, maxCharCode, digitsPart, i, t2;
    handleError = H.Primitives__throwFormatException$closure();
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (radix == null) {
      if (match != null) {
        t1 = match.length;
        if (2 >= t1)
          return H.ioore(match, 2);
        if (match[2] != null)
          return parseInt(source, 16);
        if (3 >= t1)
          return H.ioore(match, 3);
        if (match[3] != null)
          return parseInt(source, 10);
        return handleError.call$1(source);
      }
      radix = 10;
    } else {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$("Radix " + H.S(radix) + " not in range 2..36"));
      if (match != null) {
        if (radix === 10) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] != null;
        } else
          t1 = false;
        if (t1)
          return parseInt(source, 10);
        if (!(radix < 10)) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] == null;
        } else
          t1 = true;
        if (t1) {
          maxCharCode = radix <= 10 ? 48 + radix - 1 : 97 + radix - 10 - 1;
          if (1 >= match.length)
            return H.ioore(match, 1);
          digitsPart = match[1];
          t1 = J.getInterceptor$as(digitsPart);
          i = 0;
          while (true) {
            t2 = t1.get$length(digitsPart);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t1.codeUnitAt$1(digitsPart, 0);
            if (i >= digitsPart.length)
              H.throwExpression(P.RangeError$value(i));
            if (digitsPart.charCodeAt(i) > maxCharCode)
              return handleError.call$1(source);
            ++i;
          }
        }
      }
    }
    if (match == null)
      return handleError.call$1(source);
    return parseInt(source, radix);
  },
  Primitives_parseDouble: function(source, handleError) {
    var result, trimmed;
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    handleError = H.Primitives__throwFormatException$closure();
    if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
      return handleError.call$1(source);
    result = parseFloat(source);
    if (isNaN(result)) {
      trimmed = J.trim$0$s(source);
      if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
        return result;
      return handleError.call$1(source);
    }
    return result;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [P.$int];
    t1 = new H.ListIterator(codePoints, codePoints.length, 0, null);
    t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(codePoints, 0)];
    for (; t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(charCodes, charCodes.length, 0, null), [H.getTypeArgumentByIndex(charCodes, 0)]); t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111));
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$as(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index));
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = init;
    reflectionInfo.fixed$length = init;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$as(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  getRuntimeTypeString: function(object) {
    var className = J.getInterceptor(object).constructor.builtin$cls;
    if (object == null)
      return className;
    return className + H.joinArguments(object.$builtinTypeInfo, 0, null);
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  checkSubtypeOfRuntimeType: function(o, t) {
    var rti, type;
    if (o == null)
      return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
    if (t == null)
      return true;
    rti = H.getRuntimeTypeInfo(o);
    o = J.getInterceptor(o);
    if (rti != null) {
      type = rti.slice();
      type.splice(0, 0, o);
    } else
      type = o;
    return H.isSubtype(type, t);
  },
  subtypeOfRuntimeTypeCast: function(object, type) {
    if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.runtimeTypeToString(type, null)));
    return object;
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = init;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    return C.JSString_methods.indexOf$2(receiver, other, startIndex) !== -1;
  },
  _matchString: [function(match) {
    return match.$index(0, 0);
  }, "call$1", "_matchString$closure", 2, 0, 1],
  _stringIdentity: [function(string) {
    return string;
  }, "call$1", "_stringIdentity$closure", 2, 0, 2],
  stringReplaceAllFuncUnchecked: function(receiver, pattern, onMatch, onNonMatch) {
    var buffer, t1, startIndex, match, t2, str, t3;
    onNonMatch = H._stringIdentity$closure();
    buffer = P.StringBuffer$("");
    t1 = new H._AllMatchesIterator(pattern, receiver, 0, null);
    startIndex = 0;
    for (; t1.moveNext$0();) {
      match = t1.__js_helper$_current;
      t2 = match._match;
      str = onNonMatch.call$1(C.JSString_methods.substring$2(receiver, startIndex, t2.index));
      buffer._contents += typeof str === "string" ? str : H.S(str);
      str = onMatch.call$1(match);
      buffer._contents += typeof str === "string" ? str : H.S(str);
      t3 = t2.index;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = J.get$length$as(t2[0]);
      if (typeof t2 !== "number")
        return H.iae(t2);
      startIndex = t3 + t2;
    }
    buffer.write$1(onNonMatch.call$1(C.JSString_methods.substring$1(receiver, startIndex)));
    return buffer._contents;
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = init;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,__js_helper$_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = {};
      t1 = this.__js_helper$_arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }

        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }

        }(expression);
      }}
  },
  NullError: {
    "^": "Error;__js_helper$_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this.__js_helper$_message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;__js_helper$_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this.__js_helper$_message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this.__js_helper$_message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this.__js_helper$_message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;__js_helper$_message",
    toString$0: function(_) {
      var t1 = this.__js_helper$_message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:13;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    }
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    }
  },
  invokeClosure_closure: {
    "^": "Closure:11;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure:11;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure:11;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure:11;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure:11;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,__js_helper$_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this.__js_helper$_target === other.__js_helper$_target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      t1 = H.Primitives_objectHashCode(this.__js_helper$_target);
      if (typeof receiverHashCode !== "number")
        return receiverHashCode.$xor();
      return (receiverHashCode ^ t1) >>> 0;
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = init;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    $isError: true,
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = {};
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + H.S(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  TypeImpl: {
    "^": "Object;_typeName,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTypeImpl && J.$eq(this._typeName, other._typeName);
    },
    $isTypeImpl: true
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp, errorMessage;
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }

        }();
        if (regexp instanceof RegExp)
          return regexp;
        errorMessage = String(regexp);
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern: " + source + ", " + errorMessage, null, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    group$1: function(index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $index: function(_, index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    _MatchImplementation$2: function(pattern, _match) {
    },
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1 = new H._MatchImplementation(pattern, _match);
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, t3, nextIndex;
      t1 = this._string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t3 = J.get$length$as(t1[0]);
          if (typeof t3 !== "number")
            return H.iae(t3);
          nextIndex = t2 + t3;
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this._string = null;
      return false;
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableMixinWorkaround_forEach: function(iterable, f) {
    var t1;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
      f.call$1(t1._current);
  },
  IterableMixinWorkaround_sortList: function(list, compare) {
    if (compare == null)
      compare = P.Comparable_compare$closure();
    H.Sort__doSort(list, 0, list.length - 1, compare);
  },
  IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
    var $length;
    if (start < 0 || start > list.length)
      H.throwExpression(P.RangeError$range(start, 0, list.length));
    if (end < start || end > list.length)
      H.throwExpression(P.RangeError$range(end, start, list.length));
    $length = end - start;
    if ($length === 0)
      return;
    if (skipCount < 0)
      throw H.wrapException(P.ArgumentError$(skipCount));
    if (skipCount + $length > from.length)
      throw H.wrapException(H.IterableElementError_tooFew());
    H.Lists_copy(from, skipCount, list, start, $length);
  },
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var i, j, t1, t2;
    if (srcStart < dstStart)
      for (i = srcStart + count - 1, j = dstStart + count - 1, t1 = src.length; i >= srcStart; --i, --j) {
        if (i < 0 || i >= t1)
          return H.ioore(src, i);
        C.JSArray_methods.$indexSet(dst, j, src[i]);
      }
    else
      for (t1 = srcStart + count, t2 = src.length, j = dstStart, i = srcStart; i < t1; ++i, ++j) {
        if (i < 0 || i >= t2)
          return H.ioore(src, i);
        C.JSArray_methods.$indexSet(dst, j, src[i]);
      }
  },
  Sort__doSort: function(a, left, right, compare) {
    if (right - left <= 32)
      H.Sort__insertionSort(a, left, right, compare);
    else
      H.Sort__dualPivotQuicksort(a, left, right, compare);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var i, t1, el, j, j0;
    for (i = left + 1, t1 = J.getInterceptor$as(a); i <= right; ++i) {
      el = t1.$index(a, i);
      j = i;
      while (true) {
        if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
          break;
        j0 = j - 1;
        t1.$indexSet(a, j, t1.$index(a, j0));
        j = j0;
      }
      t1.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t2, great0, less0, pivots_are_equal;
    sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
    index1 = left + sixth;
    index5 = right - sixth;
    index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
    index2 = index3 - sixth;
    index4 = index3 + sixth;
    t1 = J.getInterceptor$as(a);
    el1 = t1.$index(a, index1);
    el2 = t1.$index(a, index2);
    el3 = t1.$index(a, index3);
    el4 = t1.$index(a, index4);
    el5 = t1.$index(a, index5);
    if (J.$gt$n(compare.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t1.$indexSet(a, index1, el1);
    t1.$indexSet(a, index3, el3);
    t1.$indexSet(a, index5, el5);
    t1.$indexSet(a, index2, t1.$index(a, left));
    t1.$indexSet(a, index4, t1.$index(a, right));
    less = left + 1;
    great = right - 1;
    if (J.$eq(compare.call$2(el2, el4), 0)) {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        comp = compare.call$2(ak, el2);
        t2 = J.getInterceptor(comp);
        if (t2.$eq(comp, 0))
          continue;
        if (t2.$lt(comp, 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else
          for (; true;) {
            comp = compare.call$2(t1.$index(a, great), el2);
            t2 = J.getInterceptor$n(comp);
            if (t2.$gt(comp, 0)) {
              --great;
              continue;
            } else {
              great0 = great - 1;
              if (t2.$lt(comp, 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$lt$n(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$gt$n(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$gt$n(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      pivots_are_equal = false;
    }
    t2 = less - 1;
    t1.$indexSet(a, left, t1.$index(a, t2));
    t1.$indexSet(a, t2, el2);
    t2 = great + 1;
    t1.$indexSet(a, right, t1.$index(a, t2));
    t1.$indexSet(a, t2, el4);
    H.Sort__doSort(a, left, less - 2, compare);
    H.Sort__doSort(a, great + 2, right, compare);
    if (pivots_are_equal)
      return;
    if (less < index1 && great > index5) {
      for (; J.$eq(compare.call$2(t1.$index(a, less), el2), 0);)
        ++less;
      for (; J.$eq(compare.call$2(t1.$index(a, great), el4), 0);)
        --great;
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$eq(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$eq(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$eq(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, compare);
    } else
      H.Sort__doSort(a, less, great, compare);
  },
  Symbol_getName: function(symbol) {
    return symbol.get$__internal$_name();
  },
  ListIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$as(t1);
      $length = t2.get$length(t1);
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (t3 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = this._iterable;
      t1 = new H.MappedIterator(null, t1.get$iterator(t1), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      var t1 = this._iterable;
      return t1.get$length(t1);
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f"
  },
  MappedIterator: {
    "^": "Iterator;_current,__internal$_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this.__internal$_iterator;
      if (t1.moveNext$0()) {
        this._current = this._f$1(t1.get$current());
        return true;
      }
      this._current = null;
      return false;
    },
    get$current: function() {
      return this._current;
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(function(victim, hasOwnProperty) {
      var result = [];
      for (var key in victim) {
        if (hasOwnProperty.call(victim, key))
          result.push(key);
      }
      return result;
    }(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = init;
    return t1;
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return P._AsyncRun__scheduleImmediateJsOverride$closure();
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1.storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    }
    return P._AsyncRun__scheduleImmediateWithTimer$closure();
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 3],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, callback);
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 3],
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.next;
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 4],
  Timer_Timer: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createTimer(duration, callback);
    }
    return P.Timer__createTimer(duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  Timer__createTimer: function(duration, callback) {
    var milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var entry, t1, t2;
    entry = new P._AsyncCallbackEntry(new P._rootHandleUncaughtError_closure(error, stackTrace), null);
    t1 = $._nextCallback;
    if (t1 == null) {
      $._lastPriorityCallback = entry;
      $._lastCallback = entry;
      $._nextCallback = entry;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.next;
        t2.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:13;box_0",
    call$1: function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this.box_0;
      f = t1.storedCallback_0;
      t1.storedCallback_0 = null;
      f.call$0();
    }
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:14;box_0,div_1,span_2",
    call$1: function(callback) {
      var t1, t2;
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      this.box_0.storedCallback_0 = callback;
      t1 = this.div_1;
      t2 = this.span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    }
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:11;callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }
  },
  _AsyncError: {
    "^": "Object;stackTrace<",
    $isError: true
  },
  _UncaughtAsyncError: {
    "^": "_AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + H.S(t1)) : result;
    },
    static: {_UncaughtAsyncError$: function(error, stackTrace) {
        return new P._UncaughtAsyncError(error, P._UncaughtAsyncError__getBestStackTrace(error, stackTrace));
      }, _UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  Future: {
    "^": "Object;"
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  StreamSubscription: {
    "^": "Object;"
  },
  _EventSink: {
    "^": "Object;"
  },
  _DelayedEvent: {
    "^": "Object;"
  },
  _Zone: {
    "^": "Object;"
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:11;error_0,stackTrace_1",
    call$0: function() {
      throw H.wrapException(P._UncaughtAsyncError$(this.error_0, this.stackTrace_1));
    }
  },
  _RootZone: {
    "^": "_Zone;",
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindCallback_closure(this, f);
      else
        return new P._RootZone_bindCallback_closure0(this, f);
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    static: {"^": "_RootZone__rootMap,_RootZone__rootDelegate"}
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:11;this_0,f_1",
    call$0: function() {
      return this.this_0.runGuarded$1(this.f_1);
    }
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:11;this_2,f_3",
    call$0: function() {
      return this.this_2.run$1(this.f_3);
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 5],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 6],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  HashSet_HashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._HashSet(0, null, null, null, null), [$E]);
  },
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = P.StringBuffer$(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1.write$1(rightDelimiter);
    return t1._contents;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    buffer.write$1(rightDelimiter);
    return buffer.get$_contents();
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  Maps_mapToString: function(m) {
    var t1, result;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = P.StringBuffer$("");
    try {
      $.get$IterableBase__toStringVisiting().push(m);
      result.write$1("{");
      t1.first_0 = true;
      J.forEach$1$a(m, new P.Maps_mapToString_closure(t1, result));
      result.write$1("}");
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings = this._strings;
      return strings == null ? false : strings[key] != null;
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._keys = null;
        }
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    static: {_HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:13;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      t1 = new P.HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    }
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_keys,_collection$_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._keys;
      offset = this._collection$_offset;
      t1 = this._map;
      if (keys !== t1._keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._collection$_offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var nums;
      if ((key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_collection$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_collection$_value();
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_collection$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_collection$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_collection$_value();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell.get$_collection$_key(), cell._collection$_value);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._collection$_next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_collection$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_collection$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_collection$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_collection$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_collection$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_collection$_key(), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:13;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    }
  },
  LinkedHashMapCell: {
    "^": "Object;_collection$_key<,_collection$_value@,_collection$_next@,_previous@"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.get$_collection$_key());
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._collection$_next;
      }
    }
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_collection$_key();
          this._cell = this._cell.get$_collection$_next();
          return true;
        }
      }
    }
  },
  _HashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_collection$_elements",
    get$iterator: function(_) {
      var t1 = new P.HashSetIterator(this, this._computeElements$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        return nums == null ? false : nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$as(bucket, index);
    },
    add$1: function(_, element) {
      var strings, table;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [element];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(element);
      }
      ++this._collection$_length;
      this._collection$_elements = null;
      return true;
    },
    _computeElements$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._collection$_elements;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; ++i0) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._collection$_elements = result;
      return result;
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = 0;
      ++this._collection$_length;
      this._collection$_elements = null;
      return true;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i], element))
          return i;
      return -1;
    },
    static: {_HashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  HashSetIterator: {
    "^": "Object;_set,_collection$_elements,_collection$_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var elements, offset, t1;
      elements = this._collection$_elements;
      offset = this._collection$_offset;
      t1 = this._set;
      if (elements !== t1._collection$_elements)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= elements.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = elements[offset];
        this._collection$_offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._modifications, null, null), [null]);
      t1._cell = t1._set._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$as(bucket, index).get$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell.get$_element());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._collection$_next;
      }
    },
    add$1: function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_collection$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_collection$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_collection$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_element(), element))
          return i;
      return -1;
    },
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_element<,_collection$_next@,_previous@"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_element();
          this._cell = this._cell.get$_collection$_next();
          return true;
        }
      }
    }
  },
  _HashSetBase: {
    "^": "SetBase;"
  },
  IterableBase: {
    "^": "Object;",
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq(t1.get$current(), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element;
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        if (remaining === 0)
          return element;
        --remaining;
      }
      throw H.wrapException(P.RangeError$value(index));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new H.ListIterator(this, this.get$length(this), 0, null), [H.getRuntimeTypeArgument(this, "ListMixin", 0)]);
    },
    elementAt$1: function(_, index) {
      return this.$index(0, index);
    },
    forEach$1: function(_, action) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.$index(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    contains$1: function(_, element) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < this.get$length(this); ++i) {
        if (J.$eq(this.$index(0, i), element))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    },
    add$1: function(_, element) {
      var t1 = this.get$length(this);
      this.set$length(0, t1 + 1);
      this.$indexSet(0, t1, element);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "[", "]");
    },
    $isList: true
  },
  Maps_mapToString_closure: {
    "^": "Closure:12;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(k);
      t1.write$1(": ");
      t1.write$1(v);
    }
  },
  ListQueue: {
    "^": "IterableBase;_collection$_table,_head,_collection$_tail,_modificationCount",
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._collection$_tail, this._modificationCount, this._head, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._collection$_tail; i = (i + 1 & this._collection$_table.length - 1) >>> 0) {
        t1 = this._collection$_table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._collection$_tail;
    },
    get$length: function(_) {
      return (this._collection$_tail - this._head & this._collection$_table.length - 1) >>> 0;
    },
    add$1: function(_, element) {
      this._add$1(element);
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._collection$_tail;
      if (i !== t1) {
        for (t2 = this._collection$_table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._collection$_tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._collection$_tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._collection$_table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return result;
    },
    _add$1: function(element) {
      var t1, t2, t3;
      t1 = this._collection$_table;
      t2 = this._collection$_tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._collection$_tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._collection$_table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._collection$_table;
      t2 = this._head;
      split = t1.length - t2;
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t1 = this._head;
      t2 = this._collection$_table;
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t1, t2, 0);
      this._head = 0;
      this._collection$_tail = this._collection$_table.length;
      this._collection$_table = newTable;
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._collection$_table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    static: {"^": "ListQueue__INITIAL_CAPACITY"}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._collection$_table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  },
  SetMixin: {
    "^": "Object;",
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    }
  },
  SetBase: {
    "^": "SetMixin;"
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  _symbolToString: function(symbol) {
    return H.Symbol_getName(symbol);
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(a, b);
  }, "call$2", "Comparable_compare$closure", 4, 0, 7],
  Error_safeToString: function(object) {
    var buffer, t1, i, t2, codeUnit;
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string") {
      buffer = new P.StringBuffer("");
      buffer._contents = "\"";
      for (t1 = object.length, i = 0, t2 = "\""; i < t1; ++i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(object, i);
        if (codeUnit <= 31)
          if (codeUnit === 10)
            t2 = buffer._contents += "\\n";
          else if (codeUnit === 13)
            t2 = buffer._contents += "\\r";
          else if (codeUnit === 9)
            t2 = buffer._contents += "\\t";
          else {
            t2 = buffer._contents += "\\x";
            if (codeUnit < 16)
              buffer._contents = t2 + "0";
            else {
              buffer._contents = t2 + "1";
              codeUnit -= 16;
            }
            t2 = H.Primitives_stringFromCharCode(codeUnit < 10 ? 48 + codeUnit : 87 + codeUnit);
            t2 = buffer._contents += t2;
          }
        else if (codeUnit === 92)
          t2 = buffer._contents += "\\\\";
        else if (codeUnit === 34)
          t2 = buffer._contents += "\\\"";
        else {
          t2 = H.Primitives_stringFromCharCode(codeUnit);
          t2 = buffer._contents += t2;
        }
      }
      t1 = t2 + "\"";
      buffer._contents = t1;
      return t1;
    }
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 8],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 9],
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = J.get$iterator$a(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = init;
    return list;
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:15;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(", ");
      t1.sb_0.write$1(P._symbolToString(key));
    }
  },
  bool: {
    "^": "Object;",
    $isbool: true
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  $double: {
    "^": "num;",
    $is$double: true
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, C.JSInt_methods.$add(this._duration, other.get$_duration()), 0, 0, 0);
    },
    $lt: function(_, other) {
      return C.JSInt_methods.$lt(this._duration, other.get$_duration());
    },
    $gt: function(_, other) {
      return C.JSInt_methods.$gt(this._duration, other.get$_duration());
    },
    $ge: function(_, other) {
      return C.JSInt_methods.$ge(this._duration, other.get$_duration());
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, other.get$_duration());
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSInt_methods.remainder$1(t2, 1000000));
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:16;",
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    }
  },
  Duration_toString_twoDigits: {
    "^": "Closure:16;",
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    }
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Illegal argument(s): " + H.S(t1);
      return "Illegal argument(s)";
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;message",
    toString$0: function(_) {
      return "RangeError: " + H.S(this.message);
    },
    static: {RangeError$: function(message) {
        return new P.RangeError(message);
      }, RangeError$value: function(value) {
        return new P.RangeError("value " + H.S(value));
      }, RangeError$range: function(value, start, end) {
        return new P.RangeError("value " + value + " not in range " + start + ".." + H.S(end));
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "UnimplementedError";
    },
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    }
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  FormatException: {
    "^": "Object;message,source,offset<",
    toString$0: function(_) {
      var t1, report;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      return report;
    },
    $isFormatException: true,
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  Expando: {
    "^": "Object;name<",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount"}
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isList: true
  },
  "+List": 0,
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Match: {
    "^": "Object;"
  },
  StackTrace: {
    "^": "Object;"
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$a(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    toString$0: function(_) {
      return this._contents;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol: {
    "^": "Object;"
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;",
    $isCapability: true
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  max: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (isNaN(b))
        return b;
      return a;
    }
    if (b === 0 && C.JSNumber_methods.get$isNegative(a))
      return b;
    return a;
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["engine", "package:analyzer/src/generated/engine.dart", , T, {
  "^": "",
  AnalysisEngine: {
    "^": "Object;_logger,partitionManager,enableUnionTypes,strictUnionTypes",
    static: {"^": "AnalysisEngine_SUFFIX_DART,AnalysisEngine_SUFFIX_HTM,AnalysisEngine_SUFFIX_HTML,AnalysisEngine__UniqueInstance"}
  },
  CachePartition: {
    "^": "Object;"
  },
  Logger_NullLogger: {
    "^": "Object;"
  },
  PartitionManager: {
    "^": "Object;_sdkPartitions",
    static: {"^": "PartitionManager__DEFAULT_SDK_CACHE_SIZE"}
  },
  SdkCachePartition: {
    "^": "CachePartition;",
    $isSdkCachePartition: true
  }
}],
["engine.ast", "package:analyzer/src/generated/ast.dart", , N, {
  "^": "",
  AdjacentStrings: {
    "^": "StringLiteral;_ast$_strings,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitAdjacentStrings$1(this);
    },
    get$beginToken: function() {
      return this._ast$_strings.get$beginToken();
    },
    get$endToken: function() {
      return this._ast$_strings.get$endToken();
    },
    visitChildren$1: function(visitor) {
      this._ast$_strings.accept$1(visitor);
    },
    AdjacentStrings$1: function(strings) {
      var t1 = N.StringLiteral;
      t1 = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._ast$_strings = t1;
      t1.addAll$1(0, strings);
    }
  },
  AnnotatedNode: {
    "^": "AstNode;",
    get$beginToken: function() {
      var t1, commentToken, metadataToken, t2;
      if (this._comment == null) {
        t1 = this._metadata;
        if (t1.get$isEmpty(t1))
          return this.get$firstTokenAfterCommentAndMetadata();
        else
          return this._metadata.get$beginToken();
      } else {
        t1 = this._metadata;
        if (t1.get$isEmpty(t1))
          return this._comment.get$beginToken();
      }
      commentToken = this._comment.get$beginToken();
      metadataToken = this._metadata.get$beginToken();
      t1 = commentToken.get$offset();
      t2 = metadataToken.get$offset();
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 < t2)
        return commentToken;
      return metadataToken;
    },
    get$metadata: function() {
      return this._metadata;
    },
    visitChildren$1: function(visitor) {
      var t1, childList, children;
      if (this._commentIsBeforeAnnotations$0()) {
        t1 = this._comment;
        if (t1 != null)
          t1.accept$1(visitor);
        this._metadata.accept$1(visitor);
      } else {
        childList = H.setRuntimeTypeInfo([], [N.AstNode]);
        childList.push(this._comment);
        C.JSArray_methods.addAll$1(childList, this._metadata);
        children = P.List_List$from(childList, true, null);
        t1 = $.get$AstNode_LEXICAL_ORDER();
        H.IterableMixinWorkaround_sortList(children, t1);
        t1 = H.setRuntimeTypeInfo(new H.ListIterator(children, children.length, 0, null), [H.getTypeArgumentByIndex(children, 0)]);
        for (; t1.moveNext$0();)
          t1._current.accept$1(visitor);
      }
    },
    _commentIsBeforeAnnotations$0: function() {
      var t1, firstAnnotation, t2;
      if (this._comment != null) {
        t1 = this._metadata;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = true;
      if (t1)
        return true;
      firstAnnotation = this._metadata.$index(0, 0);
      t1 = this._comment.get$offset();
      t2 = firstAnnotation.get$offset();
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 < t2;
    },
    AnnotatedNode$2: function(comment, metadata) {
      var t1 = N.Annotation;
      this._metadata = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._comment = this.becomeParentOf$1(comment);
      this._metadata.addAll$1(0, metadata);
    }
  },
  Annotation: {
    "^": "AstNode;atSign,_name<,period,_constructorName,_arguments,_ast$_element,elementAnnotation,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitAnnotation$1(this);
    },
    get$beginToken: function() {
      return this.atSign;
    },
    get$endToken: function() {
      var t1 = this._arguments;
      if (t1 != null)
        return t1.get$endToken();
      else {
        t1 = this._constructorName;
        if (t1 != null)
          return t1.get$endToken();
      }
      return this._name.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._constructorName;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._arguments;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isAnnotation: true
  },
  ArgumentList: {
    "^": "AstNode;_leftParenthesis,_arguments,_rightParenthesis,_correspondingStaticParameters,_correspondingPropagatedParameters,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitArgumentList$1(this);
    },
    get$beginToken: function() {
      return this._leftParenthesis;
    },
    get$endToken: function() {
      return this._rightParenthesis;
    },
    visitChildren$1: function(visitor) {
      this._arguments.accept$1(visitor);
    }
  },
  AsExpression: {
    "^": "Expression;_expression,asOperator,_type<,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitAsExpression$1(this);
    },
    get$beginToken: function() {
      return this._expression.get$beginToken();
    },
    get$endToken: function() {
      return this._type.get$endToken();
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  AssertStatement: {
    "^": "Statement;keyword<,leftParenthesis,_condition,rightParenthesis,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitAssertStatement$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._condition;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  AssignmentExpression: {
    "^": "Expression;_leftHandSide,operator,_rightHandSide,_staticElement,_propagatedElement,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitAssignmentExpression$1(this);
    },
    get$beginToken: function() {
      return this._leftHandSide.get$beginToken();
    },
    get$endToken: function() {
      return this._rightHandSide.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._leftHandSide;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._rightHandSide;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    AssignmentExpression$3: function(leftHandSide, operator, rightHandSide) {
      var t1 = leftHandSide == null;
      if (t1 || rightHandSide == null) {
        if (t1)
          if (rightHandSide == null)
            ;
        $.get$AnalysisEngine__UniqueInstance()._logger.toString;
      }
      this._leftHandSide = this.becomeParentOf$1(leftHandSide);
      this._rightHandSide = this.becomeParentOf$1(rightHandSide);
    },
    $isAssignmentExpression: true,
    static: {AssignmentExpression$: function(leftHandSide, operator, rightHandSide) {
        var t1 = new N.AssignmentExpression(null, operator, null, null, null, null, null, null, null);
        t1.AssignmentExpression$3(leftHandSide, operator, rightHandSide);
        return t1;
      }}
  },
  AstNode: {
    "^": "Object;",
    get$length: function(_) {
      var beginToken, endToken, t1, t2, t3;
      beginToken = this.get$beginToken();
      endToken = this.get$endToken();
      if (beginToken == null || endToken == null)
        return -1;
      t1 = endToken.get$offset();
      t2 = J.get$length$as(endToken);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = beginToken.get$offset();
      if (typeof t3 !== "number")
        return H.iae(t3);
      return t1 + t2 - t3;
    },
    get$offset: function() {
      var beginToken = this.get$beginToken();
      if (beginToken == null)
        return -1;
      return beginToken.get$offset();
    },
    toString$0: function(_) {
      var t1 = P.StringBuffer$("");
      this.accept$1(new N.ToSourceVisitor(new L.PrintStringWriter(t1)));
      return t1._contents;
    },
    becomeParentOf$1: function(child) {
      if (child != null)
        child.set$parent(this);
      return child;
    },
    set$parent: function(newParent) {
      this._parent = newParent;
    },
    $isAstNode: true
  },
  closure: {
    "^": "Closure:17;",
    call$2: function(first, second) {
      var t1, t2;
      t1 = second.get$offset();
      t2 = first.get$offset();
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 - t2;
    }
  },
  AwaitExpression: {
    "^": "Expression;awaitKeyword,_expression,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitAwaitExpression$1(this);
    },
    get$beginToken: function() {
      var t1 = this.awaitKeyword;
      if (t1 != null)
        return t1;
      return this._expression.get$beginToken();
    },
    get$endToken: function() {
      return this._expression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  BinaryExpression: {
    "^": "Expression;_leftOperand,operator,_rightOperand,_staticElement,_propagatedElement,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitBinaryExpression$1(this);
    },
    get$beginToken: function() {
      return this._leftOperand.get$beginToken();
    },
    get$endToken: function() {
      return this._rightOperand.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._leftOperand;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._rightOperand;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  Block: {
    "^": "Statement;leftBracket,_statements,rightBracket,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitBlock$1(this);
    },
    get$beginToken: function() {
      return this.leftBracket;
    },
    get$endToken: function() {
      return this.rightBracket;
    },
    visitChildren$1: function(visitor) {
      this._statements.accept$1(visitor);
    }
  },
  BlockFunctionBody: {
    "^": "FunctionBody;keyword<,star,_block,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitBlockFunctionBody$1(this);
    },
    get$beginToken: function() {
      return this._block.get$beginToken();
    },
    get$endToken: function() {
      return this._block.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._block;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  BooleanLiteral: {
    "^": "Literal;literal,value,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitBooleanLiteral$1(this);
    },
    get$beginToken: function() {
      return this.literal;
    },
    get$endToken: function() {
      return this.literal;
    },
    visitChildren$1: function(visitor) {
    }
  },
  BreakStatement: {
    "^": "Statement;keyword<,_label,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitBreakStatement$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._label;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  CascadeExpression: {
    "^": "Expression;_target,_cascadeSections,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitCascadeExpression$1(this);
    },
    get$beginToken: function() {
      return this._target.get$beginToken();
    },
    get$endToken: function() {
      return this._cascadeSections.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._target;
      if (t1 != null)
        t1.accept$1(visitor);
      this._cascadeSections.accept$1(visitor);
    },
    $isCascadeExpression: true
  },
  CatchClause: {
    "^": "AstNode;onKeyword,_exceptionType,catchKeyword,_leftParenthesis,_exceptionParameter,comma,_stackTraceParameter,_rightParenthesis,_body,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitCatchClause$1(this);
    },
    get$beginToken: function() {
      var t1 = this.onKeyword;
      if (t1 != null)
        return t1;
      return this.catchKeyword;
    },
    get$endToken: function() {
      return this._body.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._exceptionType;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._exceptionParameter;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._stackTraceParameter;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isCatchClause: true
  },
  ClassDeclaration: {
    "^": "CompilationUnitMember;abstractKeyword,classKeyword,_name<,_typeParameters,_extendsClause,_withClause,_implementsClause,_nativeClause,leftBracket,_members,rightBracket,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitClassDeclaration$1(this);
    },
    get$endToken: function() {
      return this.rightBracket;
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._typeParameters;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._extendsClause;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._withClause;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._implementsClause;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._nativeClause;
      if (t1 != null)
        t1.accept$1(visitor);
      this._members.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var t1 = this.abstractKeyword;
      if (t1 != null)
        return t1;
      return this.classKeyword;
    },
    ClassDeclaration$12: function(comment, metadata, abstractKeyword, classKeyword, $name, typeParameters, extendsClause, withClause, implementsClause, leftBracket, members, rightBracket) {
      var t1 = N.ClassMember;
      this._members = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._name = this.becomeParentOf$1($name);
      this._typeParameters = this.becomeParentOf$1(typeParameters);
      this._extendsClause = this.becomeParentOf$1(extendsClause);
      this._withClause = this.becomeParentOf$1(withClause);
      this._implementsClause = this.becomeParentOf$1(implementsClause);
      this._members.addAll$1(0, members);
    }
  },
  ClassMember: {
    "^": "Declaration;",
    $isClassMember: true
  },
  ClassTypeAlias: {
    "^": "TypeAlias;_name<,_typeParameters,equals,abstractKeyword,_superclass,_withClause,_implementsClause,keyword,semicolon,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitClassTypeAlias$1(this);
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._typeParameters;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._superclass;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._withClause;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._implementsClause;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    ClassTypeAlias$11: function(comment, metadata, keyword, $name, typeParameters, equals, abstractKeyword, superclass, withClause, implementsClause, semicolon) {
      this._name = this.becomeParentOf$1($name);
      this._typeParameters = this.becomeParentOf$1(typeParameters);
      this._superclass = this.becomeParentOf$1(superclass);
      this._withClause = this.becomeParentOf$1(withClause);
      this._implementsClause = this.becomeParentOf$1(implementsClause);
    }
  },
  Combinator: {
    "^": "AstNode;keyword<",
    get$beginToken: function() {
      return this.keyword;
    },
    $isCombinator: true
  },
  Comment: {
    "^": "AstNode;tokens,_type<,_references,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitComment$1(this);
    },
    get$beginToken: function() {
      var t1 = this.tokens;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$endToken: function() {
      var t1, t2, t3;
      t1 = this.tokens;
      t2 = t1.length;
      t3 = t2 - 1;
      if (t3 < 0)
        return H.ioore(t1, t3);
      return t1[t3];
    },
    visitChildren$1: function(visitor) {
      this._references.accept$1(visitor);
    }
  },
  CommentReference: {
    "^": "AstNode;newKeyword,_identifier,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitCommentReference$1(this);
    },
    get$beginToken: function() {
      return this._identifier.get$beginToken();
    },
    get$endToken: function() {
      return this._identifier.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isCommentReference: true
  },
  CommentType: {
    "^": "Enum;name,ordinal",
    $isCommentType: true,
    $asEnum: function() {
      return [N.CommentType];
    },
    static: {"^": "CommentType_END_OF_LINE,CommentType_BLOCK,CommentType_DOCUMENTATION,CommentType_values"}
  },
  CompilationUnit: {
    "^": "AstNode;beginToken<,_scriptTag,_directives,_declarations,endToken<,element,lineInfo,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitCompilationUnit$1(this);
    },
    get$length: function(_) {
      var endToken = this.endToken;
      if (endToken == null)
        return 0;
      return endToken.offset + endToken.get$length(endToken);
    },
    get$offset: function() {
      return 0;
    },
    visitChildren$1: function(visitor) {
      var t1, childList, children;
      t1 = this._scriptTag;
      if (t1 != null)
        t1.accept$1(visitor);
      if (this._directivesAreBeforeDeclarations$0()) {
        this._directives.accept$1(visitor);
        this._declarations.accept$1(visitor);
      } else {
        childList = H.setRuntimeTypeInfo([], [N.AstNode]);
        C.JSArray_methods.addAll$1(childList, this._directives);
        C.JSArray_methods.addAll$1(childList, this._declarations);
        children = P.List_List$from(childList, true, null);
        t1 = $.get$AstNode_LEXICAL_ORDER();
        H.IterableMixinWorkaround_sortList(children, t1);
        t1 = H.setRuntimeTypeInfo(new H.ListIterator(children, children.length, 0, null), [H.getTypeArgumentByIndex(children, 0)]);
        for (; t1.moveNext$0();)
          t1._current.accept$1(visitor);
      }
    },
    _directivesAreBeforeDeclarations$0: function() {
      var t1, lastDirective, firstDeclaration, t2;
      t1 = this._directives;
      if (!t1.get$isEmpty(t1)) {
        t1 = this._declarations;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = true;
      if (t1)
        return true;
      t1 = this._directives;
      lastDirective = t1.$index(0, t1._elements.length - 1);
      firstDeclaration = this._declarations.$index(0, 0);
      t1 = lastDirective.get$offset();
      t2 = firstDeclaration.get$offset();
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 < t2;
    },
    CompilationUnit$5: function(beginToken, scriptTag, directives, declarations, endToken) {
      var t1 = N.Directive;
      this._directives = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      t1 = N.CompilationUnitMember;
      this._declarations = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._scriptTag = this.becomeParentOf$1(scriptTag);
      this._directives.addAll$1(0, directives);
      this._declarations.addAll$1(0, declarations);
    }
  },
  CompilationUnitMember: {
    "^": "Declaration;",
    $isCompilationUnitMember: true
  },
  ConditionalExpression: {
    "^": "Expression;_condition,question,_thenExpression,colon,_elseExpression,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitConditionalExpression$1(this);
    },
    get$beginToken: function() {
      return this._condition.get$beginToken();
    },
    get$endToken: function() {
      return this._elseExpression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._condition;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._thenExpression;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._elseExpression;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    ConditionalExpression$5: function(condition, question, thenExpression, colon, elseExpression) {
      this._condition = this.becomeParentOf$1(condition);
      this._thenExpression = this.becomeParentOf$1(thenExpression);
      this._elseExpression = this.becomeParentOf$1(elseExpression);
    }
  },
  ConstructorDeclaration: {
    "^": "ClassMember;externalKeyword<,constKeyword<,factoryKeyword<,_returnType,period,_name<,_parameters,separator,_initializers,_redirectedConstructor,_body,element,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitConstructorDeclaration$1(this);
    },
    get$endToken: function() {
      var t1 = this._body;
      if (t1 != null)
        return t1.get$endToken();
      else {
        t1 = this._initializers;
        if (!t1.get$isEmpty(t1))
          return this._initializers.get$endToken();
      }
      return this._parameters.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._returnType;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._parameters;
      if (t1 != null)
        t1.accept$1(visitor);
      this._initializers.accept$1(visitor);
      t1 = this._redirectedConstructor;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var leftMost = this._leftMost$1([this.externalKeyword, this.constKeyword, this.factoryKeyword]);
      if (leftMost != null)
        return leftMost;
      return this._returnType.get$beginToken();
    },
    _leftMost$1: function(tokens) {
      var t1, leftMost, token, t2;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(tokens, 3, 0, null), [H.getTypeArgumentByIndex(tokens, 0)]), leftMost = null; t1.moveNext$0();) {
        token = t1._current;
        if (token != null) {
          t2 = token.get$offset();
          if (typeof t2 !== "number")
            return t2.$lt();
          t2 = t2 < 2147483647;
        } else
          t2 = false;
        if (t2)
          leftMost = token;
      }
      return leftMost;
    },
    ConstructorDeclaration$13: function(comment, metadata, externalKeyword, constKeyword, factoryKeyword, returnType, period, $name, parameters, separator, initializers, redirectedConstructor, body) {
      var t1 = N.ConstructorInitializer;
      this._initializers = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._returnType = this.becomeParentOf$1(returnType);
      this._name = this.becomeParentOf$1($name);
      this._parameters = this.becomeParentOf$1(parameters);
      this._initializers.addAll$1(0, initializers);
      this._redirectedConstructor = this.becomeParentOf$1(redirectedConstructor);
      this._body = this.becomeParentOf$1(body);
    }
  },
  ConstructorFieldInitializer: {
    "^": "ConstructorInitializer;keyword<,period,_fieldName,equals,_expression,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitConstructorFieldInitializer$1(this);
    },
    get$beginToken: function() {
      var t1 = this.keyword;
      if (t1 != null)
        return t1;
      return this._fieldName.get$beginToken();
    },
    get$endToken: function() {
      return this._expression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._fieldName;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ConstructorInitializer: {
    "^": "AstNode;",
    $isConstructorInitializer: true
  },
  ConstructorName: {
    "^": "AstNode;_type<,period,_name<,_staticElement,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitConstructorName$1(this);
    },
    get$beginToken: function() {
      return this._type.get$beginToken();
    },
    get$endToken: function() {
      var t1 = this._name;
      if (t1 != null)
        return t1.get$endToken();
      return this._type.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ContinueStatement: {
    "^": "Statement;keyword<,_label,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitContinueStatement$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._label;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  Declaration: {
    "^": "AnnotatedNode;"
  },
  DeclaredIdentifier: {
    "^": "Declaration;keyword<,_type<,_identifier,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitDeclaredIdentifier$1(this);
    },
    get$endToken: function() {
      return this._identifier.get$endToken();
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var t1 = this.keyword;
      if (t1 != null)
        return t1;
      else {
        t1 = this._type;
        if (t1 != null)
          return t1.get$beginToken();
      }
      return this._identifier.get$beginToken();
    }
  },
  DefaultFormalParameter: {
    "^": "FormalParameter;_parameter,kind<,separator,_defaultValue,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitDefaultFormalParameter$1(this);
    },
    get$beginToken: function() {
      return this._parameter.get$beginToken();
    },
    get$endToken: function() {
      var t1 = this._defaultValue;
      if (t1 != null)
        return t1.get$endToken();
      return this._parameter.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._parameter;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._defaultValue;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isDefaultFormalParameter: true
  },
  Directive: {
    "^": "AnnotatedNode;",
    $isDirective: true
  },
  DoStatement: {
    "^": "Statement;doKeyword,_body,whileKeyword,_leftParenthesis,_condition,_rightParenthesis,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitDoStatement$1(this);
    },
    get$beginToken: function() {
      return this.doKeyword;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._condition;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  DoubleLiteral: {
    "^": "Literal;literal,value,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitDoubleLiteral$1(this);
    },
    get$beginToken: function() {
      return this.literal;
    },
    get$endToken: function() {
      return this.literal;
    },
    visitChildren$1: function(visitor) {
    }
  },
  EmptyFunctionBody: {
    "^": "FunctionBody;semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitEmptyFunctionBody$1(this);
    },
    get$beginToken: function() {
      return this.semicolon;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
    },
    $isEmptyFunctionBody: true
  },
  EmptyStatement: {
    "^": "Statement;semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitEmptyStatement$1(this);
    },
    get$beginToken: function() {
      return this.semicolon;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
    }
  },
  EnumConstantDeclaration: {
    "^": "Declaration;_name<,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitEnumConstantDeclaration$1(this);
    },
    get$endToken: function() {
      return this._name.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this._name.get$beginToken();
    },
    $isEnumConstantDeclaration: true
  },
  EnumDeclaration: {
    "^": "CompilationUnitMember;keyword<,_name<,leftBracket,_constants,rightBracket,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitEnumDeclaration$1(this);
    },
    get$endToken: function() {
      return this.rightBracket;
    },
    get$name: function() {
      return this._name;
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this.keyword;
    },
    EnumDeclaration$7: function(comment, metadata, keyword, $name, leftBracket, constants, rightBracket) {
      var t1 = N.EnumConstantDeclaration;
      this._constants = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._name = this.becomeParentOf$1($name);
      this._constants.addAll$1(0, constants);
    }
  },
  ExportDirective: {
    "^": "NamespaceDirective;keyword,_combinators,semicolon,_uri,uriContent,source,_ast$_element,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitExportDirective$1(this);
    },
    visitChildren$1: function(visitor) {
      N.UriBasedDirective.prototype.visitChildren$1.call(this, visitor);
      this._combinators.accept$1(visitor);
    },
    $isExportDirective: true
  },
  Expression: {
    "^": "AstNode;",
    get$isAssignable: function() {
      return false;
    },
    $isExpression: true
  },
  ExpressionFunctionBody: {
    "^": "FunctionBody;keyword<,functionDefinition,_expression,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitExpressionFunctionBody$1(this);
    },
    get$beginToken: function() {
      return this.functionDefinition;
    },
    get$endToken: function() {
      var t1 = this.semicolon;
      if (t1 != null)
        return t1;
      return this._expression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ExpressionStatement: {
    "^": "Statement;_expression,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitExpressionStatement$1(this);
    },
    get$beginToken: function() {
      return this._expression.get$beginToken();
    },
    get$endToken: function() {
      var t1 = this.semicolon;
      if (t1 != null)
        return t1;
      return this._expression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ExtendsClause: {
    "^": "AstNode;keyword<,_superclass,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitExtendsClause$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._superclass.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._superclass;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  FieldDeclaration: {
    "^": "ClassMember;staticKeyword<,_fieldList,semicolon,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFieldDeclaration$1(this);
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._fieldList;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var t1 = this.staticKeyword;
      if (t1 != null)
        return t1;
      return this._fieldList.get$beginToken();
    }
  },
  FieldFormalParameter: {
    "^": "NormalFormalParameter;keyword<,_type<,thisToken,period,_parameters,_comment,_metadata,_identifier,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFieldFormalParameter$1(this);
    },
    get$beginToken: function() {
      var t1 = this.keyword;
      if (t1 != null)
        return t1;
      else {
        t1 = this._type;
        if (t1 != null)
          return t1.get$beginToken();
      }
      return this.thisToken;
    },
    get$endToken: function() {
      return this._identifier.get$endToken();
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.NormalFormalParameter.prototype.visitChildren$1.call(this, visitor);
      t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._parameters;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isFieldFormalParameter: true
  },
  ForEachStatement: {
    "^": "Statement;awaitKeyword,forKeyword,leftParenthesis,_loopVariable,_identifier,inKeyword,_iterator,rightParenthesis,_body,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitForEachStatement$1(this);
    },
    get$beginToken: function() {
      return this.forKeyword;
    },
    get$endToken: function() {
      return this._body.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._loopVariable;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._iterator;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ForStatement: {
    "^": "Statement;forKeyword,leftParenthesis,_variableList,_initialization,leftSeparator,_condition,rightSeparator,_updaters,rightParenthesis,_body,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitForStatement$1(this);
    },
    get$beginToken: function() {
      return this.forKeyword;
    },
    get$endToken: function() {
      return this._body.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._variableList;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._initialization;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._condition;
      if (t1 != null)
        t1.accept$1(visitor);
      this._updaters.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    ForStatement$10: function(forKeyword, leftParenthesis, variableList, initialization, leftSeparator, condition, rightSeparator, updaters, rightParenthesis, body) {
      var t1 = N.Expression;
      this._updaters = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._variableList = this.becomeParentOf$1(variableList);
      this._initialization = this.becomeParentOf$1(initialization);
      this._condition = this.becomeParentOf$1(condition);
      this._updaters.addAll$1(0, updaters);
      this._body = this.becomeParentOf$1(body);
    },
    $isForStatement: true
  },
  FormalParameter: {
    "^": "AstNode;",
    $isFormalParameter: true
  },
  FormalParameterList: {
    "^": "AstNode;_leftParenthesis,_parameters,_leftDelimiter,_rightDelimiter,_rightParenthesis,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFormalParameterList$1(this);
    },
    get$beginToken: function() {
      return this._leftParenthesis;
    },
    get$endToken: function() {
      return this._rightParenthesis;
    },
    visitChildren$1: function(visitor) {
      this._parameters.accept$1(visitor);
    },
    FormalParameterList$5: function(leftParenthesis, parameters, leftDelimiter, rightDelimiter, rightParenthesis) {
      var t1 = N.FormalParameter;
      t1 = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._parameters = t1;
      this._leftParenthesis = leftParenthesis;
      t1.addAll$1(0, parameters);
      this._leftDelimiter = leftDelimiter;
      this._rightDelimiter = rightDelimiter;
      this._rightParenthesis = rightParenthesis;
    },
    static: {FormalParameterList$: function(leftParenthesis, parameters, leftDelimiter, rightDelimiter, rightParenthesis) {
        var t1 = new N.FormalParameterList(null, null, null, null, null, null, null);
        t1.FormalParameterList$5(leftParenthesis, parameters, leftDelimiter, rightDelimiter, rightParenthesis);
        return t1;
      }}
  },
  FunctionBody: {
    "^": "AstNode;",
    get$keyword: function() {
      return;
    }
  },
  FunctionDeclaration: {
    "^": "CompilationUnitMember;externalKeyword<,_returnType,propertyKeyword,_name<,_functionExpression,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFunctionDeclaration$1(this);
    },
    get$endToken: function() {
      return this._functionExpression.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._returnType;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._functionExpression;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var t1 = this.externalKeyword;
      if (t1 != null)
        return t1;
      t1 = this._returnType;
      if (t1 != null)
        return t1.get$beginToken();
      else {
        t1 = this.propertyKeyword;
        if (t1 != null)
          return t1;
        else {
          t1 = this._name;
          if (t1 != null)
            return t1.get$beginToken();
        }
      }
      return this._functionExpression.get$beginToken();
    },
    FunctionDeclaration$7: function(comment, metadata, externalKeyword, returnType, propertyKeyword, $name, functionExpression) {
      this._returnType = this.becomeParentOf$1(returnType);
      this._name = this.becomeParentOf$1($name);
      this._functionExpression = this.becomeParentOf$1(functionExpression);
    },
    static: {FunctionDeclaration$: function(comment, metadata, externalKeyword, returnType, propertyKeyword, $name, functionExpression) {
        var t1 = new N.FunctionDeclaration(externalKeyword, null, propertyKeyword, null, null, null, null, null, null);
        t1.AnnotatedNode$2(comment, metadata);
        t1.FunctionDeclaration$7(comment, metadata, externalKeyword, returnType, propertyKeyword, $name, functionExpression);
        return t1;
      }}
  },
  FunctionDeclarationStatement: {
    "^": "Statement;_functionDeclaration,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFunctionDeclarationStatement$1(this);
    },
    get$beginToken: function() {
      return this._functionDeclaration.get$beginToken();
    },
    get$endToken: function() {
      return this._functionDeclaration.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._functionDeclaration;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  FunctionExpression: {
    "^": "Expression;_parameters,_body,element,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFunctionExpression$1(this);
    },
    get$beginToken: function() {
      var t1 = this._parameters;
      if (t1 != null)
        return t1.get$beginToken();
      else {
        t1 = this._body;
        if (t1 != null)
          return t1.get$beginToken();
      }
      throw H.wrapException(L.IllegalStateException$("Non-external functions must have a body"));
    },
    get$endToken: function() {
      var t1 = this._body;
      if (t1 != null)
        return t1.get$endToken();
      else {
        t1 = this._parameters;
        if (t1 != null)
          return t1.get$endToken();
      }
      throw H.wrapException(L.IllegalStateException$("Non-external functions must have a body"));
    },
    visitChildren$1: function(visitor) {
      var t1 = this._parameters;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  FunctionExpressionInvocation: {
    "^": "Expression;_function,_argumentList,staticElement,_propagatedElement,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFunctionExpressionInvocation$1(this);
    },
    get$beginToken: function() {
      return this._function.get$beginToken();
    },
    get$endToken: function() {
      return this._argumentList.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._function;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._argumentList;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  FunctionTypeAlias: {
    "^": "TypeAlias;_returnType,_name<,_typeParameters,_parameters,keyword,semicolon,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFunctionTypeAlias$1(this);
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._returnType;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._typeParameters;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._parameters;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    FunctionTypeAlias$8: function(comment, metadata, keyword, returnType, $name, typeParameters, parameters, semicolon) {
      this._returnType = this.becomeParentOf$1(returnType);
      this._name = this.becomeParentOf$1($name);
      this._typeParameters = this.becomeParentOf$1(typeParameters);
      this._parameters = this.becomeParentOf$1(parameters);
    },
    static: {FunctionTypeAlias$: function(comment, metadata, keyword, returnType, $name, typeParameters, parameters, semicolon) {
        var t1 = new N.FunctionTypeAlias(null, null, null, null, keyword, semicolon, null, null, null, null);
        t1.AnnotatedNode$2(comment, metadata);
        t1.FunctionTypeAlias$8(comment, metadata, keyword, returnType, $name, typeParameters, parameters, semicolon);
        return t1;
      }}
  },
  FunctionTypedFormalParameter: {
    "^": "NormalFormalParameter;_returnType,_parameters,_comment,_metadata,_identifier,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitFunctionTypedFormalParameter$1(this);
    },
    get$beginToken: function() {
      var t1 = this._returnType;
      if (t1 != null)
        return t1.get$beginToken();
      return this._identifier.get$beginToken();
    },
    get$endToken: function() {
      return this._parameters.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.NormalFormalParameter.prototype.visitChildren$1.call(this, visitor);
      t1 = this._returnType;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._parameters;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  GeneralizingAstVisitor: {
    "^": "Object;",
    visitAdjacentStrings$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitAnnotation$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitArgumentList$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitAsExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitAssertStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitAssignmentExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitAwaitExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitBinaryExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitBlock$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitBlockFunctionBody$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitBooleanLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitBreakStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitCascadeExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitCatchClause$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitClassDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitClassTypeAlias$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitComment$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitCommentReference$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitCompilationUnit$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitConditionalExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitConstructorDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitConstructorFieldInitializer$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitConstructorName$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitContinueStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitDeclaredIdentifier$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitDefaultFormalParameter$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitDoStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitDoubleLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitEmptyFunctionBody$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitEmptyStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitEnumConstantDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitEnumDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitExportDirective$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitExpressionFunctionBody$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitExpressionStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitExtendsClause$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFieldDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFieldFormalParameter$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitForEachStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFormalParameterList$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitForStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFunctionDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFunctionDeclarationStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFunctionExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFunctionExpressionInvocation$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFunctionTypeAlias$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitFunctionTypedFormalParameter$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitHideCombinator$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitIfStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitImplementsClause$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitImportDirective$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitIndexExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitInstanceCreationExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitIntegerLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitInterpolationExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitInterpolationString$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitIsExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitLabel$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitLabeledStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitLibraryDirective$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitLibraryIdentifier$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitListLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitMapLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitMapLiteralEntry$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitMethodDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitMethodInvocation$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitNamedExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitNativeClause$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitNativeFunctionBody$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitNullLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitParenthesizedExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitPartDirective$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitPartOfDirective$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitPostfixExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitPrefixedIdentifier$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitPrefixExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitPropertyAccess$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitRedirectingConstructorInvocation$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitRethrowExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitReturnStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitScriptTag$1: function(scriptTag) {
      scriptTag.visitChildren$1(this);
      return;
    },
    visitShowCombinator$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSimpleFormalParameter$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSimpleIdentifier$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSimpleStringLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitStringInterpolation$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSuperConstructorInvocation$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSuperExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSwitchCase$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSwitchDefault$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSwitchStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitSymbolLiteral$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitThisExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitThrowExpression$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitTopLevelVariableDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitTryStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitTypeArgumentList$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitTypeName$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitTypeParameter$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitTypeParameterList$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitVariableDeclaration$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitVariableDeclarationList$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitVariableDeclarationStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitWhileStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitWithClause$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitYieldStatement$1: function(node) {
      node.visitChildren$1(this);
      return;
    }
  },
  HideCombinator: {
    "^": "Combinator;_hiddenNames,keyword,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitHideCombinator$1(this);
    },
    get$endToken: function() {
      return this._hiddenNames.get$endToken();
    },
    visitChildren$1: function(visitor) {
      this._hiddenNames.accept$1(visitor);
    }
  },
  Identifier: {
    "^": "Expression;",
    get$isAssignable: function() {
      return true;
    }
  },
  IfStatement: {
    "^": "Statement;ifKeyword,leftParenthesis,_condition,rightParenthesis,_thenStatement,elseKeyword,_elseStatement,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitIfStatement$1(this);
    },
    get$beginToken: function() {
      return this.ifKeyword;
    },
    get$endToken: function() {
      var t1 = this._elseStatement;
      if (t1 != null)
        return t1.get$endToken();
      return this._thenStatement.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._condition;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._thenStatement;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._elseStatement;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ImplementsClause: {
    "^": "AstNode;keyword<,_interfaces,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitImplementsClause$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._interfaces.get$endToken();
    },
    visitChildren$1: function(visitor) {
      this._interfaces.accept$1(visitor);
    }
  },
  ImportDirective: {
    "^": "NamespaceDirective;deferredToken,asToken,_prefix,keyword,_combinators,semicolon,_uri,uriContent,source,_ast$_element,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitImportDirective$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.UriBasedDirective.prototype.visitChildren$1.call(this, visitor);
      t1 = this._prefix;
      if (t1 != null)
        t1.accept$1(visitor);
      this._combinators.accept$1(visitor);
    },
    $isImportDirective: true,
    static: {"^": "ImportDirective_COMPARATOR"}
  },
  IndexExpression: {
    "^": "Expression;_target,period,_leftBracket,_ast$_index,_rightBracket,_staticElement,_propagatedElement,auxiliaryElements,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitIndexExpression$1(this);
    },
    get$beginToken: function() {
      var t1 = this._target;
      if (t1 != null)
        return t1.get$beginToken();
      return this.period;
    },
    get$endToken: function() {
      return this._rightBracket;
    },
    get$isAssignable: function() {
      return true;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._target;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._ast$_index;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  InstanceCreationExpression: {
    "^": "Expression;keyword<,_constructorName,_argumentList,staticElement,_result,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitInstanceCreationExpression$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._argumentList.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._constructorName;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._argumentList;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  IntegerLiteral: {
    "^": "Literal;literal,value,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitIntegerLiteral$1(this);
    },
    get$beginToken: function() {
      return this.literal;
    },
    get$endToken: function() {
      return this.literal;
    },
    visitChildren$1: function(visitor) {
    }
  },
  InterpolationElement: {
    "^": "AstNode;",
    $isInterpolationElement: true
  },
  InterpolationExpression: {
    "^": "InterpolationElement;leftBracket,_expression,rightBracket,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitInterpolationExpression$1(this);
    },
    get$beginToken: function() {
      return this.leftBracket;
    },
    get$endToken: function() {
      var t1 = this.rightBracket;
      if (t1 != null)
        return t1;
      return this._expression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  InterpolationString: {
    "^": "InterpolationElement;_ast$_contents,_ast$_value,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitInterpolationString$1(this);
    },
    get$beginToken: function() {
      return this._ast$_contents;
    },
    get$endToken: function() {
      return this._ast$_contents;
    },
    visitChildren$1: function(visitor) {
    }
  },
  IsExpression: {
    "^": "Expression;_expression,isOperator,notOperator,_type<,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitIsExpression$1(this);
    },
    get$beginToken: function() {
      return this._expression.get$beginToken();
    },
    get$endToken: function() {
      return this._type.get$endToken();
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  Label: {
    "^": "AstNode;_label,colon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitLabel$1(this);
    },
    get$beginToken: function() {
      return this._label.get$beginToken();
    },
    get$endToken: function() {
      return this.colon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._label;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isLabel: true
  },
  LabeledStatement: {
    "^": "Statement;_labels,_statement,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitLabeledStatement$1(this);
    },
    get$beginToken: function() {
      var t1 = this._labels;
      if (!t1.get$isEmpty(t1))
        return this._labels.get$beginToken();
      return this._statement.get$beginToken();
    },
    get$endToken: function() {
      return this._statement.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1;
      this._labels.accept$1(visitor);
      t1 = this._statement;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  LibraryDirective: {
    "^": "Directive;libraryToken,_name<,semicolon,_ast$_element,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitLibraryDirective$1(this);
    },
    get$endToken: function() {
      return this.semicolon;
    },
    get$keyword: function() {
      return this.libraryToken;
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this.libraryToken;
    },
    $isLibraryDirective: true
  },
  LibraryIdentifier: {
    "^": "Identifier;_components,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitLibraryIdentifier$1(this);
    },
    get$beginToken: function() {
      return this._components.get$beginToken();
    },
    get$endToken: function() {
      return this._components.get$endToken();
    },
    get$name: function() {
      var builder, t1, needsPeriod, identifier, t2, str;
      builder = new L.JavaStringBuilder(P.StringBuffer$(""));
      for (t1 = this._components, t1 = t1.get$iterator(t1), needsPeriod = false; t1.moveNext$0();) {
        identifier = t1._current;
        if (needsPeriod) {
          t2 = builder.sb;
          t2._contents += ".";
        } else
          needsPeriod = true;
        str = identifier.get$name();
        t2 = builder.sb;
        t2._contents += typeof str === "string" ? str : H.S(str);
      }
      return builder.sb._contents;
    },
    visitChildren$1: function(visitor) {
      this._components.accept$1(visitor);
    },
    LibraryIdentifier$1: function(components) {
      var t1 = N.SimpleIdentifier;
      t1 = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._components = t1;
      t1.addAll$1(0, components);
    },
    static: {LibraryIdentifier$: function(components) {
        var t1 = new N.LibraryIdentifier(null, null, null, null, null);
        t1.LibraryIdentifier$1(components);
        return t1;
      }}
  },
  ListLiteral: {
    "^": "TypedLiteral;_leftBracket,_elements<,_rightBracket,constKeyword,_typeArguments,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitListLiteral$1(this);
    },
    get$beginToken: function() {
      var token, typeArguments;
      token = this.constKeyword;
      if (token != null)
        return token;
      typeArguments = this._typeArguments;
      if (typeArguments != null)
        return typeArguments.get$beginToken();
      return this._leftBracket;
    },
    get$endToken: function() {
      return this._rightBracket;
    },
    visitChildren$1: function(visitor) {
      N.TypedLiteral.prototype.visitChildren$1.call(this, visitor);
      this._elements.accept$1(visitor);
    },
    ListLiteral$5: function(constKeyword, typeArguments, leftBracket, elements, rightBracket) {
      var t1 = N.Expression;
      t1 = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._elements = t1;
      this._leftBracket = leftBracket;
      t1.addAll$1(0, elements);
      this._rightBracket = rightBracket;
    },
    static: {ListLiteral$: function(constKeyword, typeArguments, leftBracket, elements, rightBracket) {
        var t1 = new N.ListLiteral(null, null, null, constKeyword, null, null, null, null, null);
        t1._typeArguments = t1.becomeParentOf$1(typeArguments);
        t1.ListLiteral$5(constKeyword, typeArguments, leftBracket, elements, rightBracket);
        return t1;
      }}
  },
  Literal: {
    "^": "Expression;"
  },
  MapLiteral: {
    "^": "TypedLiteral;_leftBracket,_entries,_rightBracket,constKeyword,_typeArguments,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitMapLiteral$1(this);
    },
    get$beginToken: function() {
      var token, typeArguments;
      token = this.constKeyword;
      if (token != null)
        return token;
      typeArguments = this._typeArguments;
      if (typeArguments != null)
        return typeArguments.get$beginToken();
      return this._leftBracket;
    },
    get$endToken: function() {
      return this._rightBracket;
    },
    visitChildren$1: function(visitor) {
      N.TypedLiteral.prototype.visitChildren$1.call(this, visitor);
      this._entries.accept$1(visitor);
    },
    MapLiteral$5: function(constKeyword, typeArguments, leftBracket, entries, rightBracket) {
      var t1 = N.MapLiteralEntry;
      t1 = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._entries = t1;
      this._leftBracket = leftBracket;
      t1.addAll$1(0, entries);
      this._rightBracket = rightBracket;
    },
    static: {MapLiteral$: function(constKeyword, typeArguments, leftBracket, entries, rightBracket) {
        var t1 = new N.MapLiteral(null, null, null, constKeyword, null, null, null, null, null);
        t1._typeArguments = t1.becomeParentOf$1(typeArguments);
        t1.MapLiteral$5(constKeyword, typeArguments, leftBracket, entries, rightBracket);
        return t1;
      }}
  },
  MapLiteralEntry: {
    "^": "AstNode;_key,separator,_ast$_value,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitMapLiteralEntry$1(this);
    },
    get$beginToken: function() {
      return this._key.get$beginToken();
    },
    get$endToken: function() {
      return this._ast$_value.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._key;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._ast$_value;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isMapLiteralEntry: true
  },
  MethodDeclaration: {
    "^": "ClassMember;externalKeyword<,modifierKeyword,_returnType,propertyKeyword,operatorKeyword,_name<,_parameters,_body,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitMethodDeclaration$1(this);
    },
    get$endToken: function() {
      return this._body.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._returnType;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._parameters;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var t1 = this.modifierKeyword;
      if (t1 != null)
        return t1;
      else {
        t1 = this._returnType;
        if (t1 != null)
          return t1.get$beginToken();
        else {
          t1 = this.propertyKeyword;
          if (t1 != null)
            return t1;
          else {
            t1 = this.operatorKeyword;
            if (t1 != null)
              return t1;
          }
        }
      }
      return this._name.get$beginToken();
    },
    MethodDeclaration$10: function(comment, metadata, externalKeyword, modifierKeyword, returnType, propertyKeyword, operatorKeyword, $name, parameters, body) {
      this._returnType = this.becomeParentOf$1(returnType);
      this._name = this.becomeParentOf$1($name);
      this._parameters = this.becomeParentOf$1(parameters);
      this._body = this.becomeParentOf$1(body);
    },
    static: {MethodDeclaration$: function(comment, metadata, externalKeyword, modifierKeyword, returnType, propertyKeyword, operatorKeyword, $name, parameters, body) {
        var t1 = new N.MethodDeclaration(externalKeyword, modifierKeyword, null, propertyKeyword, operatorKeyword, null, null, null, null, null, null, null);
        t1.AnnotatedNode$2(comment, metadata);
        t1.MethodDeclaration$10(comment, metadata, externalKeyword, modifierKeyword, returnType, propertyKeyword, operatorKeyword, $name, parameters, body);
        return t1;
      }}
  },
  MethodInvocation: {
    "^": "Expression;_target,period,_methodName,_argumentList,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitMethodInvocation$1(this);
    },
    get$beginToken: function() {
      var t1 = this._target;
      if (t1 != null)
        return t1.get$beginToken();
      else {
        t1 = this.period;
        if (t1 != null)
          return t1;
      }
      return this._methodName.get$beginToken();
    },
    get$endToken: function() {
      return this._argumentList.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._target;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._methodName;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._argumentList;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  NamedExpression: {
    "^": "Expression;_name<,_expression,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitNamedExpression$1(this);
    },
    get$beginToken: function() {
      return this._name.get$beginToken();
    },
    get$endToken: function() {
      return this._expression.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isNamedExpression: true
  },
  NamespaceDirective: {
    "^": "UriBasedDirective;keyword<",
    get$endToken: function() {
      return this.semicolon;
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this.keyword;
    }
  },
  NativeClause: {
    "^": "AstNode;keyword<,_name<,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitNativeClause$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._name.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  NativeFunctionBody: {
    "^": "FunctionBody;nativeToken,_stringLiteral,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitNativeFunctionBody$1(this);
    },
    get$beginToken: function() {
      return this.nativeToken;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._stringLiteral;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  NormalFormalParameter: {
    "^": "FormalParameter;",
    get$kind: function() {
      var $parent = this._parent;
      if (!!J.getInterceptor($parent).$isDefaultFormalParameter)
        return $parent.kind;
      return C.ParameterKind_false_REQUIRED_0;
    },
    get$metadata: function() {
      return this._metadata;
    },
    visitChildren$1: function(visitor) {
      var t1, childList, children;
      if (this._commentIsBeforeAnnotations$0()) {
        t1 = this._comment;
        if (t1 != null)
          t1.accept$1(visitor);
        this._metadata.accept$1(visitor);
      } else {
        childList = H.setRuntimeTypeInfo([], [N.AstNode]);
        childList.push(this._comment);
        C.JSArray_methods.addAll$1(childList, this._metadata);
        children = P.List_List$from(childList, true, null);
        t1 = $.get$AstNode_LEXICAL_ORDER();
        H.IterableMixinWorkaround_sortList(children, t1);
        t1 = H.setRuntimeTypeInfo(new H.ListIterator(children, children.length, 0, null), [H.getTypeArgumentByIndex(children, 0)]);
        for (; t1.moveNext$0();)
          t1._current.accept$1(visitor);
      }
    },
    _commentIsBeforeAnnotations$0: function() {
      var t1, firstAnnotation, t2;
      if (this._comment != null) {
        t1 = this._metadata;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = true;
      if (t1)
        return true;
      firstAnnotation = this._metadata.$index(0, 0);
      t1 = this._comment.get$offset();
      t2 = firstAnnotation.get$offset();
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 < t2;
    },
    NormalFormalParameter$3: function(comment, metadata, identifier) {
      var t1 = N.Annotation;
      this._metadata = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._comment = this.becomeParentOf$1(comment);
      this._metadata.addAll$1(0, metadata);
      this._identifier = this.becomeParentOf$1(identifier);
    }
  },
  NullLiteral: {
    "^": "Literal;literal,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitNullLiteral$1(this);
    },
    get$beginToken: function() {
      return this.literal;
    },
    get$endToken: function() {
      return this.literal;
    },
    visitChildren$1: function(visitor) {
    }
  },
  ParenthesizedExpression: {
    "^": "Expression;_leftParenthesis,_expression,_rightParenthesis,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitParenthesizedExpression$1(this);
    },
    get$beginToken: function() {
      return this._leftParenthesis;
    },
    get$endToken: function() {
      return this._rightParenthesis;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    ParenthesizedExpression$3: function(leftParenthesis, expression, rightParenthesis) {
      this._leftParenthesis = leftParenthesis;
      this._expression = this.becomeParentOf$1(expression);
      this._rightParenthesis = rightParenthesis;
    }
  },
  PartDirective: {
    "^": "UriBasedDirective;partToken,semicolon,_uri,uriContent,source,_ast$_element,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitPartDirective$1(this);
    },
    get$endToken: function() {
      return this.semicolon;
    },
    get$keyword: function() {
      return this.partToken;
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this.partToken;
    },
    $isPartDirective: true
  },
  PartOfDirective: {
    "^": "Directive;partToken,ofToken,_libraryName,semicolon,_ast$_element,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitPartOfDirective$1(this);
    },
    get$endToken: function() {
      return this.semicolon;
    },
    get$keyword: function() {
      return this.partToken;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._libraryName;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this.partToken;
    },
    $isPartOfDirective: true
  },
  PostfixExpression: {
    "^": "Expression;_operand,operator,_propagatedElement,_staticElement,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitPostfixExpression$1(this);
    },
    get$beginToken: function() {
      return this._operand.get$beginToken();
    },
    get$endToken: function() {
      return this.operator;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._operand;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  PrefixExpression: {
    "^": "Expression;operator,_operand,_staticElement,_propagatedElement,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitPrefixExpression$1(this);
    },
    get$beginToken: function() {
      return this.operator;
    },
    get$endToken: function() {
      return this._operand.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._operand;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  PrefixedIdentifier: {
    "^": "Identifier;_prefix,period,_identifier,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitPrefixedIdentifier$1(this);
    },
    get$beginToken: function() {
      return this._prefix.get$beginToken();
    },
    get$endToken: function() {
      return this._identifier.get$endToken();
    },
    get$name: function() {
      return H.S(this._prefix.get$name()) + "." + H.S(this._identifier.get$name());
    },
    visitChildren$1: function(visitor) {
      var t1 = this._prefix;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isPrefixedIdentifier: true
  },
  PropertyAccess: {
    "^": "Expression;_target,operator,_propertyName,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitPropertyAccess$1(this);
    },
    get$beginToken: function() {
      var t1 = this._target;
      if (t1 != null)
        return t1.get$beginToken();
      return this.operator;
    },
    get$endToken: function() {
      return this._propertyName.get$endToken();
    },
    get$isAssignable: function() {
      return true;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._target;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._propertyName;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isPropertyAccess: true
  },
  RedirectingConstructorInvocation: {
    "^": "ConstructorInitializer;keyword<,period,_constructorName,_argumentList,staticElement,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitRedirectingConstructorInvocation$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._argumentList.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._constructorName;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._argumentList;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  RethrowExpression: {
    "^": "Expression;keyword<,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitRethrowExpression$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.keyword;
    },
    visitChildren$1: function(visitor) {
    },
    $isRethrowExpression: true
  },
  ReturnStatement: {
    "^": "Statement;keyword<,_expression,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitReturnStatement$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  ScriptTag: {
    "^": "AstNode;scriptTag,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitScriptTag$1(this);
    },
    get$beginToken: function() {
      return this.scriptTag;
    },
    get$endToken: function() {
      return this.scriptTag;
    },
    visitChildren$1: function(visitor) {
    }
  },
  ShowCombinator: {
    "^": "Combinator;_shownNames,keyword,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitShowCombinator$1(this);
    },
    get$endToken: function() {
      return this._shownNames.get$endToken();
    },
    visitChildren$1: function(visitor) {
      this._shownNames.accept$1(visitor);
    }
  },
  SimpleFormalParameter: {
    "^": "NormalFormalParameter;keyword<,_type<,_comment,_metadata,_identifier,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSimpleFormalParameter$1(this);
    },
    get$beginToken: function() {
      var metadata, t1;
      metadata = this._metadata;
      if (!metadata.get$isEmpty(metadata))
        return metadata.get$beginToken();
      else {
        t1 = this.keyword;
        if (t1 != null)
          return t1;
        else {
          t1 = this._type;
          if (t1 != null)
            return t1.get$beginToken();
        }
      }
      return this._identifier.get$beginToken();
    },
    get$endToken: function() {
      return this._identifier.get$endToken();
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.NormalFormalParameter.prototype.visitChildren$1.call(this, visitor);
      t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._identifier;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  SimpleIdentifier: {
    "^": "Identifier;token<,_staticElement,_propagatedElement,auxiliaryElements,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSimpleIdentifier$1(this);
    },
    get$beginToken: function() {
      return this.token;
    },
    get$endToken: function() {
      return this.token;
    },
    get$name: function() {
      return this.token.get$lexeme();
    },
    visitChildren$1: function(visitor) {
    },
    $isSimpleIdentifier: true
  },
  SimpleStringLiteral: {
    "^": "StringLiteral;literal,_ast$_value,_toolkitElement,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSimpleStringLiteral$1(this);
    },
    get$beginToken: function() {
      return this.literal;
    },
    get$endToken: function() {
      return this.literal;
    },
    visitChildren$1: function(visitor) {
    }
  },
  Statement: {
    "^": "AstNode;",
    $isStatement: true
  },
  StringInterpolation: {
    "^": "StringLiteral;_elements<,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitStringInterpolation$1(this);
    },
    get$beginToken: function() {
      return this._elements.get$beginToken();
    },
    get$endToken: function() {
      return this._elements.get$endToken();
    },
    visitChildren$1: function(visitor) {
      this._elements.accept$1(visitor);
    }
  },
  StringLiteral: {
    "^": "Literal;",
    $isStringLiteral: true
  },
  SuperConstructorInvocation: {
    "^": "ConstructorInitializer;keyword<,period,_constructorName,_argumentList,staticElement,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSuperConstructorInvocation$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._argumentList.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._constructorName;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._argumentList;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  SuperExpression: {
    "^": "Expression;keyword<,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSuperExpression$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.keyword;
    },
    visitChildren$1: function(visitor) {
    }
  },
  SwitchCase: {
    "^": "SwitchMember;_expression,_labels,keyword,colon,_statements,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSwitchCase$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this._labels.accept$1(visitor);
      t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
      this._statements.accept$1(visitor);
    }
  },
  SwitchDefault: {
    "^": "SwitchMember;_labels,keyword,colon,_statements,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSwitchDefault$1(this);
    },
    visitChildren$1: function(visitor) {
      this._labels.accept$1(visitor);
      this._statements.accept$1(visitor);
    }
  },
  SwitchMember: {
    "^": "AstNode;keyword<",
    get$beginToken: function() {
      var t1 = this._labels;
      if (!t1.get$isEmpty(t1))
        return this._labels.get$beginToken();
      return this.keyword;
    },
    get$endToken: function() {
      var t1 = this._statements;
      if (!t1.get$isEmpty(t1))
        return this._statements.get$endToken();
      return this.colon;
    },
    $isSwitchMember: true
  },
  SwitchStatement: {
    "^": "Statement;keyword<,leftParenthesis,_expression,rightParenthesis,leftBracket,_members,rightBracket,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSwitchStatement$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.rightBracket;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
      this._members.accept$1(visitor);
    }
  },
  SymbolLiteral: {
    "^": "Literal;poundSign,components,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitSymbolLiteral$1(this);
    },
    get$beginToken: function() {
      return this.poundSign;
    },
    get$endToken: function() {
      var t1, t2, t3;
      t1 = this.components;
      t2 = t1.length;
      t3 = t2 - 1;
      if (t3 < 0)
        return H.ioore(t1, t3);
      return t1[t3];
    },
    visitChildren$1: function(visitor) {
    }
  },
  ThisExpression: {
    "^": "Expression;keyword<,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitThisExpression$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this.keyword;
    },
    visitChildren$1: function(visitor) {
    }
  },
  ThrowExpression: {
    "^": "Expression;keyword<,_expression,staticType,propagatedType,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitThrowExpression$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      var t1 = this._expression;
      if (t1 != null)
        return t1.get$endToken();
      return this.keyword;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isThrowExpression: true
  },
  ToSourceVisitor: {
    "^": "Object;_writer",
    visitAdjacentStrings$1: function(node) {
      this._visitNodeListWithSeparator$2(node._ast$_strings, " ");
      return;
    },
    visitAnnotation$1: function(node) {
      var t1;
      this._writer._sb.write$1("@");
      t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(".", node._constructorName);
      t1 = node._arguments;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitArgumentList$1: function(node) {
      var t1 = this._writer._sb;
      t1.write$1("(");
      this._visitNodeListWithSeparator$2(node._arguments, ", ");
      t1.write$1(")");
      return;
    },
    visitAsExpression$1: function(node) {
      var t1 = node._expression;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(" as ");
      t1 = node._type;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitAssertStatement$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("assert (");
      t2 = node._condition;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(");");
      return;
    },
    visitAssignmentExpression$1: function(node) {
      var t1 = node._leftHandSide;
      if (t1 != null)
        t1.accept$1(this);
      t1 = this._writer._sb;
      t1.write$1(" ");
      t1.write$1(node.operator.get$lexeme());
      t1.write$1(" ");
      t1 = node._rightHandSide;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitAwaitExpression$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("await ");
      t2 = node._expression;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    visitBinaryExpression$1: function(node) {
      var t1 = node._leftOperand;
      if (t1 != null)
        t1.accept$1(this);
      t1 = this._writer._sb;
      t1.write$1(" ");
      t1.write$1(node.operator.get$lexeme());
      t1.write$1(" ");
      t1 = node._rightOperand;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitBlock$1: function(node) {
      var t1 = this._writer._sb;
      t1.write$1("{");
      this._visitNodeListWithSeparator$2(node._statements, " ");
      t1.write$1("}");
      return;
    },
    visitBlockFunctionBody$1: function(node) {
      var keyword, t1;
      keyword = node.keyword;
      if (keyword != null) {
        t1 = this._writer._sb;
        t1.write$1(keyword.get$lexeme());
        if (node.star != null)
          t1.write$1("*");
        t1.write$1(" ");
      }
      t1 = node._block;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitBooleanLiteral$1: function(node) {
      this._writer._sb.write$1(node.literal.get$lexeme());
      return;
    },
    visitBreakStatement$1: function(node) {
      var t1 = this._writer._sb;
      t1.write$1("break");
      this._visitNodeWithPrefix$2(" ", node._label);
      t1.write$1(";");
      return;
    },
    visitCascadeExpression$1: function(node) {
      var t1 = node._target;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeListWithSeparator$2(node._cascadeSections, "");
      return;
    },
    visitCatchClause$1: function(node) {
      var t1, t2;
      this._visitNodeWithPrefix$2("on ", node._exceptionType);
      if (node.catchKeyword != null) {
        if (node._exceptionType != null)
          this._writer._sb.write$1(" ");
        t1 = this._writer._sb;
        t1.write$1("catch (");
        t2 = node._exceptionParameter;
        if (t2 != null)
          t2.accept$1(this);
        this._visitNodeWithPrefix$2(", ", node._stackTraceParameter);
        t1.write$1(") ");
      } else
        this._writer._sb.write$1(" ");
      t1 = node._body;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitClassDeclaration$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitTokenWithSuffix$2(node.abstractKeyword, " ");
      t1 = this._writer._sb;
      t1.write$1("class ");
      t2 = node._name;
      if (t2 != null)
        t2.accept$1(this);
      t2 = node._typeParameters;
      if (t2 != null)
        t2.accept$1(this);
      this._visitNodeWithPrefix$2(" ", node._extendsClause);
      this._visitNodeWithPrefix$2(" ", node._withClause);
      this._visitNodeWithPrefix$2(" ", node._implementsClause);
      t1.write$1(" {");
      this._visitNodeListWithSeparator$2(node._members, " ");
      t1.write$1("}");
      return;
    },
    visitClassTypeAlias$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      if (node.abstractKeyword != null)
        this._writer._sb.write$1("abstract ");
      t1 = this._writer._sb;
      t1.write$1("class ");
      t2 = node._name;
      if (t2 != null)
        t2.accept$1(this);
      t2 = node._typeParameters;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(" = ");
      t2 = node._superclass;
      if (t2 != null)
        t2.accept$1(this);
      this._visitNodeWithPrefix$2(" ", node._withClause);
      this._visitNodeWithPrefix$2(" ", node._implementsClause);
      t1.write$1(";");
      return;
    },
    visitComment$1: function(node) {
      return;
    },
    visitCommentReference$1: function(node) {
      return;
    },
    visitCompilationUnit$1: function(node) {
      var scriptTag, directives, t1, prefix;
      scriptTag = node._scriptTag;
      directives = node._directives;
      t1 = scriptTag == null;
      if (!t1)
        scriptTag.accept$1(this);
      this._visitNodeListWithSeparatorAndPrefix$3(t1 ? "" : " ", directives, " ");
      prefix = t1 && directives.get$isEmpty(directives) ? "" : " ";
      this._visitNodeListWithSeparatorAndPrefix$3(prefix, node._declarations, " ");
      return;
    },
    visitConditionalExpression$1: function(node) {
      var t1, t2;
      t1 = node._condition;
      if (t1 != null)
        t1.accept$1(this);
      t1 = this._writer._sb;
      t1.write$1(" ? ");
      t2 = node._thenExpression;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(" : ");
      t1 = node._elseExpression;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitConstructorDeclaration$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitTokenWithSuffix$2(node.externalKeyword, " ");
      this._visitTokenWithSuffix$2(node.constKeyword, " ");
      this._visitTokenWithSuffix$2(node.factoryKeyword, " ");
      t1 = node._returnType;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(".", node._name);
      t1 = node._parameters;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeListWithSeparatorAndPrefix$3(" : ", node._initializers, ", ");
      this._visitNodeWithPrefix$2(" = ", node._redirectedConstructor);
      this._visitFunctionWithPrefix$2(" ", node._body);
      return;
    },
    visitConstructorFieldInitializer$1: function(node) {
      var t1;
      this._visitTokenWithSuffix$2(node.keyword, ".");
      t1 = node._fieldName;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(" = ");
      t1 = node._expression;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitConstructorName$1: function(node) {
      var t1 = node._type;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(".", node._name);
      return;
    },
    visitContinueStatement$1: function(node) {
      var t1 = this._writer._sb;
      t1.write$1("continue");
      this._visitNodeWithPrefix$2(" ", node._label);
      t1.write$1(";");
      return;
    },
    visitDeclaredIdentifier$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitTokenWithSuffix$2(node.keyword, " ");
      this._visitNodeWithSuffix$2(node._type, " ");
      t1 = node._identifier;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitDefaultFormalParameter$1: function(node) {
      var t1, t2;
      t1 = node._parameter;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node.separator;
      if (t1 != null) {
        t2 = this._writer._sb;
        t2.write$1(" ");
        t2.write$1(t1.get$lexeme());
        this._visitNodeWithPrefix$2(" ", node._defaultValue);
      }
      return;
    },
    visitDoStatement$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("do ");
      t2 = node._body;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(" while (");
      t2 = node._condition;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(");");
      return;
    },
    visitDoubleLiteral$1: function(node) {
      this._writer._sb.write$1(node.literal.get$lexeme());
      return;
    },
    visitEmptyFunctionBody$1: function(node) {
      this._writer._sb.write$1(";");
      return;
    },
    visitEmptyStatement$1: function(node) {
      this._writer._sb.write$1(";");
      return;
    },
    visitEnumConstantDeclaration$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitEnumDeclaration$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("enum ");
      t2 = node._name;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(" {");
      this._visitNodeListWithSeparator$2(node._constants, ", ");
      t1.write$1("}");
      return;
    },
    visitExportDirective$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("export ");
      t2 = node._uri;
      if (t2 != null)
        t2.accept$1(this);
      this._visitNodeListWithSeparatorAndPrefix$3(" ", node._combinators, " ");
      t1.write$1(";");
      return;
    },
    visitExpressionFunctionBody$1: function(node) {
      var keyword, t1, t2;
      keyword = node.keyword;
      if (keyword != null) {
        t1 = this._writer._sb;
        t1.write$1(keyword.get$lexeme());
        t1.write$1(" ");
      }
      t1 = this._writer._sb;
      t1.write$1("=> ");
      t2 = node._expression;
      if (t2 != null)
        t2.accept$1(this);
      if (node.semicolon != null)
        t1.write$1(";");
      return;
    },
    visitExpressionStatement$1: function(node) {
      var t1 = node._expression;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(";");
      return;
    },
    visitExtendsClause$1: function(node) {
      var t1;
      this._writer._sb.write$1("extends ");
      t1 = node._superclass;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFieldDeclaration$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitTokenWithSuffix$2(node.staticKeyword, " ");
      t1 = node._fieldList;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(";");
      return;
    },
    visitFieldFormalParameter$1: function(node) {
      var t1;
      this._visitTokenWithSuffix$2(node.keyword, " ");
      this._visitNodeWithSuffix$2(node._type, " ");
      this._writer._sb.write$1("this.");
      t1 = node._identifier;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._parameters;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitForEachStatement$1: function(node) {
      var loopVariable, t1, t2;
      loopVariable = node._loopVariable;
      if (node.awaitKeyword != null)
        this._writer._sb.write$1("await ");
      t1 = this._writer._sb;
      t1.write$1("for (");
      if (loopVariable == null) {
        t2 = node._identifier;
        if (t2 != null)
          t2.accept$1(this);
      } else
        loopVariable.accept$1(this);
      t1.write$1(" in ");
      t2 = node._iterator;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(") ");
      t1 = node._body;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFormalParameterList$1: function(node) {
      var t1, parameters, size, groupEnd, i, t2, parameter;
      t1 = this._writer._sb;
      t1.write$1("(");
      parameters = node._parameters;
      size = parameters._elements.length;
      for (groupEnd = null, i = 0; i < size; ++i) {
        if (i >= parameters._elements.length)
          H.throwExpression(P.RangeError$("Index: " + i + ", Size: " + parameters._elements.length));
        t2 = parameters._elements;
        if (i >= t2.length)
          return H.ioore(t2, i);
        parameter = H.subtypeOfRuntimeTypeCast(t2[i], H.getTypeArgumentByIndex(parameters, 0));
        if (i > 0)
          t1._contents += ", ";
        if (groupEnd == null && !!J.getInterceptor(parameter).$isDefaultFormalParameter)
          if (parameter.get$kind() === C.ParameterKind_true_NAMED_2) {
            t1._contents += "{";
            groupEnd = "}";
          } else {
            t1._contents += "[";
            groupEnd = "]";
          }
        parameter.accept$1(this);
      }
      if (groupEnd != null)
        t1.write$1(groupEnd);
      t1.write$1(")");
      return;
    },
    visitForStatement$1: function(node) {
      var initialization, t1, t2;
      initialization = node._initialization;
      t1 = this._writer._sb;
      t1.write$1("for (");
      if (initialization != null)
        initialization.accept$1(this);
      else {
        t2 = node._variableList;
        if (t2 != null)
          t2.accept$1(this);
      }
      t1.write$1(";");
      this._visitNodeWithPrefix$2(" ", node._condition);
      t1.write$1(";");
      this._visitNodeListWithSeparatorAndPrefix$3(" ", node._updaters, ", ");
      t1.write$1(") ");
      t1 = node._body;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFunctionDeclaration$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitNodeWithSuffix$2(node._returnType, " ");
      this._visitTokenWithSuffix$2(node.propertyKeyword, " ");
      t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._functionExpression;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFunctionDeclarationStatement$1: function(node) {
      var t1 = node._functionDeclaration;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFunctionExpression$1: function(node) {
      var t1 = node._parameters;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(" ");
      t1 = node._body;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFunctionExpressionInvocation$1: function(node) {
      var t1 = node._function;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._argumentList;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitFunctionTypeAlias$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("typedef ");
      this._visitNodeWithSuffix$2(node._returnType, " ");
      t2 = node._name;
      if (t2 != null)
        t2.accept$1(this);
      t2 = node._typeParameters;
      if (t2 != null)
        t2.accept$1(this);
      t2 = node._parameters;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    visitFunctionTypedFormalParameter$1: function(node) {
      var t1;
      this._visitNodeWithSuffix$2(node._returnType, " ");
      t1 = node._identifier;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._parameters;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitHideCombinator$1: function(node) {
      this._writer._sb.write$1("hide ");
      this._visitNodeListWithSeparator$2(node._hiddenNames, ", ");
      return;
    },
    visitIfStatement$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("if (");
      t2 = node._condition;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(") ");
      t1 = node._thenStatement;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(" else ", node._elseStatement);
      return;
    },
    visitImplementsClause$1: function(node) {
      this._writer._sb.write$1("implements ");
      this._visitNodeListWithSeparator$2(node._interfaces, ", ");
      return;
    },
    visitImportDirective$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("import ");
      t2 = node._uri;
      if (t2 != null)
        t2.accept$1(this);
      if (node.deferredToken != null)
        t1.write$1(" deferred");
      this._visitNodeWithPrefix$2(" as ", node._prefix);
      this._visitNodeListWithSeparatorAndPrefix$3(" ", node._combinators, " ");
      t1.write$1(";");
      return;
    },
    visitIndexExpression$1: function(node) {
      var t1, t2;
      if (node.period != null)
        this._writer._sb.write$1("..");
      else {
        t1 = node._target;
        if (t1 != null)
          t1.accept$1(this);
      }
      t1 = this._writer._sb;
      t1.write$1("[");
      t2 = node._ast$_index;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1("]");
      return;
    },
    visitInstanceCreationExpression$1: function(node) {
      var t1;
      this._visitTokenWithSuffix$2(node.keyword, " ");
      t1 = node._constructorName;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._argumentList;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitIntegerLiteral$1: function(node) {
      this._writer._sb.write$1(node.literal.get$lexeme());
      return;
    },
    visitInterpolationExpression$1: function(node) {
      var t1, t2;
      t1 = this._writer;
      if (node.rightBracket != null) {
        t1 = t1._sb;
        t1.write$1("${");
        t2 = node._expression;
        if (t2 != null)
          t2.accept$1(this);
        t1.write$1("}");
      } else {
        t1._sb.write$1("$");
        t1 = node._expression;
        if (t1 != null)
          t1.accept$1(this);
      }
      return;
    },
    visitInterpolationString$1: function(node) {
      this._writer._sb.write$1(node._ast$_contents.get$lexeme());
      return;
    },
    visitIsExpression$1: function(node) {
      var t1 = node._expression;
      if (t1 != null)
        t1.accept$1(this);
      t1 = this._writer;
      if (node.notOperator == null)
        t1._sb.write$1(" is ");
      else
        t1._sb.write$1(" is! ");
      t1 = node._type;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitLabel$1: function(node) {
      var t1 = node._label;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(":");
      return;
    },
    visitLabeledStatement$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._labels, " ", " ");
      t1 = node._statement;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitLibraryDirective$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("library ");
      t2 = node._name;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    visitLibraryIdentifier$1: function(node) {
      this._writer._sb.write$1(node.get$name());
      return;
    },
    visitListLiteral$1: function(node) {
      var t1, t2;
      t1 = node.constKeyword;
      if (t1 != null) {
        t2 = this._writer._sb;
        t2.write$1(t1.get$lexeme());
        t2.write$1(" ");
      }
      this._visitNodeWithSuffix$2(node._typeArguments, " ");
      t1 = this._writer._sb;
      t1.write$1("[");
      this._visitNodeListWithSeparator$2(node._elements, ", ");
      t1.write$1("]");
      return;
    },
    visitMapLiteral$1: function(node) {
      var t1, t2;
      t1 = node.constKeyword;
      if (t1 != null) {
        t2 = this._writer._sb;
        t2.write$1(t1.get$lexeme());
        t2.write$1(" ");
      }
      this._visitNodeWithSuffix$2(node._typeArguments, " ");
      t1 = this._writer._sb;
      t1.write$1("{");
      this._visitNodeListWithSeparator$2(node._entries, ", ");
      t1.write$1("}");
      return;
    },
    visitMapLiteralEntry$1: function(node) {
      var t1 = node._key;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(" : ");
      t1 = node._ast$_value;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitMethodDeclaration$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitTokenWithSuffix$2(node.externalKeyword, " ");
      this._visitTokenWithSuffix$2(node.modifierKeyword, " ");
      this._visitNodeWithSuffix$2(node._returnType, " ");
      t1 = node.propertyKeyword;
      this._visitTokenWithSuffix$2(t1, " ");
      this._visitTokenWithSuffix$2(node.operatorKeyword, " ");
      t2 = node._name;
      if (t2 != null)
        t2.accept$1(this);
      if (!(t1 != null && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))) {
        t1 = node._parameters;
        if (t1 != null)
          t1.accept$1(this);
      }
      this._visitFunctionWithPrefix$2(" ", node._body);
      return;
    },
    visitMethodInvocation$1: function(node) {
      var t1 = node.period;
      if (t1 != null && t1.type === C.TokenType_mGg)
        this._writer._sb.write$1("..");
      else
        this._visitNodeWithSuffix$2(node._target, ".");
      t1 = node._methodName;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._argumentList;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitNamedExpression$1: function(node) {
      var t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(" ", node._expression);
      return;
    },
    visitNativeClause$1: function(node) {
      var t1;
      this._writer._sb.write$1("native ");
      t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitNativeFunctionBody$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("native ");
      t2 = node._stringLiteral;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    visitNullLiteral$1: function(node) {
      this._writer._sb.write$1("null");
      return;
    },
    visitParenthesizedExpression$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("(");
      t2 = node._expression;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(")");
      return;
    },
    visitPartDirective$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("part ");
      t2 = node._uri;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    visitPartOfDirective$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("part of ");
      t2 = node._libraryName;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    visitPostfixExpression$1: function(node) {
      var t1 = node._operand;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(node.operator.get$lexeme());
      return;
    },
    visitPrefixedIdentifier$1: function(node) {
      var t1 = node._prefix;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(".");
      t1 = node._identifier;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitPrefixExpression$1: function(node) {
      var t1;
      this._writer._sb.write$1(node.operator.get$lexeme());
      t1 = node._operand;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitPropertyAccess$1: function(node) {
      var t1 = node.operator;
      if (t1 != null && t1.type === C.TokenType_mGg)
        this._writer._sb.write$1("..");
      else {
        t1 = node._target;
        if (t1 != null)
          t1.accept$1(this);
        this._writer._sb.write$1(".");
      }
      t1 = node._propertyName;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitRedirectingConstructorInvocation$1: function(node) {
      var t1;
      this._writer._sb.write$1("this");
      this._visitNodeWithPrefix$2(".", node._constructorName);
      t1 = node._argumentList;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitRethrowExpression$1: function(node) {
      this._writer._sb.write$1("rethrow");
      return;
    },
    visitReturnStatement$1: function(node) {
      var expression, t1;
      expression = node._expression;
      t1 = this._writer;
      if (expression == null)
        t1._sb.write$1("return;");
      else {
        t1 = t1._sb;
        t1.write$1("return ");
        expression.accept$1(this);
        t1.write$1(";");
      }
      return;
    },
    visitScriptTag$1: function(node) {
      this._writer._sb.write$1(node.scriptTag.get$lexeme());
      return;
    },
    visitShowCombinator$1: function(node) {
      this._writer._sb.write$1("show ");
      this._visitNodeListWithSeparator$2(node._shownNames, ", ");
      return;
    },
    visitSimpleFormalParameter$1: function(node) {
      var t1;
      this._visitTokenWithSuffix$2(node.keyword, " ");
      this._visitNodeWithSuffix$2(node._type, " ");
      t1 = node._identifier;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitSimpleIdentifier$1: function(node) {
      this._writer._sb.write$1(node.token.get$lexeme());
      return;
    },
    visitSimpleStringLiteral$1: function(node) {
      this._writer._sb.write$1(node.literal.get$lexeme());
      return;
    },
    visitStringInterpolation$1: function(node) {
      this._visitNodeListWithSeparator$2(node._elements, "");
      return;
    },
    visitSuperConstructorInvocation$1: function(node) {
      var t1;
      this._writer._sb.write$1("super");
      this._visitNodeWithPrefix$2(".", node._constructorName);
      t1 = node._argumentList;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitSuperExpression$1: function(node) {
      this._writer._sb.write$1("super");
      return;
    },
    visitSwitchCase$1: function(node) {
      var t1, t2;
      this._visitNodeListWithSeparatorAndSuffix$3(node._labels, " ", " ");
      t1 = this._writer._sb;
      t1.write$1("case ");
      t2 = node._expression;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(": ");
      this._visitNodeListWithSeparator$2(node._statements, " ");
      return;
    },
    visitSwitchDefault$1: function(node) {
      this._visitNodeListWithSeparatorAndSuffix$3(node._labels, " ", " ");
      this._writer._sb.write$1("default: ");
      this._visitNodeListWithSeparator$2(node._statements, " ");
      return;
    },
    visitSwitchStatement$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("switch (");
      t2 = node._expression;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(") {");
      this._visitNodeListWithSeparator$2(node._members, " ");
      t1.write$1("}");
      return;
    },
    visitSymbolLiteral$1: function(node) {
      var t1, components, i, str;
      t1 = this._writer._sb;
      t1.write$1("#");
      components = node.components;
      for (i = 0; i < components.length; ++i) {
        if (i > 0)
          t1._contents += ".";
        str = components[i].get$lexeme();
        t1._contents += typeof str === "string" ? str : H.S(str);
      }
      return;
    },
    visitThisExpression$1: function(node) {
      this._writer._sb.write$1("this");
      return;
    },
    visitThrowExpression$1: function(node) {
      var t1;
      this._writer._sb.write$1("throw ");
      t1 = node._expression;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitTopLevelVariableDeclaration$1: function(node) {
      this._visitNodeWithSuffix$2(node._variableList, ";");
      return;
    },
    visitTryStatement$1: function(node) {
      var t1;
      this._writer._sb.write$1("try ");
      t1 = node._body;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeListWithSeparatorAndPrefix$3(" ", node._catchClauses, " ");
      this._visitNodeWithPrefix$2(" finally ", node._finallyBlock);
      return;
    },
    visitTypeArgumentList$1: function(node) {
      var t1 = this._writer._sb;
      t1.write$1("<");
      this._visitNodeListWithSeparator$2(node._arguments, ", ");
      t1.write$1(">");
      return;
    },
    visitTypeName$1: function(node) {
      var t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      t1 = node._typeArguments;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitTypeParameter$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(" extends ", node._bound);
      return;
    },
    visitTypeParameterList$1: function(node) {
      var t1 = this._writer._sb;
      t1.write$1("<");
      this._visitNodeListWithSeparator$2(node._typeParameters, ", ");
      t1.write$1(">");
      return;
    },
    visitVariableDeclaration$1: function(node) {
      var t1;
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      t1 = node._name;
      if (t1 != null)
        t1.accept$1(this);
      this._visitNodeWithPrefix$2(" = ", node._initializer);
      return;
    },
    visitVariableDeclarationList$1: function(node) {
      this._visitNodeListWithSeparatorAndSuffix$3(node._metadata, " ", " ");
      this._visitTokenWithSuffix$2(node.keyword, " ");
      this._visitNodeWithSuffix$2(node._type, " ");
      this._visitNodeListWithSeparator$2(node._variables, ", ");
      return;
    },
    visitVariableDeclarationStatement$1: function(node) {
      var t1 = node._variableList;
      if (t1 != null)
        t1.accept$1(this);
      this._writer._sb.write$1(";");
      return;
    },
    visitWhileStatement$1: function(node) {
      var t1, t2;
      t1 = this._writer._sb;
      t1.write$1("while (");
      t2 = node._condition;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(") ");
      t1 = node._body;
      if (t1 != null)
        t1.accept$1(this);
      return;
    },
    visitWithClause$1: function(node) {
      this._writer._sb.write$1("with ");
      this._visitNodeListWithSeparator$2(node._mixinTypes, ", ");
      return;
    },
    visitYieldStatement$1: function(node) {
      var t1, t2;
      t1 = this._writer;
      if (node.star != null) {
        t1 = t1._sb;
        t1.write$1("yield* ");
      } else {
        t1 = t1._sb;
        t1.write$1("yield ");
      }
      t2 = node._expression;
      if (t2 != null)
        t2.accept$1(this);
      t1.write$1(";");
      return;
    },
    _visitFunctionWithPrefix$2: function(prefix, body) {
      if (!J.getInterceptor(body).$isEmptyFunctionBody)
        this._writer._sb.write$1(prefix);
      if (body != null)
        body.accept$1(this);
    },
    _visitNodeListWithSeparator$2: function(nodes, separator) {
      var size, t1, i, t2;
      if (nodes != null) {
        size = nodes._elements.length;
        for (t1 = this._writer._sb, i = 0; i < size; ++i) {
          if (i > 0)
            t1._contents += separator;
          if (i >= nodes._elements.length)
            H.throwExpression(P.RangeError$("Index: " + i + ", Size: " + nodes._elements.length));
          t2 = nodes._elements;
          if (i >= t2.length)
            return H.ioore(t2, i);
          H.subtypeOfRuntimeTypeCast(t2[i], H.getTypeArgumentByIndex(nodes, 0)).accept$1(this);
        }
      }
    },
    _visitNodeListWithSeparatorAndPrefix$3: function(prefix, nodes, separator) {
      var size, t1, i, t2;
      if (nodes != null) {
        size = nodes._elements.length;
        if (size > 0) {
          t1 = this._writer._sb;
          t1.write$1(prefix);
          for (i = 0; i < size; ++i) {
            if (i > 0)
              t1._contents += separator;
            if (i >= nodes._elements.length)
              H.throwExpression(P.RangeError$("Index: " + i + ", Size: " + nodes._elements.length));
            t2 = nodes._elements;
            if (i >= t2.length)
              return H.ioore(t2, i);
            H.subtypeOfRuntimeTypeCast(t2[i], H.getTypeArgumentByIndex(nodes, 0)).accept$1(this);
          }
        }
      }
    },
    _visitNodeListWithSeparatorAndSuffix$3: function(nodes, separator, suffix) {
      var size, t1, i, t2;
      if (nodes != null) {
        size = nodes._elements.length;
        if (size > 0) {
          for (t1 = this._writer._sb, i = 0; i < size; ++i) {
            if (i > 0)
              t1._contents += separator;
            if (i >= nodes._elements.length)
              H.throwExpression(P.RangeError$("Index: " + i + ", Size: " + nodes._elements.length));
            t2 = nodes._elements;
            if (i >= t2.length)
              return H.ioore(t2, i);
            H.subtypeOfRuntimeTypeCast(t2[i], H.getTypeArgumentByIndex(nodes, 0)).accept$1(this);
          }
          t1.write$1(suffix);
        }
      }
    },
    _visitNodeWithPrefix$2: function(prefix, node) {
      if (node != null) {
        this._writer._sb.write$1(prefix);
        node.accept$1(this);
      }
    },
    _visitNodeWithSuffix$2: function(node, suffix) {
      if (node != null) {
        node.accept$1(this);
        this._writer._sb.write$1(suffix);
      }
    },
    _visitTokenWithSuffix$2: function(token, suffix) {
      var t1;
      if (token != null) {
        t1 = this._writer._sb;
        t1.write$1(token.get$lexeme());
        t1.write$1(suffix);
      }
    }
  },
  TopLevelVariableDeclaration: {
    "^": "CompilationUnitMember;_variableList,semicolon,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitTopLevelVariableDeclaration$1(this);
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._variableList;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this._variableList.get$beginToken();
    }
  },
  TryStatement: {
    "^": "Statement;tryKeyword,_body,_catchClauses,finallyKeyword,_finallyBlock,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitTryStatement$1(this);
    },
    get$beginToken: function() {
      return this.tryKeyword;
    },
    get$endToken: function() {
      var t1 = this._finallyBlock;
      if (t1 != null)
        return t1.get$endToken();
      else {
        t1 = this.finallyKeyword;
        if (t1 != null)
          return t1;
        else {
          t1 = this._catchClauses;
          if (!t1.get$isEmpty(t1))
            return this._catchClauses.get$endToken();
        }
      }
      return this._body.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
      this._catchClauses.accept$1(visitor);
      t1 = this._finallyBlock;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    TryStatement$5: function(tryKeyword, body, catchClauses, finallyKeyword, finallyBlock) {
      var t1 = N.CatchClause;
      this._catchClauses = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._body = this.becomeParentOf$1(body);
      this._catchClauses.addAll$1(0, catchClauses);
      this._finallyBlock = this.becomeParentOf$1(finallyBlock);
    }
  },
  TypeAlias: {
    "^": "CompilationUnitMember;keyword<",
    get$endToken: function() {
      return this.semicolon;
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this.keyword;
    }
  },
  TypeArgumentList: {
    "^": "AstNode;leftBracket,_arguments,rightBracket,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitTypeArgumentList$1(this);
    },
    get$beginToken: function() {
      return this.leftBracket;
    },
    get$endToken: function() {
      return this.rightBracket;
    },
    visitChildren$1: function(visitor) {
      this._arguments.accept$1(visitor);
    }
  },
  TypeName: {
    "^": "AstNode;_name<,_typeArguments,type<,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitTypeName$1(this);
    },
    get$beginToken: function() {
      return this._name.get$beginToken();
    },
    get$endToken: function() {
      var t1 = this._typeArguments;
      if (t1 != null)
        return t1.get$endToken();
      return this._name.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._typeArguments;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    $isTypeName: true
  },
  TypeParameter: {
    "^": "Declaration;_name<,keyword<,_bound,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitTypeParameter$1(this);
    },
    get$endToken: function() {
      var t1 = this._bound;
      if (t1 == null)
        return this._name.get$endToken();
      return t1.get$endToken();
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._bound;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this._name.get$beginToken();
    },
    $isTypeParameter: true
  },
  TypeParameterList: {
    "^": "AstNode;leftBracket,_typeParameters,rightBracket,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitTypeParameterList$1(this);
    },
    get$beginToken: function() {
      return this.leftBracket;
    },
    get$endToken: function() {
      return this.rightBracket;
    },
    visitChildren$1: function(visitor) {
      this._typeParameters.accept$1(visitor);
    }
  },
  TypedLiteral: {
    "^": "Literal;constKeyword<",
    visitChildren$1: function(visitor) {
      var t1 = this._typeArguments;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  UriBasedDirective: {
    "^": "Directive;",
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._uri;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  VariableDeclaration: {
    "^": "Declaration;_name<,equals,_initializer,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitVariableDeclaration$1(this);
    },
    get$endToken: function() {
      var t1 = this._initializer;
      if (t1 != null)
        return t1.get$endToken();
      return this._name.get$endToken();
    },
    get$initializer: function() {
      return this._initializer;
    },
    get$name: function() {
      return this._name;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._name;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._initializer;
      if (t1 != null)
        t1.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      return this._name.get$beginToken();
    },
    $isVariableDeclaration: true
  },
  VariableDeclarationList: {
    "^": "AnnotatedNode;keyword<,_type<,_variables<,_comment,_metadata,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitVariableDeclarationList$1(this);
    },
    get$endToken: function() {
      return this._variables.get$endToken();
    },
    get$type: function() {
      return this._type;
    },
    visitChildren$1: function(visitor) {
      var t1;
      N.AnnotatedNode.prototype.visitChildren$1.call(this, visitor);
      t1 = this._type;
      if (t1 != null)
        t1.accept$1(visitor);
      this._variables.accept$1(visitor);
    },
    get$firstTokenAfterCommentAndMetadata: function() {
      var t1 = this.keyword;
      if (t1 != null)
        return t1;
      else {
        t1 = this._type;
        if (t1 != null)
          return t1.get$beginToken();
      }
      return this._variables.get$beginToken();
    },
    VariableDeclarationList$5: function(comment, metadata, keyword, type, variables) {
      var t1 = N.VariableDeclaration;
      this._variables = H.setRuntimeTypeInfo(new N.NodeList(this, H.setRuntimeTypeInfo([], [t1])), [t1]);
      this._type = this.becomeParentOf$1(type);
      this._variables.addAll$1(0, variables);
    },
    static: {VariableDeclarationList$: function(comment, metadata, keyword, type, variables) {
        var t1 = new N.VariableDeclarationList(keyword, null, null, null, null, null, null);
        t1.AnnotatedNode$2(comment, metadata);
        t1.VariableDeclarationList$5(comment, metadata, keyword, type, variables);
        return t1;
      }}
  },
  VariableDeclarationStatement: {
    "^": "Statement;_variableList,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitVariableDeclarationStatement$1(this);
    },
    get$beginToken: function() {
      return this._variableList.get$beginToken();
    },
    get$endToken: function() {
      return this.semicolon;
    },
    visitChildren$1: function(visitor) {
      var t1 = this._variableList;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  WhileStatement: {
    "^": "Statement;keyword<,leftParenthesis,_condition,rightParenthesis,_body,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitWhileStatement$1(this);
    },
    get$beginToken: function() {
      return this.keyword;
    },
    get$endToken: function() {
      return this._body.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._condition;
      if (t1 != null)
        t1.accept$1(visitor);
      t1 = this._body;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  WithClause: {
    "^": "AstNode;_withKeyword,_mixinTypes,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitWithClause$1(this);
    },
    get$beginToken: function() {
      return this._withKeyword;
    },
    get$endToken: function() {
      return this._mixinTypes.get$endToken();
    },
    visitChildren$1: function(visitor) {
      this._mixinTypes.accept$1(visitor);
    }
  },
  YieldStatement: {
    "^": "Statement;yieldKeyword,star,_expression,semicolon,_parent,_propertyMap",
    accept$1: function(visitor) {
      return visitor.visitYieldStatement$1(this);
    },
    get$beginToken: function() {
      var t1 = this.yieldKeyword;
      if (t1 != null)
        return t1;
      return this._expression.get$beginToken();
    },
    get$endToken: function() {
      var t1 = this.semicolon;
      if (t1 != null)
        return t1;
      return this._expression.get$endToken();
    },
    visitChildren$1: function(visitor) {
      var t1 = this._expression;
      if (t1 != null)
        t1.accept$1(visitor);
    }
  },
  NodeList: {
    "^": "Object_ListMixin;owner,_elements<",
    accept$1: function(visitor) {
      var $length, i, t1;
      $length = this._elements.length;
      for (i = 0; i < $length; ++i) {
        t1 = this._elements;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].accept$1(visitor);
      }
    },
    add$1: function(_, node) {
      var t1, t2;
      t1 = this._elements.length;
      if (t1 > t1)
        H.throwExpression(P.RangeError$("Index: " + t1 + ", Size: " + this._elements.length));
      this.owner.becomeParentOf$1(node);
      if (t1 === 0)
        this._elements = H.setRuntimeTypeInfo([node], [H.getTypeArgumentByIndex(this, 0)]);
      else {
        t2 = this._elements;
        t2.toString;
        if (t1 > t2.length)
          H.throwExpression(P.RangeError$value(t1));
        if (typeof t2 !== "object" || t2 === null || !!t2.fixed$length)
          H.throwExpression(P.UnsupportedError$("insert"));
        t2.splice(t1, 0, node);
      }
    },
    addAll$1: function(_, nodes) {
      var t1, t2, node;
      if (nodes != null && !J.get$isEmpty$as(nodes)) {
        J.addAll$1$a(this._elements, nodes);
        for (t1 = J.get$iterator$a(nodes), t2 = this.owner; t1.moveNext$0();) {
          node = t1._current;
          if (node != null)
            node.set$parent(t2);
        }
        return true;
      }
      return false;
    },
    $index: function(_, index) {
      var t1;
      if (typeof index !== "number")
        return index.$lt();
      if (index < 0 || index >= this._elements.length)
        throw H.wrapException(P.RangeError$("Index: " + index + ", Size: " + this._elements.length));
      t1 = this._elements;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.subtypeOfRuntimeTypeCast(t1[index], H.getTypeArgumentByIndex(this, 0));
    },
    get$beginToken: function() {
      var t1, t2;
      t1 = this._elements;
      t2 = t1.length;
      if (t2 === 0)
        return;
      if (0 >= t2)
        return H.ioore(t1, 0);
      return t1[0].get$beginToken();
    },
    get$endToken: function() {
      var t1, t2, t3;
      t1 = this._elements;
      t2 = t1.length;
      if (t2 === 0)
        return;
      t3 = t2 - 1;
      if (t3 < 0)
        return H.ioore(t1, t3);
      return t1[t3].get$endToken();
    },
    $indexSet: function(_, index, node) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, this._elements.length))
        throw H.wrapException(P.RangeError$("Index: " + H.S(index) + ", Size: " + this._elements.length));
      if (node != null)
        node.set$parent(this.owner);
      t1 = this._elements;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = node;
    },
    get$length: function(_) {
      return this._elements.length;
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize NodeList."));
    }
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: true
  }
}],
["engine.error", "package:analyzer/src/generated/error.dart", , U, {
  "^": "",
  AnalysisError: {
    "^": "Object;errorCode,_message,_correction,source,_offset,_error$_length,isStaticOnly",
    $eq: function(_, obj) {
      var t1, t2;
      if (obj == null)
        return false;
      if (obj === this)
        return true;
      if (!J.getInterceptor(obj).$isAnalysisError)
        return false;
      if (this.errorCode !== obj.errorCode)
        return false;
      t1 = this._offset;
      t2 = obj._offset;
      if ((t1 == null ? t2 != null : t1 !== t2) || this._error$_length !== obj._error$_length)
        return false;
      if (this.isStaticOnly !== obj.isStaticOnly)
        return false;
      if (this._message !== obj._message)
        return false;
      return true;
    },
    get$length: function(_) {
      return this._error$_length;
    },
    get$offset: function() {
      return this._offset;
    },
    get$hashCode: function(_) {
      var hashCode, t1;
      hashCode = this._offset;
      t1 = C.JSString_methods.get$hashCode(this._message);
      if (typeof hashCode !== "number")
        return hashCode.$xor();
      return (hashCode ^ t1 ^ 0) >>> 0;
    },
    toString$0: function(_) {
      var t1, t2, t3;
      t1 = P.StringBuffer$("");
      t1.write$1("<unknown source>");
      t1.write$1("(");
      t1.write$1(this._offset);
      t1.write$1("..");
      t2 = this._offset;
      t3 = this._error$_length;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t1.write$1(t2 + t3 - 1);
      t1.write$1("): ");
      t1.write$1(this._message);
      return t1._contents;
    },
    AnalysisError$con2$5: function(source, offset, $length, errorCode, $arguments) {
      var t1, correctionTemplate;
      this._offset = offset;
      this._error$_length = $length;
      t1 = this.errorCode;
      this._message = L.formatList(t1.get$message(), $arguments);
      correctionTemplate = t1.get$correction();
      if (correctionTemplate != null)
        this._correction = L.formatList(correctionTemplate, $arguments);
    },
    $isAnalysisError: true,
    static: {"^": "AnalysisError_NO_ERRORS,AnalysisError_FILE_COMPARATOR,AnalysisError_ERROR_CODE_COMPARATOR", AnalysisError$con2: function(source, offset, $length, errorCode, $arguments) {
        var t1 = new U.AnalysisError(errorCode, null, null, source, 0, 0, false);
        t1.AnalysisError$con2$5(source, offset, $length, errorCode, $arguments);
        return t1;
      }}
  },
  AnalysisErrorListener: {
    "^": "Object;"
  },
  BooleanErrorListener: {
    "^": "Object;_errorReported<",
    onError$1: function(error) {
      this._errorReported = true;
    }
  },
  CompileTimeErrorCode: {
    "^": "Enum;message<,correction<,name,ordinal",
    get$type: function() {
      return C.ErrorType_U01;
    },
    $isCompileTimeErrorCode: true,
    $asEnum: function() {
      return [U.CompileTimeErrorCode];
    },
    static: {"^": "CompileTimeErrorCode_ACCESS_PRIVATE_ENUM_FIELD,CompileTimeErrorCode_AMBIGUOUS_EXPORT,CompileTimeErrorCode_ARGUMENT_DEFINITION_TEST_NON_PARAMETER,CompileTimeErrorCode_ASYNC_FOR_IN_WRONG_CONTEXT,CompileTimeErrorCode_AWAIT_IN_WRONG_CONTEXT,CompileTimeErrorCode_BUILT_IN_IDENTIFIER_AS_TYPE,CompileTimeErrorCode_BUILT_IN_IDENTIFIER_AS_TYPE_NAME,CompileTimeErrorCode_BUILT_IN_IDENTIFIER_AS_TYPEDEF_NAME,CompileTimeErrorCode_BUILT_IN_IDENTIFIER_AS_TYPE_PARAMETER_NAME,CompileTimeErrorCode_CASE_EXPRESSION_TYPE_IMPLEMENTS_EQUALS,CompileTimeErrorCode_COMPILE_TIME_CONSTANT_RAISES_EXCEPTION,CompileTimeErrorCode_CONFLICTING_GETTER_AND_METHOD,CompileTimeErrorCode_CONFLICTING_METHOD_AND_GETTER,CompileTimeErrorCode_CONFLICTING_CONSTRUCTOR_NAME_AND_FIELD,CompileTimeErrorCode_CONFLICTING_CONSTRUCTOR_NAME_AND_METHOD,CompileTimeErrorCode_CONFLICTING_TYPE_VARIABLE_AND_CLASS,CompileTimeErrorCode_CONFLICTING_TYPE_VARIABLE_AND_MEMBER,CompileTimeErrorCode_CONST_CONSTRUCTOR_THROWS_EXCEPTION,CompileTimeErrorCode_CONST_CONSTRUCTOR_WITH_FIELD_INITIALIZED_BY_NON_CONST,CompileTimeErrorCode_CONST_CONSTRUCTOR_WITH_MIXIN,CompileTimeErrorCode_CONST_CONSTRUCTOR_WITH_NON_CONST_SUPER,CompileTimeErrorCode_CONST_CONSTRUCTOR_WITH_NON_FINAL_FIELD,CompileTimeErrorCode_CONST_DEFERRED_CLASS,CompileTimeErrorCode_CONST_FORMAL_PARAMETER,CompileTimeErrorCode_CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE,CompileTimeErrorCode_CONST_INITIALIZED_WITH_NON_CONSTANT_VALUE_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_CONST_INSTANCE_FIELD,CompileTimeErrorCode_CONST_MAP_KEY_EXPRESSION_TYPE_IMPLEMENTS_EQUALS,CompileTimeErrorCode_CONST_NOT_INITIALIZED,CompileTimeErrorCode_CONST_EVAL_TYPE_BOOL,CompileTimeErrorCode_CONST_EVAL_TYPE_BOOL_NUM_STRING,CompileTimeErrorCode_CONST_EVAL_TYPE_INT,CompileTimeErrorCode_CONST_EVAL_TYPE_NUM,CompileTimeErrorCode_CONST_EVAL_THROWS_EXCEPTION,CompileTimeErrorCode_CONST_EVAL_THROWS_IDBZE,CompileTimeErrorCode_CONST_WITH_INVALID_TYPE_PARAMETERS,CompileTimeErrorCode_CONST_WITH_NON_CONST,CompileTimeErrorCode_CONST_WITH_NON_CONSTANT_ARGUMENT,CompileTimeErrorCode_CONST_WITH_NON_TYPE,CompileTimeErrorCode_CONST_WITH_TYPE_PARAMETERS,CompileTimeErrorCode_CONST_WITH_UNDEFINED_CONSTRUCTOR,CompileTimeErrorCode_CONST_WITH_UNDEFINED_CONSTRUCTOR_DEFAULT,CompileTimeErrorCode_DEFAULT_VALUE_IN_FUNCTION_TYPE_ALIAS,CompileTimeErrorCode_DEFAULT_VALUE_IN_FUNCTION_TYPED_PARAMETER,CompileTimeErrorCode_DEFAULT_VALUE_IN_REDIRECTING_FACTORY_CONSTRUCTOR,CompileTimeErrorCode_DUPLICATE_CONSTRUCTOR_DEFAULT,CompileTimeErrorCode_DUPLICATE_CONSTRUCTOR_NAME,CompileTimeErrorCode_DUPLICATE_DEFINITION,CompileTimeErrorCode_DUPLICATE_DEFINITION_INHERITANCE,CompileTimeErrorCode_DUPLICATE_NAMED_ARGUMENT,CompileTimeErrorCode_EXPORT_INTERNAL_LIBRARY,CompileTimeErrorCode_EXPORT_OF_NON_LIBRARY,CompileTimeErrorCode_EXTENDS_ENUM,CompileTimeErrorCode_EXTENDS_NON_CLASS,CompileTimeErrorCode_EXTENDS_DISALLOWED_CLASS,CompileTimeErrorCode_EXTENDS_DEFERRED_CLASS,CompileTimeErrorCode_EXTRA_POSITIONAL_ARGUMENTS,CompileTimeErrorCode_FIELD_INITIALIZED_BY_MULTIPLE_INITIALIZERS,CompileTimeErrorCode_FIELD_INITIALIZED_IN_PARAMETER_AND_INITIALIZER,CompileTimeErrorCode_FINAL_INITIALIZED_MULTIPLE_TIMES,CompileTimeErrorCode_FIELD_INITIALIZER_FACTORY_CONSTRUCTOR,CompileTimeErrorCode_FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR,CompileTimeErrorCode_FIELD_INITIALIZER_REDIRECTING_CONSTRUCTOR,CompileTimeErrorCode_GETTER_AND_METHOD_WITH_SAME_NAME,CompileTimeErrorCode_IMPLEMENTS_DEFERRED_CLASS,CompileTimeErrorCode_IMPLEMENTS_DISALLOWED_CLASS,CompileTimeErrorCode_IMPLEMENTS_DYNAMIC,CompileTimeErrorCode_IMPLEMENTS_ENUM,CompileTimeErrorCode_IMPLEMENTS_NON_CLASS,CompileTimeErrorCode_IMPLEMENTS_REPEATED,CompileTimeErrorCode_IMPLEMENTS_SUPER_CLASS,CompileTimeErrorCode_IMPLICIT_THIS_REFERENCE_IN_INITIALIZER,CompileTimeErrorCode_IMPORT_INTERNAL_LIBRARY,CompileTimeErrorCode_IMPORT_OF_NON_LIBRARY,CompileTimeErrorCode_INCONSISTENT_CASE_EXPRESSION_TYPES,CompileTimeErrorCode_INITIALIZER_FOR_NON_EXISTANT_FIELD,CompileTimeErrorCode_INITIALIZER_FOR_STATIC_FIELD,CompileTimeErrorCode_INITIALIZING_FORMAL_FOR_NON_EXISTANT_FIELD,CompileTimeErrorCode_INITIALIZING_FORMAL_FOR_STATIC_FIELD,CompileTimeErrorCode_INSTANCE_MEMBER_ACCESS_FROM_FACTORY,CompileTimeErrorCode_INSTANCE_MEMBER_ACCESS_FROM_STATIC,CompileTimeErrorCode_INSTANTIATE_ENUM,CompileTimeErrorCode_INVALID_ANNOTATION,CompileTimeErrorCode_INVALID_ANNOTATION_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_INVALID_IDENTIFIER_IN_ASYNC,CompileTimeErrorCode_INVALID_MODIFIER_ON_CONSTRUCTOR,CompileTimeErrorCode_INVALID_MODIFIER_ON_SETTER,CompileTimeErrorCode_INVALID_CONSTANT,CompileTimeErrorCode_INVALID_CONSTRUCTOR_NAME,CompileTimeErrorCode_INVALID_FACTORY_NAME_NOT_A_CLASS,CompileTimeErrorCode_INVALID_REFERENCE_TO_THIS,CompileTimeErrorCode_INVALID_TYPE_ARGUMENT_IN_CONST_LIST,CompileTimeErrorCode_INVALID_TYPE_ARGUMENT_IN_CONST_MAP,CompileTimeErrorCode_INVALID_URI,CompileTimeErrorCode_LABEL_IN_OUTER_SCOPE,CompileTimeErrorCode_LABEL_UNDEFINED,CompileTimeErrorCode_MEMBER_WITH_CLASS_NAME,CompileTimeErrorCode_METHOD_AND_GETTER_WITH_SAME_NAME,CompileTimeErrorCode_MISSING_CONST_IN_LIST_LITERAL,CompileTimeErrorCode_MISSING_CONST_IN_MAP_LITERAL,CompileTimeErrorCode_MISSING_ENUM_CONSTANT_IN_SWITCH,CompileTimeErrorCode_MIXIN_DECLARES_CONSTRUCTOR,CompileTimeErrorCode_MIXIN_DEFERRED_CLASS,CompileTimeErrorCode_MIXIN_INHERITS_FROM_NOT_OBJECT,CompileTimeErrorCode_MIXIN_OF_DISALLOWED_CLASS,CompileTimeErrorCode_MIXIN_OF_ENUM,CompileTimeErrorCode_MIXIN_OF_NON_CLASS,CompileTimeErrorCode_MIXIN_REFERENCES_SUPER,CompileTimeErrorCode_MIXIN_WITH_NON_CLASS_SUPERCLASS,CompileTimeErrorCode_MULTIPLE_REDIRECTING_CONSTRUCTOR_INVOCATIONS,CompileTimeErrorCode_MULTIPLE_SUPER_INITIALIZERS,CompileTimeErrorCode_NO_ANNOTATION_CONSTRUCTOR_ARGUMENTS,CompileTimeErrorCode_NO_DEFAULT_SUPER_CONSTRUCTOR_EXPLICIT,CompileTimeErrorCode_NO_DEFAULT_SUPER_CONSTRUCTOR_IMPLICIT,CompileTimeErrorCode_NON_CONST_MAP_AS_EXPRESSION_STATEMENT,CompileTimeErrorCode_NON_CONSTANT_CASE_EXPRESSION,CompileTimeErrorCode_NON_CONSTANT_CASE_EXPRESSION_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_NON_CONSTANT_DEFAULT_VALUE,CompileTimeErrorCode_NON_CONSTANT_DEFAULT_VALUE_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_NON_CONSTANT_LIST_ELEMENT,CompileTimeErrorCode_NON_CONSTANT_LIST_ELEMENT_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_NON_CONSTANT_MAP_KEY,CompileTimeErrorCode_NON_CONSTANT_MAP_KEY_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_NON_CONSTANT_MAP_VALUE,CompileTimeErrorCode_NON_CONSTANT_MAP_VALUE_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_NON_CONSTANT_ANNOTATION_CONSTRUCTOR,CompileTimeErrorCode_NON_CONSTANT_VALUE_IN_INITIALIZER,CompileTimeErrorCode_NON_CONSTANT_VALUE_IN_INITIALIZER_FROM_DEFERRED_LIBRARY,CompileTimeErrorCode_NOT_ENOUGH_REQUIRED_ARGUMENTS,CompileTimeErrorCode_NON_GENERATIVE_CONSTRUCTOR,CompileTimeErrorCode_OBJECT_CANNOT_EXTEND_ANOTHER_CLASS,CompileTimeErrorCode_OPTIONAL_PARAMETER_IN_OPERATOR,CompileTimeErrorCode_PART_OF_NON_PART,CompileTimeErrorCode_PREFIX_COLLIDES_WITH_TOP_LEVEL_MEMBER,CompileTimeErrorCode_PRIVATE_OPTIONAL_PARAMETER,CompileTimeErrorCode_RECURSIVE_COMPILE_TIME_CONSTANT,CompileTimeErrorCode_RECURSIVE_CONSTRUCTOR_REDIRECT,CompileTimeErrorCode_RECURSIVE_FACTORY_REDIRECT,CompileTimeErrorCode_RECURSIVE_INTERFACE_INHERITANCE,CompileTimeErrorCode_RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_EXTENDS,CompileTimeErrorCode_RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_IMPLEMENTS,CompileTimeErrorCode_RECURSIVE_INTERFACE_INHERITANCE_BASE_CASE_WITH,CompileTimeErrorCode_REDIRECT_TO_MISSING_CONSTRUCTOR,CompileTimeErrorCode_REDIRECT_TO_NON_CLASS,CompileTimeErrorCode_REDIRECT_TO_NON_CONST_CONSTRUCTOR,CompileTimeErrorCode_REDIRECT_GENERATIVE_TO_MISSING_CONSTRUCTOR,CompileTimeErrorCode_REDIRECT_GENERATIVE_TO_NON_GENERATIVE_CONSTRUCTOR,CompileTimeErrorCode_REFERENCED_BEFORE_DECLARATION,CompileTimeErrorCode_RETHROW_OUTSIDE_CATCH,CompileTimeErrorCode_RETURN_IN_GENERATIVE_CONSTRUCTOR,CompileTimeErrorCode_RETURN_IN_GENERATOR,CompileTimeErrorCode_SHARED_DEFERRED_PREFIX,CompileTimeErrorCode_SUPER_IN_INVALID_CONTEXT,CompileTimeErrorCode_SUPER_IN_REDIRECTING_CONSTRUCTOR,CompileTimeErrorCode_SUPER_INITIALIZER_IN_OBJECT,CompileTimeErrorCode_TYPE_ARGUMENT_NOT_MATCHING_BOUNDS,CompileTimeErrorCode_TYPE_ALIAS_CANNOT_REFERENCE_ITSELF,CompileTimeErrorCode_UNDEFINED_CLASS,CompileTimeErrorCode_UNDEFINED_CONSTRUCTOR_IN_INITIALIZER,CompileTimeErrorCode_UNDEFINED_CONSTRUCTOR_IN_INITIALIZER_DEFAULT,CompileTimeErrorCode_UNDEFINED_NAMED_PARAMETER,CompileTimeErrorCode_URI_DOES_NOT_EXIST,CompileTimeErrorCode_URI_WITH_INTERPOLATION,CompileTimeErrorCode_WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR,CompileTimeErrorCode_WRONG_NUMBER_OF_PARAMETERS_FOR_OPERATOR_MINUS,CompileTimeErrorCode_WRONG_NUMBER_OF_PARAMETERS_FOR_SETTER,CompileTimeErrorCode_YIELD_EACH_IN_NON_GENERATOR,CompileTimeErrorCode_YIELD_IN_NON_GENERATOR,CompileTimeErrorCode_values"}
  },
  ErrorSeverity: {
    "^": "Enum;machineCode,displayName,name,ordinal",
    $isErrorSeverity: true,
    $asEnum: function() {
      return [U.ErrorSeverity];
    },
    static: {"^": "ErrorSeverity_NONE,ErrorSeverity_INFO,ErrorSeverity_WARNING,ErrorSeverity_ERROR,ErrorSeverity_values"}
  },
  ErrorType: {
    "^": "Enum;severity,name,ordinal",
    $isErrorType: true,
    $asEnum: function() {
      return [U.ErrorType];
    },
    static: {"^": "ErrorType_TODO,ErrorType_HINT,ErrorType_COMPILE_TIME_ERROR,ErrorType_CHECKED_MODE_COMPILE_TIME_ERROR,ErrorType_PUB_SUGGESTION,ErrorType_STATIC_WARNING,ErrorType_STATIC_TYPE_WARNING,ErrorType_SYNTACTIC_ERROR,ErrorType_ANGULAR,ErrorType_POLYMER,ErrorType_values"}
  }
}],
["engine.instrumentation", "package:analyzer/src/generated/instrumentation.dart", , U, {
  "^": "",
  InstrumentationBuilder: {
    "^": "Object;"
  },
  InstrumentationBuilder_Instrumentation_NULL_INSTRUMENTATION_BUILDER: {
    "^": "Object;"
  },
  InstrumentationLogger_Instrumentation_NULL_LOGGER: {
    "^": "Object;"
  }
}],
["engine.parser", "package:analyzer/src/generated/parser.dart", , S, {
  "^": "",
  CommentAndMetadata: {
    "^": "Object;comment<,metadata<"
  },
  FinalConstVarOrType: {
    "^": "Object;keyword<,type<"
  },
  Modifiers: {
    "^": "Object;abstractKeyword,constKeyword<,externalKeyword<,factoryKeyword<,finalKeyword<,staticKeyword<,varKeyword<",
    toString$0: function(_) {
      var builder = new L.JavaStringBuilder(P.StringBuffer$(""));
      this._appendKeyword$3(builder, this._appendKeyword$3(builder, this._appendKeyword$3(builder, this._appendKeyword$3(builder, this._appendKeyword$3(builder, this._appendKeyword$3(builder, this._appendKeyword$3(builder, false, this.abstractKeyword), this.constKeyword), this.externalKeyword), this.factoryKeyword), this.finalKeyword), this.staticKeyword), this.varKeyword);
      return builder.sb._contents;
    },
    _appendKeyword$3: function(builder, needsSpace, keyword) {
      var t1;
      if (keyword != null) {
        if (needsSpace)
          builder.sb.write$1(H.Primitives_stringFromCharCode(32));
        t1 = keyword.get$lexeme();
        builder.sb.write$1(t1);
        return true;
      }
      return needsSpace;
    }
  },
  Parser: {
    "^": "Object;_source,_errorListener,_errorListenerLock,_parseFunctionBodies,_parseAsync,_parseDeferredLibraries,_parseEnum,_currentToken,_inAsync,_inGenerator,_inLoop,_inSwitch,_inInitializer",
    parseCompilationUnit$1: function(token) {
      var instrumentation, t1;
      $.get$Instrumentation__CURRENT_LOGGER().toString;
      instrumentation = $.get$Instrumentation__NULL_INSTRUMENTATION_BUILDER();
      try {
        this._currentToken = token;
        t1 = this.parseCompilationUnit2$0();
        return t1;
      } finally {
        instrumentation.toString;
      }
    },
    parseArgument$0: function() {
      var t1, t2, label, node, node0;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 !== C.TokenType_nrs)
        t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
      else
        t1 = true;
      if (t1 && this._currentToken._next.type === C.TokenType_chs) {
        label = this.parseSimpleIdentifier$0();
        node = new N.Label(null, this._expect$1(C.TokenType_chs), null, null);
        label.set$parent(node);
        node._label = label;
        node0 = this.parseExpression2$0();
        t1 = new N.NamedExpression(null, null, null, null, null, null);
        node.set$parent(t1);
        t1._name = node;
        if (node0 != null)
          node0.set$parent(t1);
        t1._expression = node0;
        return t1;
      } else
        return this.parseExpression2$0();
    },
    parseArgumentList$0: function() {
      var leftParenthesis, $arguments, wasInInitializer, argument, foundNamedArgument, generatedError, blankArgument, rightParenthesis, arguments0, t1, t2, t3, t4;
      leftParenthesis = this._expect$1(C.TokenType_MD7);
      arguments0 = [];
      arguments0.$builtinTypeInfo = [N.Expression];
      $arguments = arguments0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_kC8) {
        this._currentToken = t1._next;
        t2 = new N.ArgumentList(null, null, null, null, null, null, null);
        t3 = N.Expression;
        t4 = [];
        t4.$builtinTypeInfo = [t3];
        t4 = new N.NodeList(t2, t4);
        t4.$builtinTypeInfo = [t3];
        t2._arguments = t4;
        t2._leftParenthesis = leftParenthesis;
        t4.addAll$1(0, $arguments);
        t2._rightParenthesis = t1;
        return t2;
      }
      wasInInitializer = this._inInitializer;
      this._inInitializer = false;
      try {
        argument = this.parseArgument$0();
        J.add$1$a($arguments, argument);
        foundNamedArgument = !!J.getInterceptor(argument).$isNamedExpression;
        generatedError = false;
        for (; this._optional$1(C.TokenType_s8I);) {
          argument = this.parseArgument$0();
          J.add$1$a($arguments, argument);
          if (foundNamedArgument === true) {
            blankArgument = !!J.getInterceptor(argument).$isSimpleIdentifier && H.interceptedTypeCast(argument, "$isSimpleIdentifier").token.get$lexeme().length === 0;
            if (generatedError !== true)
              t1 = !(!!J.getInterceptor(argument).$isNamedExpression && blankArgument !== true);
            else
              t1 = false;
            if (t1) {
              this._reportErrorForToken$3(C.ParserErrorCode_AeS, this._currentToken, []);
              generatedError = true;
            }
          } else if (!!J.getInterceptor(argument).$isNamedExpression)
            foundNamedArgument = true;
        }
        rightParenthesis = this._expect$1(C.TokenType_kC8);
        t1 = new N.ArgumentList(null, null, null, null, null, null, null);
        t2 = N.Expression;
        t3 = [];
        t3.$builtinTypeInfo = [t2];
        t3 = new N.NodeList(t1, t3);
        t3.$builtinTypeInfo = [t2];
        t1._arguments = t3;
        t1._leftParenthesis = leftParenthesis;
        t3.addAll$1(0, $arguments);
        t1._rightParenthesis = rightParenthesis;
        return t1;
      } finally {
        this._inInitializer = wasInInitializer;
      }
    },
    parseBitwiseOrExpression$0: function() {
      var token, expression, t1, node, expression0;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type === C.TokenType_aPH) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseBitwiseXorExpression$0();
      for (; t1 = this._currentToken, t1.type === C.TokenType_aPH; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseBitwiseXorExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    parseBlock$0: function() {
      var leftBracket, statements, statementStart, t1, statement, t2, t3;
      leftBracket = this._expect$1(C.TokenType_qFj);
      statements = [];
      statements.$builtinTypeInfo = [N.Statement];
      statementStart = this._currentToken;
      t1 = statementStart;
      while (true) {
        t1 = t1.type;
        if (!(t1 !== C.TokenType_EOF_Imi && t1 !== C.TokenType_33I))
          break;
        statement = this.parseStatement2$0();
        if (statement != null)
          statements.push(statement);
        t1 = this._currentToken;
        if (t1 == null ? statementStart == null : t1 === statementStart) {
          this._reportErrorForToken$3(C.ParserErrorCode_udD, t1, [t1.get$lexeme()]);
          t1 = this._currentToken._next;
          this._currentToken = t1;
          statementStart = t1;
        } else
          statementStart = t1;
        t1 = statementStart;
      }
      t1 = new N.Block(leftBracket, null, this._expect$1(C.TokenType_33I), null, null);
      t2 = N.Statement;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._statements = t3;
      t3.addAll$1(0, statements);
      return t1;
    },
    parseClassMember$1: function(className) {
      var commentAndMetadata, modifiers, type, t1, returnType, t2, methodName, parameters, fieldList, node, t3, t4, keyword, variables, node0, node1, previous, node2, token;
      commentAndMetadata = this._parseCommentAndMetadata$0();
      modifiers = this._parseModifiers$0();
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_void_false_VOID_30)) {
        returnType = this.parseReturnType$0();
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40)) {
          t1 = this._currentToken._next;
          t2 = t1.type;
          if (t2 !== C.TokenType_nrs)
            t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
          else
            t1 = true;
        } else
          t1 = false;
        if (t1) {
          this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
          return this._parseGetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), returnType);
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46)) {
            t1 = this._currentToken._next;
            t2 = t1.type;
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
          } else
            t1 = false;
          if (t1) {
            this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
            return this._parseSetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), returnType);
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next)) {
              this._validateModifiersForOperator$1(modifiers);
              return this._parseOperator$3(commentAndMetadata, modifiers.get$externalKeyword(), returnType);
            } else {
              t1 = this._currentToken;
              t2 = t1.type;
              if (t2 !== C.TokenType_nrs)
                t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
              else
                t1 = true;
              if (t1 && this._currentToken._next.matchesAny$1([C.TokenType_MD7, C.TokenType_qFj, C.TokenType_iJT])) {
                this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
                t1 = modifiers.get$externalKeyword();
                t2 = modifiers.get$staticKeyword();
                methodName = this.parseSimpleIdentifier$0();
                parameters = this.parseFormalParameterList$0();
                this._validateFormalParameterList$1(parameters);
                return this._parseMethodDeclarationAfterParameters$6(commentAndMetadata, t1, t2, returnType, methodName, parameters);
              } else {
                t1 = this._currentToken;
                t2 = t1.type;
                if (t2 !== C.TokenType_nrs)
                  t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
                else
                  t1 = true;
                if (t1)
                  if (this._currentToken._next.matchesAny$1([C.TokenType_Azp, C.TokenType_s8I, C.TokenType_S8h])) {
                    this._reportError$1(U.AnalysisError$con2(this._source, returnType.get$offset(), returnType.get$length(returnType), C.ParserErrorCode_2Rk, []));
                    t1 = commentAndMetadata;
                    t2 = modifiers.get$staticKeyword();
                    fieldList = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForField$1(modifiers), returnType);
                    node = t1.get$comment();
                    t1 = t1.metadata;
                    t2 = new N.FieldDeclaration(t2, null, this._expect$1(C.TokenType_S8h), null, null, null, null);
                    t3 = N.Annotation;
                    t4 = [];
                    t4.$builtinTypeInfo = [t3];
                    t4 = new N.NodeList(t2, t4);
                    t4.$builtinTypeInfo = [t3];
                    t2._metadata = t4;
                    if (node != null)
                      node.set$parent(t2);
                    t2._comment = node;
                    t2._metadata.addAll$1(0, t1);
                    fieldList.set$parent(t2);
                    t2._fieldList = fieldList;
                    return t2;
                  }
                if (this._isOperator$1(this._currentToken)) {
                  this._validateModifiersForOperator$1(modifiers);
                  return this._parseOperator$3(commentAndMetadata, modifiers.get$externalKeyword(), returnType);
                }
                this._reportErrorForToken$3(C.ParserErrorCode_Dn4, this._currentToken, []);
                return;
              }
            }
          }
        }
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40)) {
          t1 = this._currentToken._next;
          t2 = t1.type;
          if (t2 !== C.TokenType_nrs)
            t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
          else
            t1 = true;
        } else
          t1 = false;
        if (t1) {
          this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
          return this._parseGetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), null);
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46)) {
            t1 = this._currentToken._next;
            t2 = t1.type;
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
          } else
            t1 = false;
          if (t1) {
            this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
            return this._parseSetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), null);
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next)) {
              this._validateModifiersForOperator$1(modifiers);
              return this._parseOperator$3(commentAndMetadata, modifiers.get$externalKeyword(), null);
            } else {
              t1 = this._currentToken;
              t2 = t1.type;
              if (t2 !== C.TokenType_nrs)
                t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
              else
                t1 = true;
              if (!t1) {
                if (this._isOperator$1(this._currentToken)) {
                  this._validateModifiersForOperator$1(modifiers);
                  return this._parseOperator$3(commentAndMetadata, modifiers.get$externalKeyword(), null);
                }
                keyword = modifiers.get$varKeyword();
                if (keyword == null)
                  keyword = modifiers.get$finalKeyword();
                if (keyword == null)
                  keyword = modifiers.get$constKeyword();
                if (keyword != null) {
                  this._reportErrorForToken$3(C.ParserErrorCode_yw2, this._currentToken, []);
                  variables = [];
                  variables.$builtinTypeInfo = [N.VariableDeclaration];
                  node = this._createSyntheticIdentifier$0();
                  t1 = new N.VariableDeclaration(null, null, null, null, null, null, null);
                  t2 = N.Annotation;
                  t3 = [];
                  t3.$builtinTypeInfo = [t2];
                  t3 = new N.NodeList(t1, t3);
                  t3.$builtinTypeInfo = [t2];
                  t1._metadata = t3;
                  t1._comment = null;
                  t3.addAll$1(0, null);
                  node.set$parent(t1);
                  t1._name = node;
                  t1._initializer = null;
                  variables.push(t1);
                  node = commentAndMetadata.get$comment();
                  t1 = commentAndMetadata.get$metadata();
                  node0 = new N.VariableDeclarationList(keyword, null, null, null, null, null, null);
                  t2 = N.Annotation;
                  t3 = [];
                  t3.$builtinTypeInfo = [t2];
                  t3 = new N.NodeList(node0, t3);
                  t3.$builtinTypeInfo = [t2];
                  node0._metadata = t3;
                  node0._comment = null;
                  t3.addAll$1(0, null);
                  t2 = N.VariableDeclaration;
                  t3 = [];
                  t3.$builtinTypeInfo = [t2];
                  t3 = new N.NodeList(node0, t3);
                  t3.$builtinTypeInfo = [t2];
                  node0._variables = t3;
                  node0._type = null;
                  t3.addAll$1(0, variables);
                  t2 = new N.FieldDeclaration(null, null, this._expectSemicolon$0(), null, null, null, null);
                  t3 = N.Annotation;
                  t4 = [];
                  t4.$builtinTypeInfo = [t3];
                  t4 = new N.NodeList(t2, t4);
                  t4.$builtinTypeInfo = [t3];
                  t2._metadata = t4;
                  if (node != null)
                    node.set$parent(t2);
                  t2._comment = node;
                  t2._metadata.addAll$1(0, t1);
                  node0.set$parent(t2);
                  t2._fieldList = node0;
                  return t2;
                }
                this._reportErrorForToken$3(C.ParserErrorCode_2to, this._currentToken, []);
                if (commentAndMetadata.get$comment() != null || commentAndMetadata.get$metadata().length !== 0) {
                  node = commentAndMetadata.get$comment();
                  t1 = commentAndMetadata.get$metadata();
                  node0 = this._createSyntheticIdentifier$0();
                  t2 = [];
                  t2.$builtinTypeInfo = [N.FormalParameter];
                  node1 = new N.FormalParameterList(null, null, null, null, null, null, null);
                  t3 = N.FormalParameter;
                  t4 = [];
                  t4.$builtinTypeInfo = [t3];
                  t4 = new N.NodeList(node1, t4);
                  t4.$builtinTypeInfo = [t3];
                  node1._parameters = t4;
                  node1._leftParenthesis = null;
                  t4.addAll$1(0, t2);
                  node1._leftDelimiter = null;
                  node1._rightDelimiter = null;
                  node1._rightParenthesis = null;
                  t2 = this._currentToken;
                  t3 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
                  t3.offset = t2.offset;
                  $.get$StringUtilities_INTERNER().toString;
                  t3._value = "";
                  previous = t2.previous;
                  t3._next = t2;
                  t2.previous = t3;
                  previous._next = t3;
                  t3.previous = previous;
                  node2 = new N.EmptyFunctionBody(t3, null, null);
                  t3 = new N.MethodDeclaration(null, null, null, null, null, null, null, null, null, null, null, null);
                  t2 = N.Annotation;
                  t4 = [];
                  t4.$builtinTypeInfo = [t2];
                  t4 = new N.NodeList(t3, t4);
                  t4.$builtinTypeInfo = [t2];
                  t3._metadata = t4;
                  if (node != null)
                    node.set$parent(t3);
                  t3._comment = node;
                  t3._metadata.addAll$1(0, t1);
                  t3._returnType = null;
                  node0.set$parent(t3);
                  t3._name = node0;
                  node1.set$parent(t3);
                  t3._parameters = node1;
                  node2.set$parent(t3);
                  t3._body = node2;
                  return t3;
                }
                return;
              } else {
                if (this._currentToken._next.type === C.TokenType_B6W) {
                  t1 = this._peekAt$1(2);
                  t2 = t1.type;
                  if (t2 !== C.TokenType_nrs)
                    t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
                  else
                    t1 = true;
                  t1 = t1 && this._peekAt$1(3).type === C.TokenType_MD7;
                } else
                  t1 = false;
                if (t1) {
                  t1 = modifiers.get$externalKeyword();
                  t2 = this._validateModifiersForConstructor$1(modifiers);
                  t3 = modifiers.get$factoryKeyword();
                  t4 = this.parseSimpleIdentifier$0();
                  token = this._currentToken;
                  this._currentToken = token._next;
                  return this._parseConstructor$8(commentAndMetadata, t1, t2, t3, t4, token, this.parseSimpleIdentifier$0(), this.parseFormalParameterList$0());
                } else {
                  t1 = this._currentToken._next;
                  if (t1.type === C.TokenType_MD7) {
                    methodName = this.parseSimpleIdentifier$0();
                    parameters = this.parseFormalParameterList$0();
                    if (this._currentToken.type !== C.TokenType_chs)
                      if (modifiers.get$factoryKeyword() == null) {
                        t1 = methodName.token.get$lexeme();
                        t1 = t1 == null ? className == null : t1 === className;
                      } else
                        t1 = true;
                    else
                      t1 = true;
                    if (t1)
                      return this._parseConstructor$8(commentAndMetadata, modifiers.get$externalKeyword(), this._validateModifiersForConstructor$1(modifiers), modifiers.get$factoryKeyword(), methodName, null, null, parameters);
                    this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
                    this._validateFormalParameterList$1(parameters);
                    return this._parseMethodDeclarationAfterParameters$6(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), null, methodName, parameters);
                  } else if (t1.matchesAny$1([C.TokenType_Azp, C.TokenType_s8I, C.TokenType_S8h])) {
                    if (modifiers.get$constKeyword() == null && modifiers.get$finalKeyword() == null && modifiers.get$varKeyword() == null)
                      this._reportErrorForToken$3(C.ParserErrorCode_sAF, this._currentToken, []);
                    t1 = commentAndMetadata;
                    t2 = modifiers.get$staticKeyword();
                    fieldList = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForField$1(modifiers), null);
                    node = t1.get$comment();
                    t1 = t1.metadata;
                    t2 = new N.FieldDeclaration(t2, null, this._expect$1(C.TokenType_S8h), null, null, null, null);
                    t3 = N.Annotation;
                    t4 = [];
                    t4.$builtinTypeInfo = [t3];
                    t4 = new N.NodeList(t2, t4);
                    t4.$builtinTypeInfo = [t3];
                    t2._metadata = t4;
                    if (node != null)
                      node.set$parent(t2);
                    t2._comment = node;
                    t2._metadata.addAll$1(0, t1);
                    fieldList.set$parent(t2);
                    t2._fieldList = fieldList;
                    return t2;
                  }
                }
              }
            }
          }
        }
      }
      type = this.parseTypeName$0();
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40)) {
        t1 = this._currentToken._next;
        t2 = t1.type;
        if (t2 !== C.TokenType_nrs)
          t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
        else
          t1 = true;
      } else
        t1 = false;
      if (t1) {
        this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
        return this._parseGetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), type);
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46)) {
          t1 = this._currentToken._next;
          t2 = t1.type;
          if (t2 !== C.TokenType_nrs)
            t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
          else
            t1 = true;
        } else
          t1 = false;
        if (t1) {
          this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
          return this._parseSetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), type);
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next)) {
            this._validateModifiersForOperator$1(modifiers);
            return this._parseOperator$3(commentAndMetadata, modifiers.get$externalKeyword(), type);
          } else {
            t1 = this._currentToken;
            t2 = t1.type;
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
            if (!t1) {
              t1 = this._currentToken;
              if (t1.type === C.TokenType_33I) {
                t1 = commentAndMetadata;
                t2 = modifiers.get$staticKeyword();
                fieldList = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForField$1(modifiers), type);
                node = t1.get$comment();
                t1 = t1.metadata;
                t2 = new N.FieldDeclaration(t2, null, this._expect$1(C.TokenType_S8h), null, null, null, null);
                t3 = N.Annotation;
                t4 = [];
                t4.$builtinTypeInfo = [t3];
                t4 = new N.NodeList(t2, t4);
                t4.$builtinTypeInfo = [t3];
                t2._metadata = t4;
                if (node != null)
                  node.set$parent(t2);
                t2._comment = node;
                t2._metadata.addAll$1(0, t1);
                fieldList.set$parent(t2);
                t2._fieldList = fieldList;
                return t2;
              }
              if (this._isOperator$1(t1)) {
                this._validateModifiersForOperator$1(modifiers);
                return this._parseOperator$3(commentAndMetadata, modifiers.get$externalKeyword(), type);
              }
              this._reportErrorForToken$3(C.ParserErrorCode_2to, this._currentToken, []);
              try {
                ++this._errorListenerLock;
                t1 = commentAndMetadata;
                t2 = modifiers.get$staticKeyword();
                fieldList = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForField$1(modifiers), type);
                node = t1.get$comment();
                t1 = t1.metadata;
                t2 = new N.FieldDeclaration(t2, null, this._expect$1(C.TokenType_S8h), null, null, null, null);
                t3 = N.Annotation;
                t4 = [];
                t4.$builtinTypeInfo = [t3];
                t4 = new N.NodeList(t2, t4);
                t4.$builtinTypeInfo = [t3];
                t2._metadata = t4;
                if (node != null)
                  node.set$parent(t2);
                t2._comment = node;
                t2._metadata.addAll$1(0, t1);
                fieldList.set$parent(t2);
                t2._fieldList = fieldList;
                return t2;
              } finally {
                t1 = this._errorListenerLock;
                if (t1 === 0)
                  H.throwExpression(L.IllegalStateException$("Attempt to unlock not locked error listener."));
                this._errorListenerLock = t1 - 1;
              }
            } else {
              t1 = this._currentToken._next.type;
              if (t1 === C.TokenType_MD7) {
                methodName = this.parseSimpleIdentifier$0();
                parameters = this.parseFormalParameterList$0();
                t1 = methodName.token.get$lexeme();
                if (t1 == null ? className == null : t1 === className) {
                  t1 = type;
                  this._reportError$1(U.AnalysisError$con2(this._source, t1.get$offset(), J.get$length$as(t1), C.ParserErrorCode_IAC, []));
                  return this._parseConstructor$8(commentAndMetadata, modifiers.get$externalKeyword(), this._validateModifiersForConstructor$1(modifiers), modifiers.get$factoryKeyword(), methodName, null, null, parameters);
                }
                this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
                this._validateFormalParameterList$1(parameters);
                return this._parseMethodDeclarationAfterParameters$6(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), type, methodName, parameters);
              } else if (t1 === C.TokenType_qFj) {
                this._validateModifiersForGetterOrSetterOrMethod$1(modifiers);
                this._reportErrorForToken$3(C.ParserErrorCode_qN2, this._currentToken, []);
                t1 = this._currentToken;
                t2 = new S.Parser_SyntheticKeywordToken(C.Keyword_get_true_GET_40, C.TokenType_hLM, 0, null, null);
                t2.offset = t1.offset;
                previous = t1.previous;
                t2._next = t1;
                t1.previous = t2;
                previous._next = t2;
                t2.previous = previous;
                this._currentToken = t2;
                return this._parseGetter$4(commentAndMetadata, modifiers.get$externalKeyword(), modifiers.get$staticKeyword(), type);
              }
            }
          }
        }
      }
      t1 = commentAndMetadata;
      t2 = modifiers.get$staticKeyword();
      fieldList = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForField$1(modifiers), type);
      node = t1.get$comment();
      t1 = t1.metadata;
      t2 = new N.FieldDeclaration(t2, null, this._expect$1(C.TokenType_S8h), null, null, null, null);
      t3 = N.Annotation;
      t4 = [];
      t4.$builtinTypeInfo = [t3];
      t4 = new N.NodeList(t2, t4);
      t4.$builtinTypeInfo = [t3];
      t2._metadata = t4;
      if (node != null)
        node.set$parent(t2);
      t2._comment = node;
      t2._metadata.addAll$1(0, t1);
      fieldList.set$parent(t2);
      t2._fieldList = fieldList;
      return t2;
    },
    parseCompilationUnit2$0: function() {
      var firstToken, scriptTag, directives, declarations, memberStart, t1, libraryDirectiveFound, partOfDirectiveFound, partDirectiveFound, directiveFoundAfterDeclaration, commentAndMetadata, directive, directiveCount, i, member, t2;
      firstToken = this._currentToken;
      if (firstToken.type === C.TokenType_ato) {
        this._currentToken = firstToken._next;
        scriptTag = new N.ScriptTag(firstToken, null, null);
      } else
        scriptTag = null;
      directives = H.setRuntimeTypeInfo([], [N.Directive]);
      declarations = H.setRuntimeTypeInfo([], [N.CompilationUnitMember]);
      memberStart = this._currentToken;
      for (t1 = memberStart, libraryDirectiveFound = false, partOfDirectiveFound = false, partDirectiveFound = false, directiveFoundAfterDeclaration = false; t1.type !== C.TokenType_EOF_Imi; t1 = memberStart) {
        commentAndMetadata = this._parseCommentAndMetadata$0();
        t1 = this._currentToken;
        if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_import_true_IMPORT_42))) {
          t1 = this._currentToken;
          if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_export_true_EXPORT_37))) {
            t1 = this._currentToken;
            if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_library_true_LIBRARY_43))) {
              t1 = this._currentToken;
              t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_part_true_PART_45);
            } else
              t1 = true;
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1) {
          t1 = this._currentToken._next.type;
          t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ && t1 !== C.TokenType_MD7;
        } else
          t1 = false;
        if (t1) {
          directive = this._parseDirective$1(commentAndMetadata);
          if (declarations.length > 0 && !directiveFoundAfterDeclaration) {
            this._reportErrorForToken$3(C.ParserErrorCode_FCG, this._currentToken, []);
            directiveFoundAfterDeclaration = true;
          }
          if (!!directive.$isLibraryDirective)
            if (libraryDirectiveFound)
              this._reportErrorForToken$3(C.ParserErrorCode_8G7, this._currentToken, []);
            else {
              if (directives.length > 0)
                this._reportErrorForToken$3(C.ParserErrorCode_C8a, directive.libraryToken, []);
              libraryDirectiveFound = true;
            }
          else if (!!directive.$isPartDirective)
            partDirectiveFound = true;
          else if (partDirectiveFound)
            if (!!directive.$isExportDirective)
              this._reportErrorForToken$3(C.ParserErrorCode_XLl, directive.keyword, []);
            else if (!!directive.$isImportDirective)
              this._reportErrorForToken$3(C.ParserErrorCode_yLX, directive.keyword, []);
          if (!!directive.$isPartOfDirective)
            if (partOfDirectiveFound)
              this._reportErrorForToken$3(C.ParserErrorCode_p8N, this._currentToken, []);
            else {
              directiveCount = directives.length;
              for (i = 0; i < directiveCount; ++i) {
                if (i >= directives.length)
                  return H.ioore(directives, i);
                this._reportErrorForToken$3(C.ParserErrorCode_rl2, directives[i].get$keyword(), []);
              }
              partOfDirectiveFound = true;
            }
          else if (partOfDirectiveFound)
            this._reportErrorForToken$3(C.ParserErrorCode_rl2, directive.get$keyword(), []);
          directives.push(directive);
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_S8h) {
            this._reportErrorForToken$3(C.ParserErrorCode_udD, t1, [t1.get$lexeme()]);
            this._currentToken = this._currentToken._next;
          } else {
            member = this._parseCompilationUnitMember$1(commentAndMetadata);
            if (member != null)
              declarations.push(member);
          }
        }
        t1 = this._currentToken;
        if (t1 == null ? memberStart == null : t1 === memberStart) {
          this._reportErrorForToken$3(C.ParserErrorCode_udD, t1, [t1.get$lexeme()]);
          t1 = this._currentToken._next;
          this._currentToken = t1;
          while (true) {
            if (!(t1.type !== C.TokenType_EOF_Imi && !this._couldBeStartOfCompilationUnitMember$0()))
              break;
            t1 = this._currentToken._next;
            this._currentToken = t1;
          }
        }
        memberStart = this._currentToken;
      }
      t2 = new N.CompilationUnit(firstToken, null, null, null, t1, null, null, null, null);
      t2.CompilationUnit$5(firstToken, scriptTag, directives, declarations, t1);
      return t2;
    },
    parseConditionalExpression$0: function() {
      var condition, t1, thenExpression, colon, t2;
      condition = this.parseLogicalOrExpression$0();
      t1 = this._currentToken;
      if (t1.type !== C.TokenType_B8J)
        return condition;
      this._currentToken = t1._next;
      thenExpression = this.parseExpressionWithoutCascade$0();
      colon = this._expect$1(C.TokenType_chs);
      t2 = new N.ConditionalExpression(null, t1, null, colon, null, null, null, null, null);
      t2.ConditionalExpression$5(condition, t1, thenExpression, colon, this.parseExpressionWithoutCascade$0());
      return t2;
    },
    parseConstructorName$0: function() {
      var type, period, $name, t1;
      type = this.parseTypeName$0();
      period = this._currentToken;
      if (period.type === C.TokenType_B6W) {
        this._currentToken = period._next;
        $name = this.parseSimpleIdentifier$0();
      } else {
        period = null;
        $name = null;
      }
      t1 = new N.ConstructorName(null, period, null, null, null, null);
      t1._type = t1.becomeParentOf$1(type);
      t1._name = t1.becomeParentOf$1($name);
      return t1;
    },
    parseExpression2$0: function() {
      var t1, expression, tokenType, cascadeSections, section, t2, t3;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_throw_false_THROW_26))
        return this._parseThrowExpression$0();
      else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_rethrow_false_RETHROW_21))
          return new N.RethrowExpression(this._expectKeyword$1(C.Keyword_rethrow_false_RETHROW_21), null, null, null, null);
      }
      expression = this.parseConditionalExpression$0();
      t1 = this._currentToken;
      tokenType = t1.type;
      if (tokenType === C.TokenType_mGg) {
        cascadeSections = [];
        cascadeSections.$builtinTypeInfo = [N.Expression];
        for (; tokenType === C.TokenType_mGg;) {
          section = this._parseCascadeSection$0();
          if (section != null)
            cascadeSections.push(section);
          tokenType = this._currentToken.type;
        }
        t1 = new N.CascadeExpression(null, null, null, null, null, null);
        t2 = N.Expression;
        t3 = [];
        t3.$builtinTypeInfo = [t2];
        t3 = new N.NodeList(t1, t3);
        t3.$builtinTypeInfo = [t2];
        t1._cascadeSections = t3;
        if (expression != null)
          expression.set$parent(t1);
        t1._target = expression;
        t1._cascadeSections.addAll$1(0, cascadeSections);
        return t1;
      } else if (tokenType._tokenClass === C.TokenClass_1_ASSIGNMENT_OPERATOR_2) {
        this._currentToken = t1._next;
        if (expression != null && !expression.get$isAssignable())
          this._reportErrorForToken$3(C.ParserErrorCode_8hp, this._currentToken, []);
        return N.AssignmentExpression$(expression, t1, this.parseExpression2$0());
      }
      return expression;
    },
    parseExpressionWithoutCascade$0: function() {
      var expression, t1;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_throw_false_THROW_26))
        return this._parseThrowExpressionWithoutCascade$0();
      else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_rethrow_false_RETHROW_21))
        return new N.RethrowExpression(this._expectKeyword$1(C.Keyword_rethrow_false_RETHROW_21), null, null, null, null);
      expression = this.parseConditionalExpression$0();
      t1 = this._currentToken;
      if (t1.type._tokenClass === C.TokenClass_1_ASSIGNMENT_OPERATOR_2) {
        this._currentToken = t1._next;
        this._ensureAssignable$1(expression);
        expression = N.AssignmentExpression$(expression, t1, this.parseExpressionWithoutCascade$0());
      }
      return expression;
    },
    parseFormalParameterList$0: function() {
      var leftParenthesis, t1, parameters, normalParameters, positionalParameters, namedParameters, t2, currentParameters, leftSquareBracket, rightSquareBracket, leftCurlyBracket, rightCurlyBracket, kind, firstParameter, reportedMuliplePositionalGroups, reportedMulipleNamedGroups, reportedMixedGroups, wasOptionalParameter, t3, t4, initialToken, token, parameter, rightSquareBracket0, rightParenthesis;
      leftParenthesis = this._expect$1(C.TokenType_MD7);
      t1 = this._currentToken;
      if (t1.type === C.TokenType_kC8) {
        this._currentToken = t1._next;
        return N.FormalParameterList$(leftParenthesis, null, null, null, t1);
      }
      parameters = H.setRuntimeTypeInfo([], [N.FormalParameter]);
      normalParameters = H.setRuntimeTypeInfo([], [N.FormalParameter]);
      positionalParameters = H.setRuntimeTypeInfo([], [N.FormalParameter]);
      namedParameters = H.setRuntimeTypeInfo([], [N.FormalParameter]);
      t1 = C.TokenType_s8I.lexeme;
      t2 = this._source;
      currentParameters = normalParameters;
      leftSquareBracket = null;
      rightSquareBracket = null;
      leftCurlyBracket = null;
      rightCurlyBracket = null;
      kind = C.ParameterKind_false_REQUIRED_0;
      firstParameter = true;
      reportedMuliplePositionalGroups = false;
      reportedMulipleNamedGroups = false;
      reportedMixedGroups = false;
      wasOptionalParameter = false;
      do {
        if (firstParameter)
          firstParameter = false;
        else if (!this._optional$1(C.TokenType_s8I)) {
          t3 = this._getEndToken$1(leftParenthesis);
          t4 = this._currentToken;
          if (t3 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_s8i, t4, [t1]);
          else {
            this._reportErrorForToken$3(C.ParserErrorCode_Odg, t4.previous, []);
            break;
          }
        }
        initialToken = this._currentToken;
        t3 = initialToken.type;
        if (t3 === C.TokenType_AHF) {
          if (leftSquareBracket != null && !reportedMuliplePositionalGroups) {
            this._reportErrorForToken$3(C.ParserErrorCode_Smp, initialToken, []);
            reportedMuliplePositionalGroups = true;
          }
          if (leftCurlyBracket != null && !reportedMixedGroups) {
            this._reportErrorForToken$3(C.ParserErrorCode_ODT, this._currentToken, []);
            reportedMixedGroups = true;
          }
          token = this._currentToken;
          this._currentToken = token._next;
          leftSquareBracket = token;
          currentParameters = positionalParameters;
          kind = C.ParameterKind_true_POSITIONAL_1;
          wasOptionalParameter = true;
        } else if (t3 === C.TokenType_qFj) {
          if (leftCurlyBracket != null && !reportedMulipleNamedGroups) {
            this._reportErrorForToken$3(C.ParserErrorCode_Svc, initialToken, []);
            reportedMulipleNamedGroups = true;
          }
          if (leftSquareBracket != null && !reportedMixedGroups) {
            this._reportErrorForToken$3(C.ParserErrorCode_ODT, this._currentToken, []);
            reportedMixedGroups = true;
          }
          token = this._currentToken;
          this._currentToken = token._next;
          leftCurlyBracket = token;
          currentParameters = namedParameters;
          kind = C.ParameterKind_true_NAMED_2;
          wasOptionalParameter = true;
        }
        parameter = this._parseFormalParameter$1(kind);
        parameters.push(parameter);
        currentParameters.push(parameter);
        if (kind === C.ParameterKind_false_REQUIRED_0 && wasOptionalParameter)
          this._reportError$1(U.AnalysisError$con2(t2, parameter.get$offset(), parameter.get$length(parameter), C.ParserErrorCode_bQP, []));
        rightSquareBracket0 = this._currentToken;
        t3 = rightSquareBracket0.type;
        if (t3 === C.TokenType_58K) {
          t3 = rightSquareBracket0._next;
          this._currentToken = t3;
          if (leftSquareBracket == null)
            if (leftCurlyBracket != null) {
              this._reportErrorForToken$3(C.ParserErrorCode_ezM, t3, ["}"]);
              rightCurlyBracket = rightSquareBracket0;
              rightSquareBracket = null;
            } else {
              this._reportErrorForToken$3(C.ParserErrorCode_43h, t3, ["["]);
              rightSquareBracket = rightSquareBracket0;
            }
          else
            rightSquareBracket = rightSquareBracket0;
          currentParameters = normalParameters;
          kind = C.ParameterKind_false_REQUIRED_0;
        } else if (t3 === C.TokenType_33I) {
          t3 = rightSquareBracket0._next;
          this._currentToken = t3;
          if (leftCurlyBracket == null)
            if (leftSquareBracket != null) {
              this._reportErrorForToken$3(C.ParserErrorCode_ezM, t3, ["]"]);
              rightSquareBracket = rightSquareBracket0;
              rightCurlyBracket = null;
            } else {
              this._reportErrorForToken$3(C.ParserErrorCode_43h, t3, ["{"]);
              rightCurlyBracket = rightSquareBracket0;
            }
          else
            rightCurlyBracket = rightSquareBracket0;
          currentParameters = normalParameters;
          kind = C.ParameterKind_false_REQUIRED_0;
        }
        t3 = this._currentToken;
      } while (t3.type !== C.TokenType_kC8 && (initialToken == null ? t3 != null : initialToken !== t3));
      rightParenthesis = this._expect$1(C.TokenType_kC8);
      t1 = leftSquareBracket == null;
      if (!t1 && rightSquareBracket == null)
        this._reportErrorForToken$3(C.ParserErrorCode_a94, this._currentToken, ["]"]);
      if (leftCurlyBracket != null && rightCurlyBracket == null)
        this._reportErrorForToken$3(C.ParserErrorCode_a94, this._currentToken, ["}"]);
      if (t1)
        leftSquareBracket = leftCurlyBracket;
      return N.FormalParameterList$(leftParenthesis, parameters, leftSquareBracket, rightSquareBracket == null ? rightCurlyBracket : rightSquareBracket, rightParenthesis);
    },
    parseImplementsClause$0: function() {
      var keyword, interfaces, t1, t2, t3;
      keyword = this._expectKeyword$1(C.Keyword_implements_true_IMPLEMENTS_41);
      interfaces = [];
      interfaces.$builtinTypeInfo = [N.TypeName];
      interfaces.push(this.parseTypeName$0());
      for (; this._optional$1(C.TokenType_s8I);)
        interfaces.push(this.parseTypeName$0());
      t1 = new N.ImplementsClause(keyword, null, null, null);
      t2 = N.TypeName;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._interfaces = t3;
      t3.addAll$1(0, interfaces);
      return t1;
    },
    parseLibraryIdentifier$0: function() {
      var components, t1;
      components = H.setRuntimeTypeInfo([], [N.SimpleIdentifier]);
      components.push(this.parseSimpleIdentifier$0());
      for (; t1 = this._currentToken, t1.type === C.TokenType_B6W;) {
        this._currentToken = t1._next;
        components.push(this.parseSimpleIdentifier$0());
      }
      return N.LibraryIdentifier$(components);
    },
    parseLogicalOrExpression$0: function() {
      var expression, t1, node, expression0;
      expression = this._parseLogicalAndExpression$0();
      for (; t1 = this._currentToken, t1.type === C.TokenType_Mxr; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseLogicalAndExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    parseMapLiteralEntry$0: function() {
      var key, separator, value, t1;
      key = this.parseExpression2$0();
      separator = this._expect$1(C.TokenType_chs);
      value = this.parseExpression2$0();
      t1 = new N.MapLiteralEntry(null, separator, null, null, null);
      if (key != null)
        key.set$parent(t1);
      t1._key = key;
      if (value != null)
        value.set$parent(t1);
      t1._ast$_value = value;
      return t1;
    },
    parseNormalFormalParameter$0: function() {
      var commentAndMetadata, holder, token, period, thisKeyword, identifier, parameters, t1, type;
      commentAndMetadata = this._parseCommentAndMetadata$0();
      holder = this._parseFinalConstVarOrType$1(true);
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_this_false_THIS_25)) {
        token = this._currentToken;
        this._currentToken = token._next;
        period = this._expect$1(C.TokenType_B6W);
        thisKeyword = token;
      } else {
        thisKeyword = null;
        period = null;
      }
      identifier = this.parseSimpleIdentifier$0();
      if (this._currentToken.type === C.TokenType_MD7) {
        parameters = this.parseFormalParameterList$0();
        if (thisKeyword == null) {
          t1 = holder.keyword;
          if (t1 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_uti, t1, []);
          t1 = new N.FunctionTypedFormalParameter(null, null, null, null, null, null, null);
          t1.NormalFormalParameter$3(commentAndMetadata.comment, commentAndMetadata.metadata, identifier);
          t1._returnType = t1.becomeParentOf$1(holder.type);
          t1._parameters = t1.becomeParentOf$1(parameters);
          return t1;
        } else {
          t1 = new N.FieldFormalParameter(holder.keyword, null, thisKeyword, period, null, null, null, null, null, null);
          t1.NormalFormalParameter$3(commentAndMetadata.comment, commentAndMetadata.metadata, identifier);
          t1._type = t1.becomeParentOf$1(holder.type);
          t1._parameters = t1.becomeParentOf$1(parameters);
          return t1;
        }
      }
      type = holder.type;
      if (type != null)
        if (this._tokenMatchesKeyword$2(type._name.get$beginToken(), C.Keyword_void_false_VOID_30))
          this._reportErrorForToken$3(C.ParserErrorCode_hkG, type._name.get$beginToken(), []);
        else {
          t1 = holder.keyword;
          if (t1 != null && this._tokenMatchesKeyword$2(t1, C.Keyword_var_false_VAR_29))
            this._reportErrorForToken$3(C.ParserErrorCode_Xlp, t1, []);
        }
      if (thisKeyword != null) {
        t1 = new N.FieldFormalParameter(holder.keyword, null, thisKeyword, period, null, null, null, null, null, null);
        t1.NormalFormalParameter$3(commentAndMetadata.comment, commentAndMetadata.metadata, identifier);
        t1._type = t1.becomeParentOf$1(type);
        t1._parameters = t1.becomeParentOf$1(null);
        return t1;
      }
      t1 = new N.SimpleFormalParameter(holder.keyword, null, null, null, null, null, null);
      t1.NormalFormalParameter$3(commentAndMetadata.comment, commentAndMetadata.metadata, identifier);
      t1._type = t1.becomeParentOf$1(type);
      return t1;
    },
    parsePrefixedIdentifier$0: function() {
      var qualifier, t1, qualified;
      qualifier = this.parseSimpleIdentifier$0();
      t1 = this._currentToken;
      if (t1.type !== C.TokenType_B6W)
        return qualifier;
      this._currentToken = t1._next;
      qualified = this.parseSimpleIdentifier$0();
      t1 = new N.PrefixedIdentifier(null, t1, null, null, null, null, null);
      t1._prefix = t1.becomeParentOf$1(qualifier);
      t1._identifier = t1.becomeParentOf$1(qualified);
      return t1;
    },
    parseReturnType$0: function() {
      var token, t1;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_void_false_VOID_30)) {
        token = this._currentToken;
        this._currentToken = token._next;
        t1 = new N.TypeName(null, null, null, null, null);
        t1._name = t1.becomeParentOf$1(new N.SimpleIdentifier(token, null, null, null, null, null, null, null));
        t1._typeArguments = t1.becomeParentOf$1(null);
        return t1;
      } else
        return this.parseTypeName$0();
    },
    parseSimpleIdentifier$0: function() {
      var t1, t2, token;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 !== C.TokenType_nrs)
        t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
      else
        t1 = true;
      if (t1) {
        token = this._currentToken;
        this._currentToken = token._next;
        return new N.SimpleIdentifier(token, null, null, null, null, null, null, null);
      }
      this._reportErrorForToken$3(C.ParserErrorCode_yw2, this._currentToken, []);
      return this._createSyntheticIdentifier$0();
    },
    parseStatement2$0: function() {
      var labels, t1, t2, label, statement, t3;
      labels = [];
      labels.$builtinTypeInfo = [N.Label];
      while (true) {
        t1 = this._currentToken;
        t2 = t1.type;
        if (t2 !== C.TokenType_nrs)
          t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
        else
          t1 = true;
        if (!(t1 && this._currentToken._next.type === C.TokenType_chs))
          break;
        label = this.parseSimpleIdentifier$0();
        t1 = new N.Label(null, this._expect$1(C.TokenType_chs), null, null);
        label.set$parent(t1);
        t1._label = label;
        labels.push(t1);
      }
      statement = this._parseNonLabeledStatement$0();
      if (labels.length === 0)
        return statement;
      t1 = new N.LabeledStatement(null, null, null, null);
      t2 = N.Label;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._labels = t3;
      t3.addAll$1(0, labels);
      if (statement != null)
        statement.set$parent(t1);
      t1._statement = statement;
      return t1;
    },
    parseStringLiteral$0: function() {
      var strings, t1, t2;
      strings = H.setRuntimeTypeInfo([], [N.StringLiteral]);
      for (; t1 = this._currentToken, t1.type === C.TokenType_iDZ;) {
        t2 = t1._next;
        this._currentToken = t2;
        t2 = t2.type;
        if (t2 === C.TokenType_fld || t2 === C.TokenType_RG0)
          strings.push(this._parseStringInterpolation$1(t1));
        else {
          t2 = this._computeStringValue$3(t1.get$lexeme(), true, true);
          t1 = new N.SimpleStringLiteral(t1, null, null, null, null, null, null);
          $.get$StringUtilities_INTERNER().toString;
          t1._ast$_value = t2;
          strings.push(t1);
        }
      }
      t2 = strings.length;
      if (t2 < 1) {
        this._reportErrorForToken$3(C.ParserErrorCode_MUB, t1, []);
        t1 = new K.StringToken(null, C.TokenType_iDZ, 0, null, null);
        t1.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = "";
        t1 = new N.SimpleStringLiteral(this._injectToken$1(t1), null, null, null, null, null, null);
        $.get$StringUtilities_INTERNER().toString;
        t1._ast$_value = "";
        return t1;
      } else if (t2 === 1)
        return strings[0];
      else {
        t1 = new N.AdjacentStrings(null, null, null, null, null);
        t1.AdjacentStrings$1(strings);
        return t1;
      }
    },
    parseTypeArgumentList$0: function() {
      var leftBracket, $arguments, t1, t2;
      leftBracket = this._expect$1(C.TokenType_KoJ);
      $arguments = H.setRuntimeTypeInfo([], [N.TypeName]);
      $arguments.push(this.parseTypeName$0());
      for (; this._optional$1(C.TokenType_s8I);)
        $arguments.push(this.parseTypeName$0());
      t1 = new N.TypeArgumentList(leftBracket, null, this._expectGt$0(), null, null);
      t2 = N.TypeName;
      t2 = H.setRuntimeTypeInfo(new N.NodeList(t1, H.setRuntimeTypeInfo([], [t2])), [t2]);
      t1._arguments = t2;
      t2.addAll$1(0, $arguments);
      return t1;
    },
    parseTypeName$0: function() {
      var t1, token, typeName, t2, typeArguments;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_var_false_VAR_29)) {
        this._reportErrorForToken$3(C.ParserErrorCode_yHZ, this._currentToken, []);
        token = this._currentToken;
        this._currentToken = token._next;
        typeName = new N.SimpleIdentifier(token, null, null, null, null, null, null, null);
      } else {
        t1 = this._currentToken;
        t2 = t1.type;
        if (t2 !== C.TokenType_nrs)
          t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
        else
          t1 = true;
        if (t1)
          typeName = this.parsePrefixedIdentifier$0();
        else {
          typeName = this._createSyntheticIdentifier$0();
          this._reportErrorForToken$3(C.ParserErrorCode_4CA, this._currentToken, []);
        }
      }
      typeArguments = this._currentToken.type === C.TokenType_KoJ ? this.parseTypeArgumentList$0() : null;
      t1 = new N.TypeName(null, null, null, null, null);
      typeName.set$parent(t1);
      t1._name = typeName;
      if (typeArguments != null)
        typeArguments.set$parent(t1);
      t1._typeArguments = typeArguments;
      return t1;
    },
    parseTypeParameter$0: function() {
      var commentAndMetadata, $name, t1, token, bound, node, t2, t3;
      commentAndMetadata = this._parseCommentAndMetadata$0();
      $name = this.parseSimpleIdentifier$0();
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_extends_false_EXTENDS_11)) {
        token = this._currentToken;
        this._currentToken = token._next;
        bound = this.parseTypeName$0();
        node = commentAndMetadata.comment;
        t1 = new N.TypeParameter(null, token, null, null, null, null, null);
        t2 = N.Annotation;
        t3 = [];
        t3.$builtinTypeInfo = [t2];
        t3 = new N.NodeList(t1, t3);
        t3.$builtinTypeInfo = [t2];
        t1._metadata = t3;
        if (node != null)
          node.set$parent(t1);
        t1._comment = node;
        t1._metadata.addAll$1(0, commentAndMetadata.metadata);
        $name.set$parent(t1);
        t1._name = $name;
        bound.set$parent(t1);
        t1._bound = bound;
        return t1;
      }
      node = commentAndMetadata.comment;
      t1 = new N.TypeParameter(null, null, null, null, null, null, null);
      t2 = N.Annotation;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._metadata = t3;
      if (node != null)
        node.set$parent(t1);
      t1._comment = node;
      t1._metadata.addAll$1(0, commentAndMetadata.metadata);
      $name.set$parent(t1);
      t1._name = $name;
      t1._bound = null;
      return t1;
    },
    parseTypeParameterList$0: function() {
      var leftBracket, typeParameters, t1, t2;
      leftBracket = this._expect$1(C.TokenType_KoJ);
      typeParameters = H.setRuntimeTypeInfo([], [N.TypeParameter]);
      typeParameters.push(this.parseTypeParameter$0());
      for (; this._optional$1(C.TokenType_s8I);)
        typeParameters.push(this.parseTypeParameter$0());
      t1 = new N.TypeParameterList(leftBracket, null, this._expectGt$0(), null, null);
      t2 = N.TypeParameter;
      t2 = H.setRuntimeTypeInfo(new N.NodeList(t1, H.setRuntimeTypeInfo([], [t2])), [t2]);
      t1._typeParameters = t2;
      t2.addAll$1(0, typeParameters);
      return t1;
    },
    parseWithClause$0: function() {
      var with2, types, t1, t2, t3;
      with2 = this._expectKeyword$1(C.Keyword_with_false_WITH_32);
      types = [];
      types.$builtinTypeInfo = [N.TypeName];
      types.push(this.parseTypeName$0());
      for (; this._optional$1(C.TokenType_s8I);)
        types.push(this.parseTypeName$0());
      t1 = new N.WithClause(null, null, null, null);
      t2 = N.TypeName;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._mixinTypes = t3;
      t1._withKeyword = with2;
      t3.addAll$1(0, types);
      return t1;
    },
    _appendScalarValue$5: function(builder, escapeSequence, scalarValue, startIndex, endIndex) {
      var t1;
      if (scalarValue >= 0)
        if (scalarValue <= 1114111)
          t1 = scalarValue >= 55296 && scalarValue <= 57343;
        else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        this._reportErrorForToken$3(C.ParserErrorCode_aRy, this._currentToken, [escapeSequence]);
        return;
      }
      if (scalarValue < 65535)
        builder.sb.write$1(H.Primitives_stringFromCharCode(scalarValue));
      else {
        t1 = L.Character_toChars(scalarValue);
        builder.sb.write$1(t1);
      }
    },
    _computeStringValue$3: function(lexeme, first, last) {
      var isRaw, start, t1, t2, t3, end, builder, index;
      if (first)
        if (X.StringUtilities_startsWith4(lexeme, 0, 114, 34, 34, 34) || X.StringUtilities_startsWith4(lexeme, 0, 114, 39, 39, 39)) {
          isRaw = true;
          start = 4;
        } else {
          t1 = lexeme.length;
          t2 = t1 - 0 >= 2;
          if (t2) {
            if (0 >= t1)
              H.throwExpression(P.RangeError$value(0));
            if (lexeme.charCodeAt(0) === 114) {
              if (1 >= t1)
                H.throwExpression(P.RangeError$value(1));
              t3 = lexeme.charCodeAt(1) === 34;
            } else
              t3 = false;
          } else
            t3 = false;
          if (!t3)
            if (t2) {
              if (0 >= t1)
                H.throwExpression(P.RangeError$value(0));
              if (lexeme.charCodeAt(0) === 114) {
                if (1 >= t1)
                  H.throwExpression(P.RangeError$value(1));
                t2 = lexeme.charCodeAt(1) === 39;
              } else
                t2 = false;
            } else
              t2 = false;
          else
            t2 = true;
          if (t2) {
            isRaw = true;
            start = 2;
          } else {
            if (X.StringUtilities_startsWith3(lexeme, 0, 34, 34, 34) || X.StringUtilities_startsWith3(lexeme, 0, 39, 39, 39))
              start = 3;
            else {
              t2 = t1 !== 0;
              if (t2) {
                if (0 >= t1)
                  H.throwExpression(P.RangeError$value(0));
                t3 = lexeme.charCodeAt(0) === 34;
              } else
                t3 = false;
              if (!t3)
                if (t2) {
                  if (0 >= t1)
                    H.throwExpression(P.RangeError$value(0));
                  t1 = lexeme.charCodeAt(0) === 39;
                } else
                  t1 = false;
              else
                t1 = true;
              start = t1 ? 1 : 0;
            }
            isRaw = false;
          }
        }
      else {
        isRaw = false;
        start = 0;
      }
      end = lexeme.length;
      if (last)
        if (X.StringUtilities_endsWith3(lexeme, 34, 34, 34) || X.StringUtilities_endsWith3(lexeme, 39, 39, 39))
          end -= 3;
        else {
          t1 = end > 0;
          if (t1) {
            t2 = end - 1;
            if (t2 >= end)
              H.throwExpression(P.RangeError$value(t2));
            t2 = lexeme.charCodeAt(t2) === 34;
          } else
            t2 = false;
          if (!t2)
            if (t1) {
              t1 = end - 1;
              if (t1 >= end)
                H.throwExpression(P.RangeError$value(t1));
              t1 = lexeme.charCodeAt(t1) === 39;
            } else
              t1 = false;
          else
            t1 = true;
          if (t1)
            --end;
        }
      if (end - start + 1 < 0) {
        t1 = $.get$AnalysisEngine__UniqueInstance()._logger;
        H.S(lexeme);
        "" + first;
        "" + last;
        t1.toString;
        return "";
      }
      if (isRaw)
        return J.substring$2$s(lexeme, start, end);
      t1 = new P.StringBuffer("");
      t1._contents = "";
      builder = new L.JavaStringBuilder(t1);
      for (index = start; index < end;)
        index = this._translateCharacter$3(builder, lexeme, index);
      return builder.sb._contents;
    },
    _couldBeStartOfCompilationUnitMember$0: function() {
      var t1, t2;
      t1 = this._currentToken;
      if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_import_true_IMPORT_42))) {
        t1 = this._currentToken;
        if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_export_true_EXPORT_37))) {
          t1 = this._currentToken;
          if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_library_true_LIBRARY_43))) {
            t1 = this._currentToken;
            t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_part_true_PART_45);
          } else
            t1 = true;
        } else
          t1 = true;
      } else
        t1 = true;
      if (t1) {
        t1 = this._currentToken._next.type;
        t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ;
      } else
        t1 = false;
      if (t1)
        return true;
      else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_class_false_CLASS_4))
          return true;
        else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_typedef_true_TYPEDEF_48)) {
            t1 = this._currentToken._next.type;
            t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ;
          } else
            t1 = false;
          if (t1)
            return true;
          else {
            t1 = this._currentToken;
            if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_void_false_VOID_30))) {
              t1 = this._currentToken;
              if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))) {
                t1 = this._currentToken;
                t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46);
              } else
                t1 = true;
              if (t1) {
                t1 = this._currentToken._next;
                t2 = t1.type;
                if (t2 !== C.TokenType_nrs)
                  t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
                else
                  t1 = true;
              } else
                t1 = false;
              if (!t1) {
                t1 = this._currentToken;
                t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next);
              } else
                t1 = true;
            } else
              t1 = true;
            if (t1)
              return true;
            else {
              t1 = this._currentToken;
              t2 = t1.type;
              if (t2 !== C.TokenType_nrs)
                t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
              else
                t1 = true;
              if (t1) {
                t1 = this._currentToken;
                if (t1._next.type === C.TokenType_MD7)
                  return true;
                if (this._skipReturnType$1(t1) == null)
                  return false;
                t1 = this._currentToken;
                if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))) {
                  t1 = this._currentToken;
                  if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46))) {
                    t1 = this._currentToken;
                    if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next))) {
                      t1 = this._currentToken;
                      t2 = t1.type;
                      if (t2 !== C.TokenType_nrs)
                        t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
                      else
                        t1 = true;
                    } else
                      t1 = true;
                  } else
                    t1 = true;
                } else
                  t1 = true;
                if (t1)
                  return true;
              }
            }
          }
        }
      }
      return false;
    },
    _createSyntheticIdentifier$0: function() {
      var t1, t2, syntheticToken, previous;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM) {
        t1 = t1.get$lexeme();
        t2 = this._currentToken;
        syntheticToken = new K.SyntheticStringToken(null, C.TokenType_nrs, 0, null, null);
        syntheticToken.offset = t2.offset;
        $.get$StringUtilities_INTERNER().toString;
        syntheticToken._value = t1;
        previous = t2.previous;
        syntheticToken._next = t2;
        t2.previous = syntheticToken;
        previous._next = syntheticToken;
        syntheticToken.previous = previous;
      } else {
        syntheticToken = new K.StringToken(null, C.TokenType_nrs, 0, null, null);
        syntheticToken.offset = t1.offset;
        $.get$StringUtilities_INTERNER().toString;
        syntheticToken._value = "";
        previous = t1.previous;
        syntheticToken._next = t1;
        t1.previous = syntheticToken;
        previous._next = syntheticToken;
        syntheticToken.previous = previous;
      }
      return new N.SimpleIdentifier(syntheticToken, null, null, null, null, null, null, null);
    },
    _ensureAssignable$1: function(expression) {
      if (expression != null && !expression.get$isAssignable())
        this._reportErrorForToken$3(C.ParserErrorCode_8hp, this._currentToken, []);
    },
    _expect$1: function(type) {
      var t1, t2;
      t1 = this._currentToken;
      if (t1.type === type) {
        this._currentToken = t1._next;
        return t1;
      }
      t2 = type.lexeme;
      if (type === C.TokenType_S8h)
        this._reportErrorForToken$3(C.ParserErrorCode_s8i, t1.previous, [t2]);
      else
        this._reportErrorForToken$3(C.ParserErrorCode_s8i, t1, [t2]);
      return this._currentToken;
    },
    _expectGt$0: function() {
      if (this._matchesGt$0()) {
        var token = this._currentToken;
        this._currentToken = token._next;
        return token;
      }
      this._reportErrorForToken$3(C.ParserErrorCode_s8i, this._currentToken, [C.TokenType_Bac.lexeme]);
      return this._currentToken;
    },
    _expectKeyword$1: function(keyword) {
      var token;
      if (this._tokenMatchesKeyword$2(this._currentToken, keyword)) {
        token = this._currentToken;
        this._currentToken = token._next;
        return token;
      }
      this._reportErrorForToken$3(C.ParserErrorCode_s8i, this._currentToken, [keyword.syntax]);
      return this._currentToken;
    },
    _expectSemicolon$0: function() {
      var t1 = this._currentToken;
      if (t1.type === C.TokenType_S8h) {
        this._currentToken = t1._next;
        return t1;
      } else {
        this._reportErrorForToken$3(C.ParserErrorCode_s8i, t1.previous, [";"]);
        t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
        t1.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = "";
        return this._injectToken$1(t1);
      }
    },
    _findRange$2: function(ranges, index) {
      var rangeCount, i, range, t1;
      rangeCount = ranges.length;
      for (i = 0; i < rangeCount; ++i) {
        range = ranges[i];
        t1 = range[0];
        if (t1 <= index && index <= range[1])
          return range;
        else if (index < t1)
          return;
      }
      return;
    },
    _getCodeBlockRanges$1: function(comment) {
      var ranges, $length, secondChar, thirdChar, t1, index, currentChar, end, t2, index0;
      ranges = [];
      ranges.$builtinTypeInfo = [[P.List, P.$int]];
      $length = comment.length;
      if ($length < 3)
        return ranges;
      if (comment.charCodeAt(0) === 47) {
        secondChar = comment.charCodeAt(1);
        thirdChar = comment.charCodeAt(2);
        if (!(secondChar === 42 && thirdChar === 42))
          t1 = secondChar === 47 && thirdChar === 47;
        else
          t1 = true;
        index = t1 ? 3 : 0;
      } else
        index = 0;
      for (; index < $length;) {
        if (index < 0)
          H.throwExpression(P.RangeError$value(index));
        if (index >= $length)
          H.throwExpression(P.RangeError$value(index));
        currentChar = comment.charCodeAt(index);
        if (currentChar === 13 || currentChar === 10) {
          ++index;
          while (true) {
            if (index < $length) {
              if (index < 0)
                H.throwExpression(P.RangeError$value(index));
              if (index >= $length)
                H.throwExpression(P.RangeError$value(index));
              t1 = comment.charCodeAt(index);
              t1 = t1 === 9 || t1 === 32 || t1 === 10 || t1 === 13;
            } else
              t1 = false;
            if (!t1)
              break;
            ++index;
          }
          if ($length - index >= 6) {
            if (index < 0)
              H.throwExpression(P.RangeError$value(index));
            if (index >= $length)
              H.throwExpression(P.RangeError$value(index));
            if (comment.charCodeAt(index) === 42) {
              t1 = index + 1;
              if (t1 < 0)
                H.throwExpression(P.RangeError$value(t1));
              if (t1 >= $length)
                H.throwExpression(P.RangeError$value(t1));
              if (comment.charCodeAt(t1) === 32) {
                t1 = index + 2;
                if (t1 < 0)
                  H.throwExpression(P.RangeError$value(t1));
                if (t1 >= $length)
                  H.throwExpression(P.RangeError$value(t1));
                if (comment.charCodeAt(t1) === 32) {
                  t1 = index + 3;
                  if (t1 < 0)
                    H.throwExpression(P.RangeError$value(t1));
                  if (t1 >= $length)
                    H.throwExpression(P.RangeError$value(t1));
                  if (comment.charCodeAt(t1) === 32) {
                    t1 = index + 4;
                    if (t1 < 0)
                      H.throwExpression(P.RangeError$value(t1));
                    if (t1 >= $length)
                      H.throwExpression(P.RangeError$value(t1));
                    if (comment.charCodeAt(t1) === 32) {
                      t1 = index + 5;
                      if (t1 < 0)
                        H.throwExpression(P.RangeError$value(t1));
                      if (t1 >= $length)
                        H.throwExpression(P.RangeError$value(t1));
                      t1 = comment.charCodeAt(t1) === 32;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
          if (t1) {
            end = index + 6;
            while (true) {
              if (end < $length) {
                t1 = end < 0;
                if (t1)
                  H.throwExpression(P.RangeError$value(end));
                t2 = end >= $length;
                if (t2)
                  H.throwExpression(P.RangeError$value(end));
                if (comment.charCodeAt(end) !== 13) {
                  if (t1)
                    H.throwExpression(P.RangeError$value(end));
                  if (t2)
                    H.throwExpression(P.RangeError$value(end));
                  t1 = comment.charCodeAt(end) !== 10;
                } else
                  t1 = false;
              } else
                t1 = false;
              if (!t1)
                break;
              ++end;
            }
            t1 = [index, end];
            t1.$builtinTypeInfo = [P.$int];
            ranges.push(t1);
            index = end;
          }
        } else {
          index0 = index + 1;
          if (index0 < $length)
            if (currentChar === 91) {
              if (index0 < 0)
                H.throwExpression(P.RangeError$value(index0));
              if (index0 >= $length)
                H.throwExpression(P.RangeError$value(index0));
              t1 = comment.charCodeAt(index0) === 58;
            } else
              t1 = false;
          else
            t1 = false;
          if (t1) {
            end = X.StringUtilities_indexOf2(comment, index + 2, 58, 93);
            if (end < 0)
              end = $length;
            t1 = [index, end];
            t1.$builtinTypeInfo = [P.$int];
            ranges.push(t1);
            index = end + 1;
          } else
            index = index0;
        }
      }
      return ranges;
    },
    _getEndToken$1: function(beginToken) {
      if (!!J.getInterceptor(beginToken).$isBeginToken)
        return beginToken.endToken;
      return;
    },
    get$hasReturnTypeInTypeAlias: function() {
      var next = this._skipReturnType$1(this._currentToken);
      if (next == null)
        return false;
      return this._tokenMatchesIdentifier$1(next);
    },
    _injectToken$1: function(token) {
      var t1, previous;
      t1 = this._currentToken;
      previous = t1.previous;
      token._next = t1;
      t1.previous = token;
      previous._next = token;
      token.previous = previous;
      return token;
    },
    _isFunctionDeclaration$0: function() {
      var afterReturnType, afterIdentifier, afterName, t1;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_void_false_VOID_30))
        return true;
      afterReturnType = this._skipTypeName$1(this._currentToken);
      afterIdentifier = this._skipSimpleIdentifier$1(afterReturnType == null ? this._currentToken : afterReturnType);
      if (afterIdentifier == null)
        afterIdentifier = this._skipSimpleIdentifier$1(this._currentToken);
      if (afterIdentifier == null)
        return false;
      if (this._isFunctionExpression$1(afterIdentifier))
        return true;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_get_true_GET_40)) {
        afterName = this._skipSimpleIdentifier$1(this._currentToken._next);
        if (afterName == null)
          return false;
        t1 = afterName.type;
        return t1 === C.TokenType_iJT || t1 === C.TokenType_qFj;
      }
      return false;
    },
    _isFunctionExpression$1: function(startToken) {
      var afterParameters, lexeme;
      if (this._inInitializer)
        return false;
      afterParameters = this._skipFormalParameterList$1(startToken);
      if (afterParameters == null)
        return false;
      if (afterParameters.matchesAny$1([C.TokenType_qFj, C.TokenType_iJT]))
        return true;
      if (this._parseAsync) {
        lexeme = afterParameters.get$lexeme();
        return lexeme === $.Parser_ASYNC || lexeme === $.Parser_SYNC;
      }
      return false;
    },
    _isHexDigit$1: function(character) {
      var t1;
      if (!(48 <= character && character <= 57))
        if (!(65 <= character && character <= 70))
          t1 = 97 <= character && character <= 102;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    _isInitializedVariableDeclaration$0: function() {
      var token, type;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_final_false_FINAL_13) || this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_var_false_VAR_29))
        return true;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_const_false_CONST_5))
        return !this._currentToken._next.matchesAny$1([C.TokenType_KoJ, C.TokenType_qFj, C.TokenType_AHF, C.TokenType_WFw]);
      token = this._skipTypeName$1(this._currentToken);
      if (token == null)
        return false;
      token = this._skipSimpleIdentifier$1(token);
      if (token == null)
        return false;
      type = token.type;
      return type === C.TokenType_Azp || type === C.TokenType_s8I || type === C.TokenType_S8h || this._tokenMatchesKeyword$2(token, C.Keyword_in_false_IN_17);
    },
    _isLinkText$2: function(comment, rightIndex) {
      var $length, index, nextChar;
      $length = comment.length;
      index = rightIndex + 1;
      if (index >= $length)
        return false;
      if (index < 0)
        H.throwExpression(P.RangeError$value(index));
      nextChar = comment.charCodeAt(index);
      if (nextChar === 40 || nextChar === 58)
        return true;
      while (true) {
        if (!(nextChar === 9 || nextChar === 32 || nextChar === 10 || nextChar === 13))
          break;
        ++index;
        if (index >= $length)
          return false;
        if (index < 0)
          H.throwExpression(P.RangeError$value(index));
        nextChar = comment.charCodeAt(index);
      }
      return nextChar === 91;
    },
    _isOperator$1: function(startToken) {
      var t1, token;
      t1 = startToken.type;
      if (!t1.get$isOperator())
        return false;
      if (t1 === C.TokenType_Azp)
        return false;
      token = startToken._next;
      while (true) {
        t1 = token.type;
        if (!(t1._tokenClass !== C.TokenClass_0_NO_CLASS_0 && t1 !== C.TokenType_MD7 && t1 !== C.TokenType_AHF && t1 !== C.TokenType_B6W))
          break;
        token = token._next;
      }
      return t1 === C.TokenType_MD7;
    },
    _isSwitchMember$0: function() {
      var token, t1, keyword;
      token = this._currentToken;
      while (true) {
        t1 = token.type;
        if (!(t1 === C.TokenType_nrs && token._next.type === C.TokenType_chs))
          break;
        token = token._next._next;
      }
      if (t1 === C.TokenType_hLM) {
        keyword = H.interceptedTypeCast(token, "$isKeywordToken").keyword;
        t1 = J.getInterceptor(keyword);
        return t1.$eq(keyword, C.Keyword_case_false_CASE_2) || t1.$eq(keyword, C.Keyword_default_false_DEFAULT_7);
      }
      return false;
    },
    _isTypedIdentifier$1: function(startToken) {
      var token, t1;
      token = this._skipReturnType$1(startToken);
      if (token == null)
        return false;
      else if (this._tokenMatchesIdentifier$1(token))
        return true;
      else {
        if (this._tokenMatchesKeyword$2(token, C.Keyword_this_false_THIS_25)) {
          t1 = token._next;
          t1 = t1.type === C.TokenType_B6W && this._tokenMatchesIdentifier$1(t1._next);
        } else
          t1 = false;
        if (t1)
          return true;
      }
      return false;
    },
    _lexicallyFirst$1: function(tokens) {
      var t1, first, firstOffset, token, offset;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(tokens, 3, 0, null), [H.getTypeArgumentByIndex(tokens, 0)]), first = null, firstOffset = 2147483647; t1.moveNext$0();) {
        token = t1._current;
        if (token != null) {
          offset = token.get$offset();
          if (typeof offset !== "number")
            return offset.$lt();
          if (offset < firstOffset) {
            firstOffset = offset;
            first = token;
          }
        }
      }
      return first;
    },
    _matchesGt$0: function() {
      var t1, currentType, offset, first, second, t2, third;
      t1 = this._currentToken;
      currentType = t1.type;
      if (currentType === C.TokenType_Bac)
        return true;
      else if (currentType === C.TokenType_WFo) {
        offset = t1.offset;
        first = new K.Token(C.TokenType_Bac, 0, null, null);
        first.offset = offset;
        second = new K.Token(C.TokenType_Bac, 0, null, null);
        second.offset = offset + 1;
        t2 = t1._next;
        second._next = t2;
        t2.previous = second;
        first._next = second;
        second.previous = first;
        t1 = t1.previous;
        t1._next = first;
        first.previous = t1;
        this._currentToken = first;
        return true;
      } else if (currentType === C.TokenType_juX) {
        offset = t1.offset;
        first = new K.Token(C.TokenType_Bac, 0, null, null);
        first.offset = offset;
        second = new K.Token(C.TokenType_Azp, 0, null, null);
        second.offset = offset + 1;
        t2 = t1._next;
        second._next = t2;
        t2.previous = second;
        first._next = second;
        second.previous = first;
        t1 = t1.previous;
        t1._next = first;
        first.previous = t1;
        this._currentToken = first;
        return true;
      } else if (currentType === C.TokenType_y9W) {
        offset = t1.offset;
        first = new K.Token(C.TokenType_Bac, 0, null, null);
        first.offset = offset;
        second = new K.Token(C.TokenType_Bac, 0, null, null);
        second.offset = offset + 1;
        third = new K.Token(C.TokenType_Azp, 0, null, null);
        third.offset = offset + 2;
        t2 = t1._next;
        third._next = t2;
        t2.previous = third;
        second._next = third;
        third.previous = second;
        first._next = second;
        second.previous = first;
        t1 = t1.previous;
        t1._next = first;
        first.previous = t1;
        this._currentToken = first;
        return true;
      }
      return false;
    },
    _matchesString$1: function(identifier) {
      var t1 = this._currentToken;
      return t1.type === C.TokenType_nrs && t1.get$lexeme() === identifier;
    },
    _optional$1: function(type) {
      var t1 = this._currentToken;
      if (t1.type === type) {
        this._currentToken = t1._next;
        return true;
      }
      return false;
    },
    _parseAdditiveExpression$0: function() {
      var t1, token, expression, node, expression0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type._tokenClass === C.TokenClass_12_ADDITIVE_OPERATOR_1) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseMultiplicativeExpression$0();
      for (; t1 = this._currentToken, t1.type._tokenClass === C.TokenClass_12_ADDITIVE_OPERATOR_1; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseMultiplicativeExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseAssignableExpression$1: function(primaryAllowed) {
      var token, expression, t1, isOptional, argumentList, t2, expression0, node, node0, selectorExpression;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_super_false_SUPER_23)) {
        token = this._currentToken;
        this._currentToken = token._next;
        return this._parseAssignableSelector$2(new N.SuperExpression(token, null, null, null, null), false);
      }
      expression = this._parsePrimaryExpression$0();
      t1 = !primaryAllowed;
      isOptional = !t1 || !!J.getInterceptor(expression).$isSimpleIdentifier;
      for (; true; expression = selectorExpression, isOptional = true) {
        for (; this._currentToken.type === C.TokenType_MD7;) {
          argumentList = this.parseArgumentList$0();
          t2 = J.getInterceptor(expression);
          if (!!t2.$isSimpleIdentifier) {
            expression0 = new N.MethodInvocation(null, null, null, null, null, null, null, null);
            expression0._target = null;
            expression.set$parent(expression0);
            expression0._methodName = expression;
            if (argumentList != null)
              argumentList.set$parent(expression0);
            expression0._argumentList = argumentList;
            expression = expression0;
          } else if (!!t2.$isPrefixedIdentifier) {
            node = expression._prefix;
            t2 = expression.period;
            node0 = expression._identifier;
            expression = new N.MethodInvocation(null, t2, null, null, null, null, null, null);
            if (node != null)
              node.set$parent(expression);
            expression._target = node;
            if (node0 != null)
              node0.set$parent(expression);
            expression._methodName = node0;
            if (argumentList != null)
              argumentList.set$parent(expression);
            expression._argumentList = argumentList;
          } else if (!!t2.$isPropertyAccess) {
            node = expression._target;
            t2 = expression.operator;
            node0 = expression._propertyName;
            expression = new N.MethodInvocation(null, t2, null, null, null, null, null, null);
            if (node != null)
              node.set$parent(expression);
            expression._target = node;
            if (node0 != null)
              node0.set$parent(expression);
            expression._methodName = node0;
            if (argumentList != null)
              argumentList.set$parent(expression);
            expression._argumentList = argumentList;
          } else {
            expression0 = new N.FunctionExpressionInvocation(null, null, null, null, null, null, null, null);
            if (expression != null)
              expression.set$parent(expression0);
            expression0._function = expression;
            if (argumentList != null)
              argumentList.set$parent(expression0);
            expression0._argumentList = argumentList;
            expression = expression0;
          }
          if (t1)
            isOptional = false;
        }
        t2 = !isOptional;
        selectorExpression = this._parseAssignableSelector$2(expression, !t2 || !!J.getInterceptor(expression).$isPrefixedIdentifier);
        if (selectorExpression == null ? expression == null : selectorExpression === expression) {
          if (t2 && !!J.getInterceptor(expression).$isPrefixedIdentifier) {
            H.interceptedTypeCast(expression, "$isPrefixedIdentifier");
            node = expression._prefix;
            t1 = expression.period;
            node0 = expression._identifier;
            expression = new N.PropertyAccess(null, t1, null, null, null, null, null);
            if (node != null)
              node.set$parent(expression);
            expression._target = node;
            if (node0 != null)
              node0.set$parent(expression);
            expression._propertyName = node0;
          }
          return expression;
        }
      }
    },
    _parseAssignableSelector$2: function(prefix, optional) {
      var leftBracket, wasInInitializer, index, rightBracket, t1, t2, node, node0;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_AHF) {
        this._currentToken = t1._next;
        leftBracket = t1;
        wasInInitializer = this._inInitializer;
        this._inInitializer = false;
        try {
          index = this.parseExpression2$0();
          rightBracket = this._expect$1(C.TokenType_58K);
          node = prefix;
          node0 = index;
          t1 = new N.IndexExpression(null, null, null, null, null, null, null, null, null, null, null, null);
          if (node != null)
            node.set$parent(t1);
          t1._target = node;
          t1._leftBracket = leftBracket;
          if (node0 != null)
            node0.set$parent(t1);
          t1._ast$_index = node0;
          t1._rightBracket = rightBracket;
          return t1;
        } finally {
          this._inInitializer = wasInInitializer;
        }
      } else if (t2 === C.TokenType_B6W) {
        this._currentToken = t1._next;
        node = prefix;
        node0 = this.parseSimpleIdentifier$0();
        t1 = new N.PropertyAccess(null, t1, null, null, null, null, null);
        if (node != null)
          node.set$parent(t1);
        t1._target = node;
        node0.set$parent(t1);
        t1._propertyName = node0;
        return t1;
      } else {
        if (!optional)
          this._reportErrorForToken$3(C.ParserErrorCode_if8, t1, []);
        return prefix;
      }
    },
    _parseBitwiseAndExpression$0: function() {
      var t1, token, expression, node, expression0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type === C.TokenType_0GE) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseShiftExpression$0();
      for (; t1 = this._currentToken, t1.type === C.TokenType_0GE; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseShiftExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseBitwiseXorExpression$0: function() {
      var t1, token, expression, node, expression0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type === C.TokenType_ub9) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseBitwiseAndExpression$0();
      for (; t1 = this._currentToken, t1.type === C.TokenType_ub9; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseBitwiseAndExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseCascadeSection$0: function() {
      var period, expression, leftBracket, wasInInitializer, index, rightBracket, t1, t2, functionName, node, expression0, node0, node1, progress, selector, propertyAccess;
      period = this._expect$1(C.TokenType_mGg);
      expression = null;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 !== C.TokenType_nrs)
        t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
      else
        t1 = true;
      if (t1)
        functionName = this.parseSimpleIdentifier$0();
      else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_AHF) {
          this._currentToken = t1._next;
          leftBracket = t1;
          wasInInitializer = this._inInitializer;
          this._inInitializer = false;
          try {
            index = this.parseExpression2$0();
            rightBracket = this._expect$1(C.TokenType_58K);
            node = index;
            expression0 = new N.IndexExpression(null, period, null, null, null, null, null, null, null, null, null, null);
            expression0._leftBracket = leftBracket;
            if (node != null)
              node.set$parent(expression0);
            expression0._ast$_index = node;
            expression0._rightBracket = rightBracket;
            expression = expression0;
            period = null;
          } finally {
            this._inInitializer = wasInInitializer;
          }
          functionName = null;
        } else {
          this._reportErrorForToken$3(C.ParserErrorCode_yw2, t1, [t1.get$lexeme()]);
          functionName = this._createSyntheticIdentifier$0();
        }
      }
      if (this._currentToken.type === C.TokenType_MD7)
        for (; this._currentToken.type === C.TokenType_MD7;)
          if (functionName != null) {
            node = expression;
            node0 = this.parseArgumentList$0();
            expression0 = new N.MethodInvocation(null, period, null, null, null, null, null, null);
            if (node != null)
              node.set$parent(expression0);
            expression0._target = node;
            functionName.set$parent(expression0);
            expression0._methodName = functionName;
            if (node0 != null)
              node0.set$parent(expression0);
            expression0._argumentList = node0;
            expression = expression0;
            period = null;
            functionName = null;
          } else if (expression == null) {
            node = expression;
            node0 = this._createSyntheticIdentifier$0();
            node1 = this.parseArgumentList$0();
            expression0 = new N.MethodInvocation(null, period, null, null, null, null, null, null);
            if (node != null)
              node.set$parent(expression0);
            expression0._target = node;
            node0.set$parent(expression0);
            expression0._methodName = node0;
            if (node1 != null)
              node1.set$parent(expression0);
            expression0._argumentList = node1;
            expression = expression0;
          } else {
            node = expression;
            node0 = this.parseArgumentList$0();
            expression0 = new N.FunctionExpressionInvocation(null, null, null, null, null, null, null, null);
            if (node != null)
              node.set$parent(expression0);
            expression0._function = node;
            if (node0 != null)
              node0.set$parent(expression0);
            expression0._argumentList = node0;
            expression = expression0;
          }
      else if (functionName != null) {
        node = expression;
        expression0 = new N.PropertyAccess(null, period, null, null, null, null, null);
        if (node != null)
          node.set$parent(expression0);
        expression0._target = node;
        functionName.set$parent(expression0);
        expression0._propertyName = functionName;
        expression = expression0;
        period = null;
      }
      for (progress = true; progress;) {
        selector = this._parseAssignableSelector$2(expression, true);
        t1 = expression;
        if (selector == null ? t1 != null : selector !== t1) {
          expression = selector;
          for (; this._currentToken.type === C.TokenType_MD7;)
            if (!!J.getInterceptor(expression).$isPropertyAccess) {
              propertyAccess = H.interceptedTypeCast(expression, "$isPropertyAccess");
              node = propertyAccess._target;
              t1 = propertyAccess.operator;
              node0 = propertyAccess._propertyName;
              node1 = this.parseArgumentList$0();
              expression0 = new N.MethodInvocation(null, t1, null, null, null, null, null, null);
              if (node != null)
                node.set$parent(expression0);
              expression0._target = node;
              if (node0 != null)
                node0.set$parent(expression0);
              expression0._methodName = node0;
              if (node1 != null)
                node1.set$parent(expression0);
              expression0._argumentList = node1;
              expression = expression0;
            } else {
              node = expression;
              node0 = this.parseArgumentList$0();
              expression0 = new N.FunctionExpressionInvocation(null, null, null, null, null, null, null, null);
              if (node != null)
                node.set$parent(expression0);
              expression0._function = node;
              if (node0 != null)
                node0.set$parent(expression0);
              expression0._argumentList = node0;
              expression = expression0;
            }
          progress = true;
        } else
          progress = false;
      }
      t1 = this._currentToken;
      if (t1.type._tokenClass === C.TokenClass_1_ASSIGNMENT_OPERATOR_2) {
        this._currentToken = t1._next;
        t2 = expression;
        if (t2 != null && !t2.get$isAssignable())
          this._reportErrorForToken$3(C.ParserErrorCode_8hp, this._currentToken, []);
        expression = N.AssignmentExpression$(expression, t1, this.parseExpressionWithoutCascade$0());
      }
      return expression;
    },
    _parseClassDeclaration$2: function(commentAndMetadata, abstractKeyword) {
      var keyword, next, t1, $name, className, typeParameters, extendsClause, withClause, implementsClause, foundClause, keyword0, superclass, token, nativeClause, leftBracket, members, rightBracket, t2, classDeclaration;
      keyword = this._expectKeyword$1(C.Keyword_class_false_CLASS_4);
      if (this._tokenMatchesIdentifier$1(this._currentToken)) {
        next = this._currentToken._next;
        t1 = next.type;
        if (t1 === C.TokenType_KoJ) {
          next = this._skipTypeParameterList$1(next);
          if (next != null && next.type === C.TokenType_Azp)
            return this._parseClassTypeAlias$3(commentAndMetadata, abstractKeyword, keyword);
        } else if (t1 === C.TokenType_Azp)
          return this._parseClassTypeAlias$3(commentAndMetadata, abstractKeyword, keyword);
      }
      $name = this.parseSimpleIdentifier$0();
      className = $name.token.get$lexeme();
      typeParameters = this._currentToken.type === C.TokenType_KoJ ? this.parseTypeParameterList$0() : null;
      for (extendsClause = null, withClause = null, implementsClause = null, foundClause = true; foundClause;) {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_extends_false_EXTENDS_11))
          if (extendsClause == null) {
            keyword0 = this._expectKeyword$1(C.Keyword_extends_false_EXTENDS_11);
            superclass = this.parseTypeName$0();
            extendsClause = new N.ExtendsClause(keyword0, null, null, null);
            superclass.set$parent(extendsClause);
            extendsClause._superclass = superclass;
            if (withClause != null)
              this._reportErrorForToken$3(C.ParserErrorCode_c1W, withClause._withKeyword, []);
            else if (implementsClause != null)
              this._reportErrorForToken$3(C.ParserErrorCode_86y, implementsClause.keyword, []);
          } else {
            this._reportErrorForToken$3(C.ParserErrorCode_CeS, extendsClause.keyword, []);
            keyword0 = this._expectKeyword$1(C.Keyword_extends_false_EXTENDS_11);
            superclass = this.parseTypeName$0();
            t1 = new N.ExtendsClause(keyword0, null, null, null);
            superclass.set$parent(t1);
            t1._superclass = superclass;
          }
        else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_with_false_WITH_32))
            if (withClause == null) {
              withClause = this.parseWithClause$0();
              if (implementsClause != null)
                this._reportErrorForToken$3(C.ParserErrorCode_MUw, implementsClause.keyword, []);
            } else {
              this._reportErrorForToken$3(C.ParserErrorCode_ECL0, withClause._withKeyword, []);
              this.parseWithClause$0();
            }
          else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_implements_true_IMPLEMENTS_41))
              if (implementsClause == null)
                implementsClause = this.parseImplementsClause$0();
              else {
                this._reportErrorForToken$3(C.ParserErrorCode_WXJ, implementsClause.keyword, []);
                this.parseImplementsClause$0();
              }
            else
              foundClause = false;
          }
        }
      }
      if (withClause != null && extendsClause == null)
        this._reportErrorForToken$3(C.ParserErrorCode_ubf, withClause._withKeyword, []);
      if (this._matchesString$1($.Parser__NATIVE) && this._currentToken._next.type === C.TokenType_iDZ) {
        token = this._currentToken;
        this._currentToken = token._next;
        nativeClause = new N.NativeClause(token, null, null, null);
        nativeClause._name = nativeClause.becomeParentOf$1(this.parseStringLiteral$0());
      } else
        nativeClause = null;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_qFj) {
        leftBracket = this._expect$1(C.TokenType_qFj);
        members = this._parseClassMembers$2(className, this._getEndToken$1(leftBracket));
        rightBracket = this._expect$1(C.TokenType_33I);
      } else {
        t2 = new K.StringToken(null, C.TokenType_qFj, 0, null, null);
        t2.offset = t1.offset;
        $.get$StringUtilities_INTERNER().toString;
        t2._value = "";
        leftBracket = this._injectToken$1(t2);
        t2 = new K.StringToken(null, C.TokenType_33I, 0, null, null);
        t2.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t2._value = "";
        rightBracket = this._injectToken$1(t2);
        this._reportErrorForToken$3(C.ParserErrorCode_Aec, this._currentToken, []);
        members = null;
      }
      t1 = commentAndMetadata.comment;
      t2 = commentAndMetadata.metadata;
      classDeclaration = new N.ClassDeclaration(abstractKeyword, keyword, null, null, null, null, null, null, leftBracket, null, rightBracket, null, null, null, null);
      classDeclaration.AnnotatedNode$2(t1, t2);
      classDeclaration.ClassDeclaration$12(t1, t2, abstractKeyword, keyword, $name, typeParameters, extendsClause, withClause, implementsClause, leftBracket, members, rightBracket);
      classDeclaration._nativeClause = classDeclaration.becomeParentOf$1(nativeClause);
      return classDeclaration;
    },
    _parseClassMembers$2: function(className, closingBracket) {
      var members, memberStart, t1, t2, t3, member;
      members = H.setRuntimeTypeInfo([], [N.ClassMember]);
      memberStart = this._currentToken;
      t1 = closingBracket == null;
      t2 = memberStart;
      while (true) {
        t3 = t2.type;
        if (t3 !== C.TokenType_EOF_Imi)
          if (t3 !== C.TokenType_33I)
            if (t1)
              if (!(t3 === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t2, "$isKeywordToken").keyword, C.Keyword_class_false_CLASS_4))) {
                t2 = this._currentToken;
                t2 = !(t2.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t2, "$isKeywordToken").keyword, C.Keyword_typedef_true_TYPEDEF_48));
              } else
                t2 = false;
            else
              t2 = true;
          else
            t2 = false;
        else
          t2 = false;
        if (!t2)
          break;
        t2 = this._currentToken;
        if (t2.type === C.TokenType_S8h) {
          this._reportErrorForToken$3(C.ParserErrorCode_udD, t2, [t2.get$lexeme()]);
          this._currentToken = this._currentToken._next;
        } else {
          member = this.parseClassMember$1(className);
          if (member != null)
            members.push(member);
        }
        t2 = this._currentToken;
        if (t2 == null ? memberStart == null : t2 === memberStart) {
          this._reportErrorForToken$3(C.ParserErrorCode_udD, t2, [t2.get$lexeme()]);
          t2 = this._currentToken._next;
          this._currentToken = t2;
          memberStart = t2;
        } else
          memberStart = t2;
        t2 = memberStart;
      }
      return members;
    },
    _parseClassTypeAlias$3: function(commentAndMetadata, abstractKeyword, classKeyword) {
      var className, typeParameters, equals, superclass, withClause, implementsClause, semicolon, t1, t2, token, t3;
      className = this.parseSimpleIdentifier$0();
      typeParameters = this._currentToken.type === C.TokenType_KoJ ? this.parseTypeParameterList$0() : null;
      equals = this._expect$1(C.TokenType_Azp);
      superclass = this.parseTypeName$0();
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_with_false_WITH_32))
        withClause = this.parseWithClause$0();
      else {
        this._reportErrorForToken$3(C.ParserErrorCode_s8i, this._currentToken, [C.Keyword_with_false_WITH_32.syntax]);
        withClause = null;
      }
      implementsClause = this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_implements_true_IMPLEMENTS_41) ? this.parseImplementsClause$0() : null;
      semicolon = this._currentToken;
      t1 = semicolon.type;
      if (t1 === C.TokenType_S8h)
        this._currentToken = semicolon._next;
      else {
        t2 = C.TokenType_S8h.lexeme;
        if (t1 === C.TokenType_qFj) {
          this._reportErrorForToken$3(C.ParserErrorCode_s8i, semicolon, [t2]);
          token = this._currentToken;
          this._currentToken = token._next;
          this._parseClassMembers$2(className.token.get$lexeme(), this._getEndToken$1(token));
          this._expect$1(C.TokenType_33I);
        } else
          this._reportErrorForToken$3(C.ParserErrorCode_s8i, semicolon.previous, [t2]);
        t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
        t1.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = "";
        semicolon = this._injectToken$1(t1);
      }
      t1 = commentAndMetadata.comment;
      t2 = commentAndMetadata.metadata;
      t3 = new N.ClassTypeAlias(null, null, equals, abstractKeyword, null, null, null, classKeyword, semicolon, null, null, null, null);
      t3.AnnotatedNode$2(t1, t2);
      t3.ClassTypeAlias$11(t1, t2, classKeyword, className, typeParameters, equals, abstractKeyword, superclass, withClause, implementsClause, semicolon);
      return t3;
    },
    _parseCombinators$0: function() {
      var combinators, t1, t2, keyword, shownNames, t3, hiddenNames;
      combinators = H.setRuntimeTypeInfo([], [N.Combinator]);
      while (true) {
        t1 = $.Parser__SHOW;
        t2 = this._currentToken;
        if (!(t2.type === C.TokenType_nrs && t2.get$lexeme() === t1)) {
          t1 = $.Parser__HIDE;
          t2 = this._currentToken;
          t1 = t2.type === C.TokenType_nrs && t2.get$lexeme() === t1;
        } else
          t1 = true;
        if (!t1)
          break;
        keyword = this._expect$1(C.TokenType_nrs);
        if (keyword.get$lexeme() === $.Parser__SHOW) {
          shownNames = this._parseIdentifierList$0();
          t1 = new N.ShowCombinator(null, keyword, null, null);
          t2 = N.SimpleIdentifier;
          t3 = [];
          t3.$builtinTypeInfo = [t2];
          t3 = new N.NodeList(t1, t3);
          t3.$builtinTypeInfo = [t2];
          t1._shownNames = t3;
          t3.addAll$1(0, shownNames);
          combinators.push(t1);
        } else {
          hiddenNames = this._parseIdentifierList$0();
          t1 = new N.HideCombinator(null, keyword, null, null);
          t2 = N.SimpleIdentifier;
          t3 = [];
          t3.$builtinTypeInfo = [t2];
          t3 = new N.NodeList(t1, t3);
          t3.$builtinTypeInfo = [t2];
          t1._hiddenNames = t3;
          t3.addAll$1(0, hiddenNames);
          combinators.push(t1);
        }
      }
      return combinators;
    },
    _parseCommentAndMetadata$0: function() {
      var comment, metadata, atSign, $name, period, constructorName, $arguments, t1, optionalComment;
      comment = this._parseDocumentationComment$0();
      metadata = [];
      metadata.$builtinTypeInfo = [N.Annotation];
      for (; this._currentToken.type === C.TokenType_27D;) {
        atSign = this._expect$1(C.TokenType_27D);
        $name = this.parsePrefixedIdentifier$0();
        period = this._currentToken;
        if (period.type === C.TokenType_B6W) {
          this._currentToken = period._next;
          constructorName = this.parseSimpleIdentifier$0();
        } else {
          period = null;
          constructorName = null;
        }
        $arguments = this._currentToken.type === C.TokenType_MD7 ? this.parseArgumentList$0() : null;
        t1 = new N.Annotation(atSign, null, period, null, null, null, null, null, null);
        $name.set$parent(t1);
        t1._name = $name;
        if (constructorName != null)
          constructorName.set$parent(t1);
        t1._constructorName = constructorName;
        if ($arguments != null)
          $arguments.set$parent(t1);
        t1._arguments = $arguments;
        metadata.push(t1);
        optionalComment = this._parseDocumentationComment$0();
        if (optionalComment != null)
          comment = optionalComment;
      }
      return new S.CommentAndMetadata(comment, metadata);
    },
    _parseCommentReference$2: function(referenceSource, sourceOffset) {
      var listener, scanner, firstToken, newKeyword, secondToken, thirdToken, nextToken, identifier, syntheticToken, node, t1, t2, t3, scanner0, node0, identifier0, exception;
      if (J.get$length$as(referenceSource) === 0) {
        syntheticToken = new K.SyntheticStringToken(null, C.TokenType_nrs, 0, null, null);
        syntheticToken.offset = sourceOffset;
        $.get$StringUtilities_INTERNER().toString;
        syntheticToken._value = "";
        node = new N.SimpleIdentifier(syntheticToken, null, null, null, null, null, null, null);
        t1 = new N.CommentReference(null, null, null, null);
        node.set$parent(t1);
        t1._identifier = node;
        return t1;
      }
      try {
        listener = new U.BooleanErrorListener(false);
        t1 = referenceSource;
        t2 = new K.SubSequenceReader(sourceOffset, t1, 0, 0);
        t2._stringLength = J.get$length$as(t1);
        t2._charOffset = -1;
        t1 = [];
        t1.$builtinTypeInfo = [P.$int];
        t3 = [];
        t3.$builtinTypeInfo = [K.BeginToken];
        scanner0 = new K.Scanner(null, t2, listener, true, null, null, null, null, 0, t1, t3, -1, false);
        t2 = new K.Token(C.TokenType_EOF_Imi, 0, null, null);
        t2.offset = -1;
        scanner0._tokens = t2;
        t2._next = t2;
        t2.previous = t2;
        scanner0._tail = t2;
        scanner0._tokenStart = -1;
        t1.push(0);
        scanner = scanner0;
        scanner.setSourceStart$2(1, 1);
        firstToken = scanner.tokenize$0();
        if (listener.get$_errorReported())
          return;
        newKeyword = null;
        t1 = firstToken;
        if (J.$eq(t1.get$type(), C.TokenType_hLM) && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_new_false_NEW_19)) {
          newKeyword = firstToken;
          firstToken = firstToken.get$_next();
        }
        t1 = firstToken;
        if (t1.get$type() !== C.TokenType_nrs)
          t1 = t1.get$type() === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
        else
          t1 = true;
        if (t1) {
          secondToken = firstToken.get$_next();
          thirdToken = secondToken.get$_next();
          nextToken = null;
          identifier = null;
          if (secondToken.get$type() === C.TokenType_B6W) {
            t1 = thirdToken;
            if (t1.get$type() !== C.TokenType_nrs)
              t1 = t1.get$type() === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
          } else
            t1 = false;
          if (t1) {
            node = new N.SimpleIdentifier(firstToken, null, null, null, null, null, null, null);
            node0 = new N.SimpleIdentifier(thirdToken, null, null, null, null, null, null, null);
            identifier0 = new N.PrefixedIdentifier(null, secondToken, null, null, null, null, null);
            node.set$parent(identifier0);
            identifier0._prefix = node;
            node0.set$parent(identifier0);
            identifier0._identifier = node0;
            identifier = identifier0;
            nextToken = thirdToken.get$_next();
          } else {
            identifier = new N.SimpleIdentifier(firstToken, null, null, null, null, null, null, null);
            nextToken = firstToken.get$_next();
          }
          if (nextToken.get$type() !== C.TokenType_EOF_Imi)
            return;
          node = identifier;
          t1 = new N.CommentReference(newKeyword, null, null, null);
          if (node != null)
            node.set$parent(t1);
          t1._identifier = node;
          return t1;
        } else {
          t1 = firstToken;
          if (!(J.$eq(t1.get$type(), C.TokenType_hLM) && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_this_false_THIS_25))) {
            t1 = firstToken;
            if (!(J.$eq(t1.get$type(), C.TokenType_hLM) && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_null_false_NULL_20))) {
              t1 = firstToken;
              if (!(J.$eq(t1.get$type(), C.TokenType_hLM) && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_true_false_TRUE_27))) {
                t1 = firstToken;
                t1 = J.$eq(t1.get$type(), C.TokenType_hLM) && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_false_false_FALSE_12);
              } else
                t1 = true;
            } else
              t1 = true;
          } else
            t1 = true;
          if (t1)
            return;
        }
      } catch (exception) {
        H.unwrapException(exception);
      }

      return;
    },
    _parseCommentReferences$1: function(tokens) {
      var references, t1, token, comment, $length, codeBlockRanges, leftIndex, range, nameOffset, rightIndex, rightIndex0, firstChar, reference, charAfterLeft, t2, $name, nameToken, node;
      references = H.setRuntimeTypeInfo([], [N.CommentReference]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(tokens, tokens.length, 0, null), [H.getTypeArgumentByIndex(tokens, 0)]); t1.moveNext$0();) {
        token = t1._current;
        comment = token.get$lexeme();
        $length = comment.length;
        codeBlockRanges = this._getCodeBlockRanges$1(comment);
        leftIndex = J.getInterceptor$as(comment).indexOf$1(comment, "[");
        while (true) {
          if (!(leftIndex >= 0 && leftIndex + 1 < $length))
            break;
          range = this._findRange$2(codeBlockRanges, leftIndex);
          if (range == null) {
            nameOffset = token.get$offset() + leftIndex + 1;
            rightIndex = L.JavaString_indexOf(comment, "]", leftIndex);
            rightIndex0 = leftIndex + 1;
            if (rightIndex >= 0) {
              if (rightIndex0 < 0)
                H.throwExpression(P.RangeError$value(rightIndex0));
              if (rightIndex0 >= $length)
                H.throwExpression(P.RangeError$value(rightIndex0));
              firstChar = comment.charCodeAt(rightIndex0);
              if (firstChar !== 39 && firstChar !== 34)
                if (this._isLinkText$2(comment, rightIndex))
                  ;
                else {
                  reference = this._parseCommentReference$2(C.JSString_methods.substring$2(comment, rightIndex0, rightIndex), nameOffset);
                  if (reference != null)
                    references.push(reference);
                }
            } else {
              if (rightIndex0 < 0)
                H.throwExpression(P.RangeError$value(rightIndex0));
              if (rightIndex0 >= $length)
                H.throwExpression(P.RangeError$value(rightIndex0));
              charAfterLeft = comment.charCodeAt(rightIndex0);
              if (!(charAfterLeft >= 65 && charAfterLeft <= 90))
                t2 = charAfterLeft >= 97 && charAfterLeft <= 122;
              else
                t2 = true;
              if (!t2)
                t2 = charAfterLeft >= 48 && charAfterLeft <= 57;
              else
                t2 = true;
              if (t2) {
                $name = C.JSString_methods.substring$2(comment, rightIndex0, X.StringUtilities_indexOfFirstNotLetterDigit(comment, rightIndex0));
                nameToken = new K.StringToken(null, C.TokenType_nrs, 0, null, null);
                nameToken.offset = nameOffset;
                $.get$StringUtilities_INTERNER().toString;
                nameToken._value = $name;
                node = new N.SimpleIdentifier(nameToken, null, null, null, null, null, null, null);
                t2 = new N.CommentReference(null, null, null, null);
                node.set$parent(t2);
                t2._identifier = node;
                references.push(t2);
              } else {
                nameToken = new K.SyntheticStringToken(null, C.TokenType_nrs, 0, null, null);
                nameToken.offset = nameOffset;
                $.get$StringUtilities_INTERNER().toString;
                nameToken._value = "";
                node = new N.SimpleIdentifier(nameToken, null, null, null, null, null, null, null);
                t2 = new N.CommentReference(null, null, null, null);
                node.set$parent(t2);
                t2._identifier = node;
                references.push(t2);
              }
              rightIndex = rightIndex0;
            }
            leftIndex = L.JavaString_indexOf(comment, "[", rightIndex);
          } else
            leftIndex = L.JavaString_indexOf(comment, "[", range[1] + 1);
        }
      }
      return references;
    },
    _parseCompilationUnitMember$1: function(commentAndMetadata) {
      var modifiers, t1, returnType, t2, node, t3, node0, node1, node2, node3, node4, t4, keyword, variables, semicolon, semicolon0, previous;
      modifiers = this._parseModifiers$0();
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_class_false_CLASS_4)) {
        this._validateModifiersForTopLevelDeclaration$1(modifiers);
        t1 = modifiers.constKeyword;
        if (t1 != null)
          this._reportErrorForToken$3(C.ParserErrorCode_eWW, t1, []);
        t1 = modifiers.externalKeyword;
        if (t1 != null)
          this._reportErrorForToken$3(C.ParserErrorCode_UV6, t1, []);
        t1 = modifiers.finalKeyword;
        if (t1 != null)
          this._reportErrorForToken$3(C.ParserErrorCode_I1c, t1, []);
        t1 = modifiers.varKeyword;
        if (t1 != null)
          this._reportErrorForToken$3(C.ParserErrorCode_8Gl, t1, []);
        return this._parseClassDeclaration$2(commentAndMetadata, modifiers.abstractKeyword);
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_typedef_true_TYPEDEF_48)) {
          t1 = this._currentToken._next.type;
          t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ && t1 !== C.TokenType_MD7;
        } else
          t1 = false;
        if (t1) {
          this._validateModifiersForTopLevelDeclaration$1(modifiers);
          t1 = modifiers.abstractKeyword;
          if (t1 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_r76, t1, []);
          t1 = modifiers.constKeyword;
          if (t1 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_ato, t1, []);
          t1 = modifiers.externalKeyword;
          if (t1 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_jMY, t1, []);
          t1 = modifiers.finalKeyword;
          if (t1 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_UW6, t1, []);
          t1 = modifiers.varKeyword;
          if (t1 != null)
            this._reportErrorForToken$3(C.ParserErrorCode_iL9, t1, []);
          return this._parseTypeAlias$1(commentAndMetadata);
        } else {
          if (this._parseEnum) {
            t1 = this._currentToken;
            t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_enum_false_ENUM_10);
          } else
            t1 = false;
          if (t1) {
            this._validateModifiersForTopLevelDeclaration$1(modifiers);
            t1 = modifiers.abstractKeyword;
            if (t1 != null)
              this._reportErrorForToken$3(C.ParserErrorCode_EuH, t1, []);
            t1 = modifiers.constKeyword;
            if (t1 != null)
              this._reportErrorForToken$3(C.ParserErrorCode_8WR, t1, []);
            t1 = modifiers.externalKeyword;
            if (t1 != null)
              this._reportErrorForToken$3(C.ParserErrorCode_O1c, t1, []);
            t1 = modifiers.finalKeyword;
            if (t1 != null)
              this._reportErrorForToken$3(C.ParserErrorCode_ksx, t1, []);
            t1 = modifiers.varKeyword;
            if (t1 != null)
              this._reportErrorForToken$3(C.ParserErrorCode_mBX, t1, []);
            return this._parseEnumDeclaration$1(commentAndMetadata);
          }
        }
      }
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_void_false_VOID_30)) {
        returnType = this.parseReturnType$0();
        t1 = this._currentToken;
        if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))) {
          t1 = this._currentToken;
          t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46);
        } else
          t1 = true;
        if (t1) {
          t1 = this._currentToken._next;
          t2 = t1.type;
          if (t2 !== C.TokenType_nrs)
            t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
          else
            t1 = true;
        } else
          t1 = false;
        if (t1) {
          this._validateModifiersForTopLevelFunction$1(modifiers);
          return this._parseFunctionDeclaration$3(commentAndMetadata, modifiers.externalKeyword, returnType);
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next)) {
            this._reportErrorForToken$3(C.ParserErrorCode_kiY, this._currentToken, []);
            t1 = this._parseOperator$3(commentAndMetadata, modifiers.externalKeyword, returnType);
            node = t1._comment;
            t2 = t1._metadata;
            t3 = t1.externalKeyword;
            node0 = t1._returnType;
            node1 = t1._name;
            node2 = t1._parameters;
            node3 = t1._body;
            node4 = new N.FunctionExpression(null, null, null, null, null, null, null);
            if (node2 != null)
              node2.set$parent(node4);
            node4._parameters = node2;
            if (node3 != null)
              node3.set$parent(node4);
            node4._body = node3;
            t1 = new N.FunctionDeclaration(t3, null, t1.propertyKeyword, null, null, null, null, null, null);
            t3 = N.Annotation;
            t4 = [];
            t4.$builtinTypeInfo = [t3];
            t4 = new N.NodeList(t1, t4);
            t4.$builtinTypeInfo = [t3];
            t1._metadata = t4;
            if (node != null)
              node.set$parent(t1);
            t1._comment = node;
            t1._metadata.addAll$1(0, t2);
            if (node0 != null)
              node0.set$parent(t1);
            t1._returnType = node0;
            if (node1 != null)
              node1.set$parent(t1);
            t1._name = node1;
            node4.set$parent(t1);
            t1._functionExpression = node4;
            return t1;
          } else {
            t1 = this._currentToken;
            t2 = t1.type;
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
            if (t1 && this._currentToken._next.matchesAny$1([C.TokenType_MD7, C.TokenType_qFj, C.TokenType_iJT])) {
              this._validateModifiersForTopLevelFunction$1(modifiers);
              return this._parseFunctionDeclaration$3(commentAndMetadata, modifiers.externalKeyword, returnType);
            } else {
              t1 = this._currentToken;
              t2 = t1.type;
              if (t2 !== C.TokenType_nrs)
                t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
              else
                t1 = true;
              if (t1)
                if (this._currentToken._next.matchesAny$1([C.TokenType_Azp, C.TokenType_s8I, C.TokenType_S8h])) {
                  this._reportError$1(U.AnalysisError$con2(this._source, returnType.get$offset(), returnType.get$length(returnType), C.ParserErrorCode_2Rk, []));
                  node = commentAndMetadata.comment;
                  node0 = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForTopLevelVariable$1(modifiers), null);
                  t1 = new N.TopLevelVariableDeclaration(null, this._expect$1(C.TokenType_S8h), null, null, null, null);
                  t2 = N.Annotation;
                  t3 = [];
                  t3.$builtinTypeInfo = [t2];
                  t3 = new N.NodeList(t1, t3);
                  t3.$builtinTypeInfo = [t2];
                  t1._metadata = t3;
                  if (node != null)
                    node.set$parent(t1);
                  t1._comment = node;
                  t1._metadata.addAll$1(0, commentAndMetadata.metadata);
                  node0.set$parent(t1);
                  t1._variableList = node0;
                  return t1;
                }
              this._reportErrorForToken$3(C.ParserErrorCode_Dn4, this._currentToken, []);
              return;
            }
          }
        }
      } else {
        t1 = this._currentToken;
        if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))) {
          t1 = this._currentToken;
          t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46);
        } else
          t1 = true;
        if (t1) {
          t1 = this._currentToken._next;
          t2 = t1.type;
          if (t2 !== C.TokenType_nrs)
            t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
          else
            t1 = true;
        } else
          t1 = false;
        if (t1) {
          this._validateModifiersForTopLevelFunction$1(modifiers);
          return this._parseFunctionDeclaration$3(commentAndMetadata, modifiers.externalKeyword, null);
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next)) {
            this._reportErrorForToken$3(C.ParserErrorCode_kiY, this._currentToken, []);
            t1 = this._parseOperator$3(commentAndMetadata, modifiers.externalKeyword, null);
            node = t1._comment;
            t2 = t1._metadata;
            t3 = t1.externalKeyword;
            node0 = t1._returnType;
            node1 = t1._name;
            node2 = t1._parameters;
            node3 = t1._body;
            node4 = new N.FunctionExpression(null, null, null, null, null, null, null);
            if (node2 != null)
              node2.set$parent(node4);
            node4._parameters = node2;
            if (node3 != null)
              node3.set$parent(node4);
            node4._body = node3;
            t1 = new N.FunctionDeclaration(t3, null, t1.propertyKeyword, null, null, null, null, null, null);
            t3 = N.Annotation;
            t4 = [];
            t4.$builtinTypeInfo = [t3];
            t4 = new N.NodeList(t1, t4);
            t4.$builtinTypeInfo = [t3];
            t1._metadata = t4;
            if (node != null)
              node.set$parent(t1);
            t1._comment = node;
            t1._metadata.addAll$1(0, t2);
            if (node0 != null)
              node0.set$parent(t1);
            t1._returnType = node0;
            if (node1 != null)
              node1.set$parent(t1);
            t1._name = node1;
            node4.set$parent(t1);
            t1._functionExpression = node4;
            return t1;
          } else {
            t1 = this._currentToken;
            t2 = t1.type;
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
            if (!t1) {
              keyword = modifiers.varKeyword;
              if (keyword == null)
                keyword = modifiers.finalKeyword;
              if (keyword == null)
                keyword = modifiers.constKeyword;
              if (keyword != null) {
                this._reportErrorForToken$3(C.ParserErrorCode_yw2, this._currentToken, []);
                variables = [];
                variables.$builtinTypeInfo = [N.VariableDeclaration];
                node = this._createSyntheticIdentifier$0();
                t1 = new N.VariableDeclaration(null, null, null, null, null, null, null);
                t2 = N.Annotation;
                t3 = [];
                t3.$builtinTypeInfo = [t2];
                t3 = new N.NodeList(t1, t3);
                t3.$builtinTypeInfo = [t2];
                t1._metadata = t3;
                t1._comment = null;
                t3.addAll$1(0, null);
                node.set$parent(t1);
                t1._name = node;
                t1._initializer = null;
                variables.push(t1);
                node = commentAndMetadata.comment;
                node0 = new N.VariableDeclarationList(keyword, null, null, null, null, null, null);
                t1 = N.Annotation;
                t2 = [];
                t2.$builtinTypeInfo = [t1];
                t2 = new N.NodeList(node0, t2);
                t2.$builtinTypeInfo = [t1];
                node0._metadata = t2;
                node0._comment = null;
                t2.addAll$1(0, null);
                t1 = N.VariableDeclaration;
                t2 = [];
                t2.$builtinTypeInfo = [t1];
                t2 = new N.NodeList(node0, t2);
                t2.$builtinTypeInfo = [t1];
                node0._variables = t2;
                node0._type = null;
                t2.addAll$1(0, variables);
                t1 = new N.TopLevelVariableDeclaration(null, this._expectSemicolon$0(), null, null, null, null);
                t2 = N.Annotation;
                t3 = [];
                t3.$builtinTypeInfo = [t2];
                t3 = new N.NodeList(t1, t3);
                t3.$builtinTypeInfo = [t2];
                t1._metadata = t3;
                if (node != null)
                  node.set$parent(t1);
                t1._comment = node;
                t1._metadata.addAll$1(0, commentAndMetadata.metadata);
                node0.set$parent(t1);
                t1._variableList = node0;
                return t1;
              }
              this._reportErrorForToken$3(C.ParserErrorCode_Dn4, this._currentToken, []);
              return;
            } else {
              t1 = this._currentToken._next;
              if (t1.type === C.TokenType_MD7) {
                this._validateModifiersForTopLevelFunction$1(modifiers);
                return this._parseFunctionDeclaration$3(commentAndMetadata, modifiers.externalKeyword, null);
              } else if (t1.matchesAny$1([C.TokenType_Azp, C.TokenType_s8I, C.TokenType_S8h])) {
                if (modifiers.constKeyword == null && modifiers.finalKeyword == null && modifiers.varKeyword == null)
                  this._reportErrorForToken$3(C.ParserErrorCode_sAF, this._currentToken, []);
                node = commentAndMetadata.comment;
                node0 = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForTopLevelVariable$1(modifiers), null);
                t1 = new N.TopLevelVariableDeclaration(null, this._expect$1(C.TokenType_S8h), null, null, null, null);
                t2 = N.Annotation;
                t3 = [];
                t3.$builtinTypeInfo = [t2];
                t3 = new N.NodeList(t1, t3);
                t3.$builtinTypeInfo = [t2];
                t1._metadata = t3;
                if (node != null)
                  node.set$parent(t1);
                t1._comment = node;
                t1._metadata.addAll$1(0, commentAndMetadata.metadata);
                node0.set$parent(t1);
                t1._variableList = node0;
                return t1;
              }
            }
          }
        }
      }
      returnType = this.parseReturnType$0();
      t1 = this._currentToken;
      if (!(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))) {
        t1 = this._currentToken;
        t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_set_true_SET_46);
      } else
        t1 = true;
      if (t1) {
        t1 = this._currentToken._next;
        t2 = t1.type;
        if (t2 !== C.TokenType_nrs)
          t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
        else
          t1 = true;
      } else
        t1 = false;
      if (t1) {
        this._validateModifiersForTopLevelFunction$1(modifiers);
        return this._parseFunctionDeclaration$3(commentAndMetadata, modifiers.externalKeyword, returnType);
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_operator_true_OPERATOR_44) && this._isOperator$1(this._currentToken._next)) {
          this._reportErrorForToken$3(C.ParserErrorCode_kiY, this._currentToken, []);
          t1 = this._parseOperator$3(commentAndMetadata, modifiers.externalKeyword, returnType);
          node = t1._comment;
          t2 = t1._metadata;
          t3 = t1.externalKeyword;
          node0 = t1._returnType;
          node1 = t1._name;
          node2 = t1._parameters;
          node3 = t1._body;
          node4 = new N.FunctionExpression(null, null, null, null, null, null, null);
          if (node2 != null)
            node2.set$parent(node4);
          node4._parameters = node2;
          if (node3 != null)
            node3.set$parent(node4);
          node4._body = node3;
          t1 = new N.FunctionDeclaration(t3, null, t1.propertyKeyword, null, null, null, null, null, null);
          t3 = N.Annotation;
          t4 = [];
          t4.$builtinTypeInfo = [t3];
          t4 = new N.NodeList(t1, t4);
          t4.$builtinTypeInfo = [t3];
          t1._metadata = t4;
          if (node != null)
            node.set$parent(t1);
          t1._comment = node;
          t1._metadata.addAll$1(0, t2);
          if (node0 != null)
            node0.set$parent(t1);
          t1._returnType = node0;
          if (node1 != null)
            node1.set$parent(t1);
          t1._name = node1;
          node4.set$parent(t1);
          t1._functionExpression = node4;
          return t1;
        } else {
          t1 = this._currentToken;
          t2 = t1.type;
          if (t2 === C.TokenType_27D) {
            node = commentAndMetadata.comment;
            node0 = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForTopLevelVariable$1(modifiers), returnType);
            t1 = new N.TopLevelVariableDeclaration(null, this._expect$1(C.TokenType_S8h), null, null, null, null);
            t2 = N.Annotation;
            t3 = [];
            t3.$builtinTypeInfo = [t2];
            t3 = new N.NodeList(t1, t3);
            t3.$builtinTypeInfo = [t2];
            t1._metadata = t3;
            if (node != null)
              node.set$parent(t1);
            t1._comment = node;
            t1._metadata.addAll$1(0, commentAndMetadata.metadata);
            node0.set$parent(t1);
            t1._variableList = node0;
            return t1;
          } else {
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
            if (!t1) {
              this._reportErrorForToken$3(C.ParserErrorCode_Dn4, this._currentToken, []);
              semicolon = this._currentToken;
              if (semicolon.type === C.TokenType_S8h)
                this._currentToken = semicolon._next;
              else {
                semicolon0 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
                semicolon0.offset = semicolon.offset;
                $.get$StringUtilities_INTERNER().toString;
                semicolon0._value = "";
                previous = semicolon.previous;
                semicolon0._next = semicolon;
                semicolon.previous = semicolon0;
                previous._next = semicolon0;
                semicolon0.previous = previous;
                semicolon = semicolon0;
              }
              variables = [];
              variables.$builtinTypeInfo = [N.VariableDeclaration];
              node = this._createSyntheticIdentifier$0();
              t1 = new N.VariableDeclaration(null, null, null, null, null, null, null);
              t2 = N.Annotation;
              t3 = [];
              t3.$builtinTypeInfo = [t2];
              t3 = new N.NodeList(t1, t3);
              t3.$builtinTypeInfo = [t2];
              t1._metadata = t3;
              t1._comment = null;
              t3.addAll$1(0, null);
              node.set$parent(t1);
              t1._name = node;
              t1._initializer = null;
              variables.push(t1);
              node = commentAndMetadata.comment;
              node0 = new N.VariableDeclarationList(null, null, null, null, null, null, null);
              t1 = N.Annotation;
              t2 = [];
              t2.$builtinTypeInfo = [t1];
              t2 = new N.NodeList(node0, t2);
              t2.$builtinTypeInfo = [t1];
              node0._metadata = t2;
              node0._comment = null;
              t2.addAll$1(0, null);
              t1 = N.VariableDeclaration;
              t2 = [];
              t2.$builtinTypeInfo = [t1];
              t2 = new N.NodeList(node0, t2);
              t2.$builtinTypeInfo = [t1];
              node0._variables = t2;
              returnType.set$parent(node0);
              node0._type = returnType;
              node0._variables.addAll$1(0, variables);
              t1 = new N.TopLevelVariableDeclaration(null, semicolon, null, null, null, null);
              t2 = N.Annotation;
              t3 = [];
              t3.$builtinTypeInfo = [t2];
              t3 = new N.NodeList(t1, t3);
              t3.$builtinTypeInfo = [t2];
              t1._metadata = t3;
              if (node != null)
                node.set$parent(t1);
              t1._comment = node;
              t1._metadata.addAll$1(0, commentAndMetadata.metadata);
              node0.set$parent(t1);
              t1._variableList = node0;
              return t1;
            }
          }
        }
      }
      if (this._currentToken._next.matchesAny$1([C.TokenType_MD7, C.TokenType_iJT, C.TokenType_qFj])) {
        this._validateModifiersForTopLevelFunction$1(modifiers);
        return this._parseFunctionDeclaration$3(commentAndMetadata, modifiers.externalKeyword, returnType);
      }
      node = commentAndMetadata.comment;
      node0 = this._parseVariableDeclarationListAfterType$3(null, this._validateModifiersForTopLevelVariable$1(modifiers), returnType);
      t1 = new N.TopLevelVariableDeclaration(null, this._expect$1(C.TokenType_S8h), null, null, null, null);
      t2 = N.Annotation;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._metadata = t3;
      if (node != null)
        node.set$parent(t1);
      t1._comment = node;
      t1._metadata.addAll$1(0, commentAndMetadata.metadata);
      node0.set$parent(t1);
      t1._variableList = node0;
      return t1;
    },
    _parseConstExpression$0: function() {
      var keyword, t1;
      keyword = this._expectKeyword$1(C.Keyword_const_false_CONST_5);
      t1 = this._currentToken.type;
      if (t1 === C.TokenType_AHF || t1 === C.TokenType_WFw)
        return this._parseListLiteral$2(keyword, null);
      else if (t1 === C.TokenType_qFj)
        return this._parseMapLiteral$2(keyword, null);
      else if (t1 === C.TokenType_KoJ)
        return this._parseListOrMapLiteral$1(keyword);
      return this._parseInstanceCreationExpression$1(keyword);
    },
    _parseConstructor$8: function(commentAndMetadata, externalKeyword, constKeyword, factoryKeyword, returnType, period, $name, parameters) {
      var bodyAllowed, separator, initializers, bodyAllowed0, t1, keyword, period0, constructorName, argumentList, separator0, redirectedConstructor, body, t2, t3;
      bodyAllowed = externalKeyword == null;
      separator = this._currentToken;
      if (separator.type === C.TokenType_chs) {
        this._currentToken = separator._next;
        initializers = H.setRuntimeTypeInfo([], [N.ConstructorInitializer]);
        bodyAllowed0 = bodyAllowed;
        do {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_this_false_THIS_25)) {
            t1 = this._currentToken._next.type;
            if (t1 === C.TokenType_MD7) {
              initializers.push(this._parseRedirectingConstructorInvocation$0());
              bodyAllowed0 = false;
            } else if (t1 === C.TokenType_B6W && this._peekAt$1(3).type === C.TokenType_MD7) {
              initializers.push(this._parseRedirectingConstructorInvocation$0());
              bodyAllowed0 = false;
            } else
              initializers.push(this._parseConstructorFieldInitializer$0());
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23)) {
              keyword = this._expectKeyword$1(C.Keyword_super_false_SUPER_23);
              period0 = this._currentToken;
              if (period0.type === C.TokenType_B6W) {
                this._currentToken = period0._next;
                constructorName = this.parseSimpleIdentifier$0();
              } else {
                period0 = null;
                constructorName = null;
              }
              argumentList = this.parseArgumentList$0();
              t1 = new N.SuperConstructorInvocation(keyword, period0, null, null, null, null, null);
              if (constructorName != null)
                constructorName.set$parent(t1);
              t1._constructorName = constructorName;
              if (argumentList != null)
                argumentList.set$parent(t1);
              t1._argumentList = argumentList;
              initializers.push(t1);
            } else
              initializers.push(this._parseConstructorFieldInitializer$0());
          }
        } while (this._optional$1(C.TokenType_s8I));
      } else {
        bodyAllowed0 = bodyAllowed;
        separator = null;
        initializers = null;
      }
      separator0 = this._currentToken;
      if (separator0.type === C.TokenType_Azp) {
        this._currentToken = separator0._next;
        redirectedConstructor = this.parseConstructorName$0();
        body = new N.EmptyFunctionBody(this._expect$1(C.TokenType_S8h), null, null);
        if (factoryKeyword == null)
          this._reportError$1(U.AnalysisError$con2(this._source, redirectedConstructor.get$offset(), redirectedConstructor.get$length(redirectedConstructor), C.ParserErrorCode_quJ, []));
        separator = separator0;
      } else {
        body = this._parseFunctionBody$3(true, C.ParserErrorCode_MQW, false);
        t1 = constKeyword != null;
        if (t1 && factoryKeyword != null && bodyAllowed)
          this._reportErrorForToken$3(C.ParserErrorCode_gf4, factoryKeyword, []);
        else {
          t2 = J.getInterceptor(body);
          if (!!t2.$isEmptyFunctionBody) {
            if (factoryKeyword != null && bodyAllowed)
              this._reportErrorForToken$3(C.ParserErrorCode_gld, factoryKeyword, []);
          } else if (t1)
            this._reportError$1(U.AnalysisError$con2(this._source, body.get$offset(), t2.get$length(body), C.ParserErrorCode_iDZ, []));
          else if (!bodyAllowed0)
            this._reportError$1(U.AnalysisError$con2(this._source, body.get$offset(), t2.get$length(body), C.ParserErrorCode_IRN, []));
        }
        redirectedConstructor = null;
      }
      t1 = commentAndMetadata.comment;
      t2 = commentAndMetadata.metadata;
      t3 = new N.ConstructorDeclaration(externalKeyword, constKeyword, factoryKeyword, null, period, null, null, separator, null, null, null, null, null, null, null, null);
      t3.AnnotatedNode$2(t1, t2);
      t3.ConstructorDeclaration$13(t1, t2, externalKeyword, constKeyword, factoryKeyword, returnType, period, $name, parameters, separator, initializers, redirectedConstructor, body);
      return t3;
    },
    _parseConstructorFieldInitializer$0: function() {
      var keyword, period, fieldName, equals, wasInInitializer, expression, tokenType, cascadeSections, section, t1, token, cascadeSections0, node, expression0, t2, node0;
      keyword = null;
      period = null;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_this_false_THIS_25)) {
        token = this._currentToken;
        this._currentToken = token._next;
        keyword = token;
        period = this._expect$1(C.TokenType_B6W);
      }
      fieldName = this.parseSimpleIdentifier$0();
      equals = this._expect$1(C.TokenType_Azp);
      wasInInitializer = this._inInitializer;
      this._inInitializer = true;
      try {
        expression = this.parseConditionalExpression$0();
        tokenType = this._currentToken.type;
        if (tokenType === C.TokenType_mGg) {
          cascadeSections0 = [];
          cascadeSections0.$builtinTypeInfo = [N.Expression];
          cascadeSections = cascadeSections0;
          for (; tokenType === C.TokenType_mGg;) {
            section = this._parseCascadeSection$0();
            if (section != null)
              J.add$1$a(cascadeSections, section);
            tokenType = this._currentToken.type;
          }
          node = expression;
          expression0 = new N.CascadeExpression(null, null, null, null, null, null);
          t1 = N.Expression;
          t2 = [];
          t2.$builtinTypeInfo = [t1];
          t2 = new N.NodeList(expression0, t2);
          t2.$builtinTypeInfo = [t1];
          expression0._cascadeSections = t2;
          if (node != null)
            node.set$parent(expression0);
          expression0._target = node;
          expression0._cascadeSections.addAll$1(0, cascadeSections);
          expression = expression0;
        }
        node = fieldName;
        node0 = expression;
        t1 = new N.ConstructorFieldInitializer(keyword, period, null, equals, null, null, null);
        if (node != null)
          node.set$parent(t1);
        t1._fieldName = node;
        if (node0 != null)
          node0.set$parent(t1);
        t1._expression = node0;
        return t1;
      } finally {
        this._inInitializer = wasInInitializer;
      }
    },
    _parseDirective$1: function(commentAndMetadata) {
      var t1, importKeyword, libraryUri, token, deferredToken, prefix, asToken, combinators, node, t2, t3, exportKeyword, keyword, libraryName;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_import_true_IMPORT_42)) {
        importKeyword = this._expectKeyword$1(C.Keyword_import_true_IMPORT_42);
        libraryUri = this.parseStringLiteral$0();
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_deferred_true_DEFERRED_35)) {
          token = this._currentToken;
          if (this._parseDeferredLibraries) {
            this._currentToken = token._next;
            deferredToken = token;
          } else {
            this._reportErrorForToken$3(C.ParserErrorCode_YCv, token, []);
            this._currentToken = this._currentToken._next;
            deferredToken = null;
          }
        } else
          deferredToken = null;
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_as_true_AS_34)) {
          token = this._currentToken;
          this._currentToken = token._next;
          prefix = this.parseSimpleIdentifier$0();
          asToken = token;
        } else {
          if (deferredToken != null)
            this._reportErrorForToken$3(C.ParserErrorCode_ECO, this._currentToken, []);
          asToken = null;
          prefix = null;
        }
        combinators = this._parseCombinators$0();
        node = commentAndMetadata.comment;
        t1 = new N.ImportDirective(deferredToken, asToken, null, importKeyword, null, this._expectSemicolon$0(), null, null, null, null, null, null, null, null);
        t2 = N.Annotation;
        t3 = [];
        t3.$builtinTypeInfo = [t2];
        t3 = new N.NodeList(t1, t3);
        t3.$builtinTypeInfo = [t2];
        t1._metadata = t3;
        if (node != null)
          node.set$parent(t1);
        t1._comment = node;
        t1._metadata.addAll$1(0, commentAndMetadata.metadata);
        libraryUri.set$parent(t1);
        t1._uri = libraryUri;
        t2 = N.Combinator;
        t3 = [];
        t3.$builtinTypeInfo = [t2];
        t3 = new N.NodeList(t1, t3);
        t3.$builtinTypeInfo = [t2];
        t1._combinators = t3;
        t3.addAll$1(0, combinators);
        if (prefix != null)
          prefix.set$parent(t1);
        t1._prefix = prefix;
        return t1;
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_export_true_EXPORT_37)) {
          exportKeyword = this._expectKeyword$1(C.Keyword_export_true_EXPORT_37);
          libraryUri = this.parseStringLiteral$0();
          combinators = this._parseCombinators$0();
          node = commentAndMetadata.comment;
          t1 = new N.ExportDirective(exportKeyword, null, this._expectSemicolon$0(), null, null, null, null, null, null, null, null);
          t2 = N.Annotation;
          t3 = [];
          t3.$builtinTypeInfo = [t2];
          t3 = new N.NodeList(t1, t3);
          t3.$builtinTypeInfo = [t2];
          t1._metadata = t3;
          if (node != null)
            node.set$parent(t1);
          t1._comment = node;
          t1._metadata.addAll$1(0, commentAndMetadata.metadata);
          libraryUri.set$parent(t1);
          t1._uri = libraryUri;
          t2 = N.Combinator;
          t3 = [];
          t3.$builtinTypeInfo = [t2];
          t3 = new N.NodeList(t1, t3);
          t3.$builtinTypeInfo = [t2];
          t1._combinators = t3;
          t3.addAll$1(0, combinators);
          return t1;
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_library_true_LIBRARY_43)) {
            keyword = this._expectKeyword$1(C.Keyword_library_true_LIBRARY_43);
            libraryName = this._parseLibraryName$2(C.ParserErrorCode_o0y, keyword);
            node = commentAndMetadata.comment;
            t1 = new N.LibraryDirective(keyword, null, this._expect$1(C.TokenType_S8h), null, null, null, null, null);
            t2 = N.Annotation;
            t3 = [];
            t3.$builtinTypeInfo = [t2];
            t3 = new N.NodeList(t1, t3);
            t3.$builtinTypeInfo = [t2];
            t1._metadata = t3;
            if (node != null)
              node.set$parent(t1);
            t1._comment = node;
            t1._metadata.addAll$1(0, commentAndMetadata.metadata);
            libraryName.set$parent(t1);
            t1._name = libraryName;
            return t1;
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_part_true_PART_45))
              return this._parsePartDirective$1(commentAndMetadata);
            else
              throw H.wrapException(L.IllegalStateException$("parseDirective invoked in an invalid state; currentToken = " + J.toString$0(this._currentToken)));
          }
        }
      }
    },
    _parseDocumentationComment$0: function() {
      var commentTokens, commentToken, t1, tokens, references, t2, t3;
      commentTokens = [];
      commentTokens.$builtinTypeInfo = [K.Token];
      commentToken = this._currentToken.get$precedingComments();
      for (; commentToken != null;) {
        if (commentToken.type === C.TokenType_Aec) {
          if (X.StringUtilities_startsWith3(commentToken.get$lexeme(), 0, 47, 47, 47)) {
            t1 = commentTokens.length;
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(commentTokens, 0);
              t1 = X.StringUtilities_startsWith3(commentTokens[0].get$lexeme(), 0, 47, 42, 42);
            } else
              t1 = false;
            if (t1)
              C.JSArray_methods.set$length(commentTokens, 0);
            commentTokens.push(commentToken);
          }
        } else if (X.StringUtilities_startsWith3(commentToken.get$lexeme(), 0, 47, 42, 42)) {
          C.JSArray_methods.set$length(commentTokens, 0);
          commentTokens.push(commentToken);
        }
        commentToken = commentToken._next;
      }
      if (commentTokens.length === 0)
        return;
      tokens = P.List_List$from(commentTokens, true, null);
      references = this._parseCommentReferences$1(tokens);
      t1 = new N.Comment(tokens, C.CommentType_DOCUMENTATION_2, null, null, null);
      t2 = N.CommentReference;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._references = t3;
      t3.addAll$1(0, references);
      return t1;
    },
    _parseDoStatement$0: function() {
      var wasInLoop, doKeyword, body, whileKeyword, leftParenthesis, condition, rightParenthesis, semicolon, t1;
      wasInLoop = this._inLoop;
      this._inLoop = true;
      try {
        doKeyword = this._expectKeyword$1(C.Keyword_do_false_DO_8);
        body = this.parseStatement2$0();
        whileKeyword = this._expectKeyword$1(C.Keyword_while_false_WHILE_31);
        leftParenthesis = this._expect$1(C.TokenType_MD7);
        condition = this.parseExpression2$0();
        rightParenthesis = this._expect$1(C.TokenType_kC8);
        semicolon = this._expect$1(C.TokenType_S8h);
        t1 = new N.DoStatement(doKeyword, null, whileKeyword, null, null, null, semicolon, null, null);
        t1._body = t1.becomeParentOf$1(body);
        t1._leftParenthesis = leftParenthesis;
        t1._condition = t1.becomeParentOf$1(condition);
        t1._rightParenthesis = rightParenthesis;
        return t1;
      } finally {
        this._inLoop = wasInLoop;
      }
    },
    _parseEnumConstantDeclaration$0: function() {
      var commentAndMetadata, t1, t2, $name, node, t3;
      commentAndMetadata = this._parseCommentAndMetadata$0();
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 !== C.TokenType_nrs)
        t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
      else
        t1 = true;
      $name = t1 ? this.parseSimpleIdentifier$0() : this._createSyntheticIdentifier$0();
      node = commentAndMetadata.comment;
      t1 = new N.EnumConstantDeclaration(null, null, null, null, null);
      t2 = N.Annotation;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._metadata = t3;
      if (node != null)
        node.set$parent(t1);
      t1._comment = node;
      t1._metadata.addAll$1(0, commentAndMetadata.metadata);
      $name.set$parent(t1);
      t1._name = $name;
      return t1;
    },
    _parseEnumDeclaration$1: function(commentAndMetadata) {
      var keyword, $name, constants, t1, leftBracket, rightBracket, t2, t3;
      keyword = this._expectKeyword$1(C.Keyword_enum_false_ENUM_10);
      $name = this.parseSimpleIdentifier$0();
      constants = H.setRuntimeTypeInfo([], [N.EnumConstantDeclaration]);
      t1 = this._currentToken;
      if (t1.type === C.TokenType_qFj) {
        leftBracket = this._expect$1(C.TokenType_qFj);
        if (this._tokenMatchesIdentifier$1(this._currentToken))
          constants.push(this._parseEnumConstantDeclaration$0());
        else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_s8I && this._tokenMatchesIdentifier$1(t1._next)) {
            constants.push(this._parseEnumConstantDeclaration$0());
            this._reportErrorForToken$3(C.ParserErrorCode_yw2, this._currentToken, []);
          } else {
            constants.push(this._parseEnumConstantDeclaration$0());
            this._reportErrorForToken$3(C.ParserErrorCode_0, this._currentToken, []);
          }
        }
        for (; this._optional$1(C.TokenType_s8I);) {
          if (this._currentToken.type === C.TokenType_33I)
            break;
          constants.push(this._parseEnumConstantDeclaration$0());
        }
        rightBracket = this._expect$1(C.TokenType_33I);
      } else {
        t2 = new K.StringToken(null, C.TokenType_qFj, 0, null, null);
        t2.offset = t1.offset;
        $.get$StringUtilities_INTERNER().toString;
        t2._value = "";
        leftBracket = this._injectToken$1(t2);
        t2 = new K.StringToken(null, C.TokenType_33I, 0, null, null);
        t2.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t2._value = "";
        rightBracket = this._injectToken$1(t2);
        this._reportErrorForToken$3(C.ParserErrorCode_4e8, this._currentToken, []);
      }
      t1 = commentAndMetadata.comment;
      t2 = commentAndMetadata.metadata;
      t3 = new N.EnumDeclaration(keyword, null, leftBracket, null, rightBracket, null, null, null, null);
      t3.AnnotatedNode$2(t1, t2);
      t3.EnumDeclaration$7(t1, t2, keyword, $name, leftBracket, constants, rightBracket);
      return t3;
    },
    _parseEqualityExpression$0: function() {
      var t1, token, expression, leftEqualityExpression, t2, node, expression0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type._tokenClass === C.TokenClass_6_EQUALITY_OPERATOR_8) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseRelationalExpression$0();
      for (t1 = this._source, leftEqualityExpression = false; t2 = this._currentToken, t2.type._tokenClass === C.TokenClass_6_EQUALITY_OPERATOR_8; expression = expression0, leftEqualityExpression = true) {
        this._currentToken = t2._next;
        if (leftEqualityExpression)
          this._reportError$1(U.AnalysisError$con2(t1, expression.get$offset(), J.get$length$as(expression), C.ParserErrorCode_ECL, []));
        node = this._parseRelationalExpression$0();
        expression0 = new N.BinaryExpression(null, t2, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseExpressionList$0: function() {
      var expressions = H.setRuntimeTypeInfo([], [N.Expression]);
      expressions.push(this.parseExpression2$0());
      for (; this._optional$1(C.TokenType_s8I);)
        expressions.push(this.parseExpression2$0());
      return expressions;
    },
    _parseFinalConstVarOrType$1: function(optional) {
      var token, t1, type, keyword;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_final_false_FINAL_13) || this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_const_false_CONST_5)) {
        token = this._currentToken;
        t1 = token._next;
        this._currentToken = t1;
        type = this._isTypedIdentifier$1(t1) ? this.parseTypeName$0() : null;
        keyword = token;
      } else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_var_false_VAR_29)) {
        token = this._currentToken;
        this._currentToken = token._next;
        keyword = token;
        type = null;
      } else {
        if (this._isTypedIdentifier$1(this._currentToken))
          type = this.parseReturnType$0();
        else {
          if (!optional)
            this._reportErrorForToken$3(C.ParserErrorCode_sAF, this._currentToken, []);
          type = null;
        }
        keyword = null;
      }
      return new S.FinalConstVarOrType(keyword, type);
    },
    _parseFormalParameter$1: function(kind) {
      var parameter, t1, t2, defaultValue;
      parameter = this.parseNormalFormalParameter$0();
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_Azp) {
        this._currentToken = t1._next;
        defaultValue = this.parseExpression2$0();
        if (kind === C.ParameterKind_true_NAMED_2)
          this._reportErrorForToken$3(C.ParserErrorCode_H31, t1, []);
        else if (kind === C.ParameterKind_false_REQUIRED_0)
          this._reportError$1(U.AnalysisError$con2(this._source, parameter.get$offset(), parameter.get$length(parameter), C.ParserErrorCode_WTB, []));
        t1 = new N.DefaultFormalParameter(null, kind, t1, null, null, null);
        parameter.set$parent(t1);
        t1._parameter = parameter;
        if (defaultValue != null)
          defaultValue.set$parent(t1);
        t1._defaultValue = defaultValue;
        return t1;
      } else if (t2 === C.TokenType_chs) {
        this._currentToken = t1._next;
        defaultValue = this.parseExpression2$0();
        if (kind === C.ParameterKind_true_POSITIONAL_1)
          this._reportErrorForToken$3(C.ParserErrorCode_PEK, t1, []);
        else if (kind === C.ParameterKind_false_REQUIRED_0)
          this._reportError$1(U.AnalysisError$con2(this._source, parameter.get$offset(), parameter.get$length(parameter), C.ParserErrorCode_GRv, []));
        t1 = new N.DefaultFormalParameter(null, kind, t1, null, null, null);
        parameter.set$parent(t1);
        t1._parameter = parameter;
        if (defaultValue != null)
          defaultValue.set$parent(t1);
        t1._defaultValue = defaultValue;
        return t1;
      } else if (kind !== C.ParameterKind_false_REQUIRED_0) {
        t1 = new N.DefaultFormalParameter(null, kind, null, null, null, null);
        parameter.set$parent(t1);
        t1._parameter = parameter;
        t1._defaultValue = null;
        return t1;
      }
      return parameter;
    },
    _parseForStatement$0: function() {
      var wasInLoop, awaitKeyword, forKeyword, leftParenthesis, variableList, initialization, commentAndMetadata, variables, variableName, loopVariable, identifier, variables0, variable, keyword, type, inKeyword, iterator, rightParenthesis, body, leftSeparator, condition, rightSeparator, updaters, rightParenthesis0, body0, token, t1, t2, t3, loopVariable0, t4, t5, t6;
      wasInLoop = this._inLoop;
      this._inLoop = true;
      try {
        awaitKeyword = null;
        if (this._matchesString$1($.Parser__AWAIT)) {
          token = this._currentToken;
          this._currentToken = token._next;
          awaitKeyword = token;
        }
        forKeyword = this._expectKeyword$1(C.Keyword_for_false_FOR_15);
        leftParenthesis = this._expect$1(C.TokenType_MD7);
        variableList = null;
        initialization = null;
        if (this._currentToken.type !== C.TokenType_S8h) {
          commentAndMetadata = this._parseCommentAndMetadata$0();
          if (this._tokenMatchesIdentifier$1(this._currentToken) && this._tokenMatchesKeyword$2(this._currentToken._next, C.Keyword_in_false_IN_17)) {
            variables = H.setRuntimeTypeInfo([], [N.VariableDeclaration]);
            variableName = this.parseSimpleIdentifier$0();
            t1 = new N.VariableDeclaration(null, null, null, null, null, null, null);
            t1.AnnotatedNode$2(null, null);
            t1._name = t1.becomeParentOf$1(variableName);
            t1._initializer = t1.becomeParentOf$1(null);
            J.add$1$a(variables, t1);
            variableList = N.VariableDeclarationList$(commentAndMetadata.get$comment(), commentAndMetadata.get$metadata(), null, null, variables);
          } else if (this._isInitializedVariableDeclaration$0())
            variableList = this._parseVariableDeclarationListAfterMetadata$1(commentAndMetadata);
          else
            initialization = this.parseExpression2$0();
          if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_in_false_IN_17)) {
            loopVariable = null;
            identifier = null;
            if (variableList == null)
              this._reportErrorForToken$3(C.ParserErrorCode_AbH, this._currentToken, []);
            else {
              variables0 = variableList.get$_variables();
              if (variables0.get$_elements().length > 1) {
                t1 = C.JSInt_methods.toString$0(variables0.get$_elements().length);
                this._reportErrorForToken$3(C.ParserErrorCode_akP, this._currentToken, [t1]);
              }
              variable = J.$index$as(variables0, 0);
              if (variable.get$initializer() != null)
                this._reportErrorForToken$3(C.ParserErrorCode_8Wd0, this._currentToken, []);
              keyword = variableList.get$keyword();
              type = variableList.get$_type();
              if (keyword != null || type != null) {
                t1 = commentAndMetadata.get$comment();
                t2 = commentAndMetadata.get$metadata();
                t3 = variable.get$_name();
                loopVariable0 = new N.DeclaredIdentifier(keyword, null, null, null, null, null, null);
                loopVariable0.AnnotatedNode$2(t1, t2);
                loopVariable0._type = loopVariable0.becomeParentOf$1(type);
                loopVariable0._identifier = loopVariable0.becomeParentOf$1(t3);
                loopVariable = loopVariable0;
              } else {
                if (commentAndMetadata.get$metadata().length !== 0)
                  ;
                identifier = variable.get$_name();
              }
            }
            inKeyword = this._expectKeyword$1(C.Keyword_in_false_IN_17);
            iterator = this.parseExpression2$0();
            rightParenthesis = this._expect$1(C.TokenType_kC8);
            body = this.parseStatement2$0();
            if (loopVariable == null) {
              t1 = new N.ForEachStatement(awaitKeyword, forKeyword, leftParenthesis, null, null, inKeyword, null, rightParenthesis, null, null, null);
              t1._identifier = t1.becomeParentOf$1(identifier);
              t1._iterator = t1.becomeParentOf$1(iterator);
              t1._body = t1.becomeParentOf$1(body);
              return t1;
            }
            t1 = new N.ForEachStatement(awaitKeyword, forKeyword, leftParenthesis, null, null, inKeyword, null, rightParenthesis, null, null, null);
            t1._loopVariable = t1.becomeParentOf$1(loopVariable);
            t1._iterator = t1.becomeParentOf$1(iterator);
            t1._body = t1.becomeParentOf$1(body);
            return t1;
          }
        }
        if (awaitKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_H9g, awaitKeyword, []);
        leftSeparator = this._expect$1(C.TokenType_S8h);
        condition = null;
        if (this._currentToken.type !== C.TokenType_S8h)
          condition = this.parseExpression2$0();
        rightSeparator = this._expect$1(C.TokenType_S8h);
        updaters = null;
        if (this._currentToken.type !== C.TokenType_kC8)
          updaters = this._parseExpressionList$0();
        rightParenthesis0 = this._expect$1(C.TokenType_kC8);
        body0 = this.parseStatement2$0();
        t1 = forKeyword;
        t2 = leftParenthesis;
        t3 = leftSeparator;
        t4 = rightSeparator;
        t5 = rightParenthesis0;
        t6 = new N.ForStatement(t1, t2, null, null, t3, null, t4, null, t5, null, null, null);
        t6.ForStatement$10(t1, t2, variableList, initialization, t3, condition, t4, updaters, t5, body0);
        return t6;
      } finally {
        this._inLoop = wasInLoop;
      }
    },
    _parseFunctionBody$3: function(mayBeEmpty, emptyErrorCode, inExpression) {
      var wasInAsync, wasInGenerator, wasInLoop, wasInSwitch, nativeToken, stringLiteral, keyword, star, functionDefinition, expression, semicolon, t1, token, t2;
      wasInAsync = this._inAsync;
      wasInGenerator = this._inGenerator;
      wasInLoop = this._inLoop;
      wasInSwitch = this._inSwitch;
      this._inAsync = false;
      this._inGenerator = false;
      this._inLoop = false;
      this._inSwitch = false;
      try {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_S8h) {
          if (mayBeEmpty !== true)
            this._reportErrorForToken$3(emptyErrorCode, t1, []);
          token = this._currentToken;
          this._currentToken = token._next;
          return new N.EmptyFunctionBody(token, null, null);
        } else if (this._matchesString$1($.Parser__NATIVE)) {
          token = this._currentToken;
          t1 = token._next;
          this._currentToken = t1;
          nativeToken = token;
          stringLiteral = null;
          if (t1.type === C.TokenType_iDZ)
            stringLiteral = this.parseStringLiteral$0();
          t1 = new N.NativeFunctionBody(nativeToken, null, this._expect$1(C.TokenType_S8h), null, null);
          t1._stringLiteral = t1.becomeParentOf$1(stringLiteral);
          return t1;
        }
        keyword = null;
        star = null;
        if (this._parseAsync)
          if (this._matchesString$1($.Parser_ASYNC)) {
            token = this._currentToken;
            t1 = token._next;
            this._currentToken = t1;
            keyword = token;
            if (t1.type === C.TokenType_ph7) {
              this._currentToken = t1._next;
              star = t1;
              this._inGenerator = true;
            }
            this._inAsync = true;
          } else if (this._matchesString$1($.Parser_SYNC)) {
            token = this._currentToken;
            t1 = token._next;
            this._currentToken = t1;
            keyword = token;
            if (t1.type === C.TokenType_ph7) {
              this._currentToken = t1._next;
              star = t1;
              this._inGenerator = true;
            }
          }
        t1 = this._currentToken;
        t2 = t1.type;
        if (t2 === C.TokenType_iJT) {
          if (keyword != null) {
            t1 = keyword;
            t2 = $.Parser_ASYNC;
            if (!(t1.get$type() === C.TokenType_nrs && t1.get$lexeme() === t2)) {
              this._reportErrorForToken$3(C.ParserErrorCode_IkF, keyword, []);
              keyword = null;
            } else if (star != null)
              this._reportErrorForToken$3(C.ParserErrorCode_ACQ, star, []);
          }
          token = this._currentToken;
          this._currentToken = token._next;
          functionDefinition = token;
          expression = this.parseExpression2$0();
          semicolon = null;
          if (inExpression !== true)
            semicolon = this._expect$1(C.TokenType_S8h);
          if (!this._parseFunctionBodies) {
            t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
            t1.offset = this._currentToken.offset;
            $.get$StringUtilities_INTERNER().toString;
            t1._value = "";
            t1 = this._injectToken$1(t1);
            return new N.EmptyFunctionBody(t1, null, null);
          }
          t1 = new N.ExpressionFunctionBody(keyword, functionDefinition, null, semicolon, null, null);
          t1._expression = t1.becomeParentOf$1(expression);
          return t1;
        } else if (t2 === C.TokenType_qFj) {
          if (keyword != null) {
            t1 = keyword;
            t2 = $.Parser_SYNC;
            if (t1.get$type() === C.TokenType_nrs && t1.get$lexeme() === t2 && star == null)
              this._reportErrorForToken$3(C.ParserErrorCode_MEg, keyword, []);
          }
          if (!this._parseFunctionBodies) {
            this._skipBlock$0();
            t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
            t1.offset = this._currentToken.offset;
            $.get$StringUtilities_INTERNER().toString;
            t1._value = "";
            t1 = this._injectToken$1(t1);
            return new N.EmptyFunctionBody(t1, null, null);
          }
          t1 = new N.BlockFunctionBody(keyword, star, null, null, null);
          t1._block = t1.becomeParentOf$1(this.parseBlock$0());
          return t1;
        } else {
          this._reportErrorForToken$3(emptyErrorCode, t1, []);
          t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
          t1.offset = this._currentToken.offset;
          $.get$StringUtilities_INTERNER().toString;
          t1._value = "";
          t1 = this._injectToken$1(t1);
          return new N.EmptyFunctionBody(t1, null, null);
        }
      } finally {
        this._inAsync = wasInAsync;
        this._inGenerator = wasInGenerator;
        this._inLoop = wasInLoop;
        this._inSwitch = wasInSwitch;
      }
    },
    _parseFunctionDeclaration$3: function(commentAndMetadata, externalKeyword, returnType) {
      var token, keyword, isGetter, $name, t1, parameters, body;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_get_true_GET_40) && this._currentToken._next.type !== C.TokenType_MD7) {
        token = this._currentToken;
        this._currentToken = token._next;
        keyword = token;
        isGetter = true;
      } else {
        if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_set_true_SET_46) && this._currentToken._next.type !== C.TokenType_MD7) {
          token = this._currentToken;
          this._currentToken = token._next;
          keyword = token;
        } else
          keyword = null;
        isGetter = false;
      }
      $name = this.parseSimpleIdentifier$0();
      if (!isGetter) {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_MD7) {
          parameters = this.parseFormalParameterList$0();
          this._validateFormalParameterList$1(parameters);
        } else {
          this._reportErrorForToken$3(C.ParserErrorCode_sav, t1, []);
          parameters = null;
        }
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_MD7) {
          this._reportErrorForToken$3(C.ParserErrorCode_sav0, t1, []);
          this.parseFormalParameterList$0();
        }
        parameters = null;
      }
      body = externalKeyword == null ? this._parseFunctionBody$3(false, C.ParserErrorCode_MQW, false) : new N.EmptyFunctionBody(this._expect$1(C.TokenType_S8h), null, null);
      t1 = new N.FunctionExpression(null, null, null, null, null, null, null);
      t1._parameters = t1.becomeParentOf$1(parameters);
      t1._body = t1.becomeParentOf$1(body);
      return N.FunctionDeclaration$(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, returnType, keyword, $name, t1);
    },
    _parseFunctionDeclarationStatementAfterReturnType$2: function(commentAndMetadata, returnType) {
      var declaration, propertyKeyword, t1;
      declaration = this._parseFunctionDeclaration$3(commentAndMetadata, null, returnType);
      propertyKeyword = declaration.propertyKeyword;
      if (propertyKeyword != null)
        if (J.$eq(H.interceptedTypeCast(propertyKeyword, "$isKeywordToken").keyword, C.Keyword_get_true_GET_40))
          this._reportErrorForToken$3(C.ParserErrorCode_cfF, propertyKeyword, []);
        else
          this._reportErrorForToken$3(C.ParserErrorCode_TlH, propertyKeyword, []);
      t1 = new N.FunctionDeclarationStatement(null, null, null);
      t1._functionDeclaration = t1.becomeParentOf$1(declaration);
      return t1;
    },
    _parseFunctionTypeAlias$2: function(commentAndMetadata, keyword) {
      var returnType, $name, typeParameters, t1, t2, parameters;
      returnType = this.get$hasReturnTypeInTypeAlias() ? this.parseReturnType$0() : null;
      $name = this.parseSimpleIdentifier$0();
      typeParameters = this._currentToken.type === C.TokenType_KoJ ? this.parseTypeParameterList$0() : null;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_S8h || t2 === C.TokenType_EOF_Imi) {
        this._reportErrorForToken$3(C.ParserErrorCode_aZ8, t1, []);
        t1 = new K.StringToken(null, C.TokenType_MD7, 0, null, null);
        t1.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = "";
        t1 = this._injectToken$1(t1);
        t2 = new K.StringToken(null, C.TokenType_kC8, 0, null, null);
        t2.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t2._value = "";
        return N.FunctionTypeAlias$(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, returnType, $name, typeParameters, N.FormalParameterList$(t1, null, null, null, this._injectToken$1(t2)), this._expect$1(C.TokenType_S8h));
      } else if (t2 !== C.TokenType_MD7) {
        this._reportErrorForToken$3(C.ParserErrorCode_aZ8, t1, []);
        t1 = new K.StringToken(null, C.TokenType_MD7, 0, null, null);
        t1.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = "";
        t1 = this._injectToken$1(t1);
        t2 = new K.StringToken(null, C.TokenType_kC8, 0, null, null);
        t2.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t2._value = "";
        t2 = N.FormalParameterList$(t1, null, null, null, this._injectToken$1(t2));
        t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
        t1.offset = this._currentToken.offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = "";
        return N.FunctionTypeAlias$(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, returnType, $name, typeParameters, t2, this._injectToken$1(t1));
      }
      parameters = this.parseFormalParameterList$0();
      this._validateFormalParameterList$1(parameters);
      return N.FunctionTypeAlias$(commentAndMetadata.comment, commentAndMetadata.metadata, keyword, returnType, $name, typeParameters, parameters, this._expect$1(C.TokenType_S8h));
    },
    _parseGetter$4: function(commentAndMetadata, externalKeyword, staticKeyword, returnType) {
      var propertyKeyword, $name, t1, body;
      propertyKeyword = this._expectKeyword$1(C.Keyword_get_true_GET_40);
      $name = this.parseSimpleIdentifier$0();
      t1 = this._currentToken;
      if (t1.type === C.TokenType_MD7 && t1._next.type === C.TokenType_kC8) {
        this._reportErrorForToken$3(C.ParserErrorCode_sav0, t1, []);
        t1 = this._currentToken._next;
        this._currentToken = t1;
        this._currentToken = t1._next;
      }
      t1 = externalKeyword == null;
      body = this._parseFunctionBody$3(!t1 || staticKeyword == null, C.ParserErrorCode_8Gy, false);
      if (!t1 && !J.getInterceptor(body).$isEmptyFunctionBody)
        this._reportErrorForToken$3(C.ParserErrorCode_Q2X0, this._currentToken, []);
      return N.MethodDeclaration$(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, staticKeyword, returnType, propertyKeyword, null, $name, null, body);
    },
    _parseIdentifierList$0: function() {
      var identifiers, t1;
      identifiers = [];
      identifiers.$builtinTypeInfo = [N.SimpleIdentifier];
      identifiers.push(this.parseSimpleIdentifier$0());
      for (; t1 = this._currentToken, t1.type === C.TokenType_s8I;) {
        this._currentToken = t1._next;
        identifiers.push(this.parseSimpleIdentifier$0());
      }
      return identifiers;
    },
    _parseInstanceCreationExpression$1: function(keyword) {
      var constructorName, argumentList, t1;
      constructorName = this.parseConstructorName$0();
      argumentList = this.parseArgumentList$0();
      t1 = new N.InstanceCreationExpression(keyword, null, null, null, null, null, null, null, null);
      t1._constructorName = t1.becomeParentOf$1(constructorName);
      t1._argumentList = t1.becomeParentOf$1(argumentList);
      return t1;
    },
    _parseLibraryName$2: function(missingNameError, missingNameToken) {
      var string, components;
      if (this._tokenMatchesIdentifier$1(this._currentToken))
        return this.parseLibraryIdentifier$0();
      else if (this._currentToken.type === C.TokenType_iDZ) {
        string = this.parseStringLiteral$0();
        this._reportError$1(U.AnalysisError$con2(this._source, string.get$offset(), string.get$length(string), C.ParserErrorCode_MUw0, []));
      } else
        this._reportErrorForToken$3(missingNameError, missingNameToken, []);
      components = H.setRuntimeTypeInfo([], [N.SimpleIdentifier]);
      components.push(this._createSyntheticIdentifier$0());
      return N.LibraryIdentifier$(components);
    },
    _parseListLiteral$2: function(modifier, typeArguments) {
      var leftBracket, wasInInitializer, elements, rightBracket, t1, t2, node, t3, t4;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_WFw) {
        leftBracket = K.BeginToken$(C.TokenType_AHF, t1.offset);
        t1 = this._currentToken;
        rightBracket = new K.Token(C.TokenType_58K, 0, null, null);
        rightBracket.offset = t1.offset + 1;
        leftBracket.endToken = rightBracket;
        t2 = t1._next;
        rightBracket._next = t2;
        t2.previous = rightBracket;
        leftBracket._next = rightBracket;
        rightBracket.previous = leftBracket;
        t2 = t1.previous;
        t2._next = leftBracket;
        leftBracket.previous = t2;
        this._currentToken = t1._next;
        return N.ListLiteral$(modifier, typeArguments, leftBracket, null, rightBracket);
      }
      leftBracket = this._expect$1(C.TokenType_AHF);
      t1 = this._currentToken;
      if (t1.type === C.TokenType_58K) {
        this._currentToken = t1._next;
        return N.ListLiteral$(modifier, typeArguments, leftBracket, null, t1);
      }
      wasInInitializer = this._inInitializer;
      this._inInitializer = false;
      try {
        elements = H.setRuntimeTypeInfo([], [N.Expression]);
        J.add$1$a(elements, this.parseExpression2$0());
        for (; this._optional$1(C.TokenType_s8I);) {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_58K) {
            node = typeArguments;
            this._currentToken = t1._next;
            t2 = new N.ListLiteral(null, null, null, modifier, null, null, null, null, null);
            if (node != null)
              node.set$parent(t2);
            t2._typeArguments = node;
            t3 = N.Expression;
            t4 = [];
            t4.$builtinTypeInfo = [t3];
            t4 = new N.NodeList(t2, t4);
            t4.$builtinTypeInfo = [t3];
            t2._elements = t4;
            t2._leftBracket = leftBracket;
            t4.addAll$1(0, elements);
            t2._rightBracket = t1;
            return t2;
          }
          J.add$1$a(elements, this.parseExpression2$0());
        }
        rightBracket = this._expect$1(C.TokenType_58K);
        t1 = N.ListLiteral$(modifier, typeArguments, leftBracket, elements, rightBracket);
        return t1;
      } finally {
        this._inInitializer = wasInInitializer;
      }
    },
    _parseListOrMapLiteral$1: function(modifier) {
      var typeArguments, t1, t2;
      typeArguments = this._currentToken.type === C.TokenType_KoJ ? this.parseTypeArgumentList$0() : null;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_qFj)
        return this._parseMapLiteral$2(modifier, typeArguments);
      else if (t2 === C.TokenType_AHF || t2 === C.TokenType_WFw)
        return this._parseListLiteral$2(modifier, typeArguments);
      this._reportErrorForToken$3(C.ParserErrorCode_7FR, t1, []);
      t1 = new K.StringToken(null, C.TokenType_AHF, 0, null, null);
      t1.offset = this._currentToken.offset;
      $.get$StringUtilities_INTERNER().toString;
      t1._value = "";
      t1 = this._injectToken$1(t1);
      t2 = new K.StringToken(null, C.TokenType_58K, 0, null, null);
      t2.offset = this._currentToken.offset;
      $.get$StringUtilities_INTERNER().toString;
      t2._value = "";
      return N.ListLiteral$(modifier, typeArguments, t1, null, this._injectToken$1(t2));
    },
    _parseLogicalAndExpression$0: function() {
      var expression, t1, node, expression0;
      expression = this._parseEqualityExpression$0();
      for (; t1 = this._currentToken, t1.type === C.TokenType_qbp; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseEqualityExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseMapLiteral$2: function(modifier, typeArguments) {
      var leftBracket, entries, wasInInitializer, rightBracket, t1, node, t2, t3, t4;
      leftBracket = this._expect$1(C.TokenType_qFj);
      entries = H.setRuntimeTypeInfo([], [N.MapLiteralEntry]);
      t1 = this._currentToken;
      if (t1.type === C.TokenType_33I) {
        this._currentToken = t1._next;
        return N.MapLiteral$(modifier, typeArguments, leftBracket, entries, t1);
      }
      wasInInitializer = this._inInitializer;
      this._inInitializer = false;
      try {
        J.add$1$a(entries, this.parseMapLiteralEntry$0());
        for (; this._optional$1(C.TokenType_s8I);) {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_33I) {
            node = typeArguments;
            this._currentToken = t1._next;
            t2 = new N.MapLiteral(null, null, null, modifier, null, null, null, null, null);
            if (node != null)
              node.set$parent(t2);
            t2._typeArguments = node;
            t3 = N.MapLiteralEntry;
            t4 = [];
            t4.$builtinTypeInfo = [t3];
            t4 = new N.NodeList(t2, t4);
            t4.$builtinTypeInfo = [t3];
            t2._entries = t4;
            t2._leftBracket = leftBracket;
            t4.addAll$1(0, entries);
            t2._rightBracket = t1;
            return t2;
          }
          J.add$1$a(entries, this.parseMapLiteralEntry$0());
        }
        rightBracket = this._expect$1(C.TokenType_33I);
        t1 = N.MapLiteral$(modifier, typeArguments, leftBracket, entries, rightBracket);
        return t1;
      } finally {
        this._inInitializer = wasInInitializer;
      }
    },
    _parseMethodDeclarationAfterParameters$6: function(commentAndMetadata, externalKeyword, staticKeyword, returnType, $name, parameters) {
      var t1, body;
      t1 = externalKeyword == null;
      body = this._parseFunctionBody$3(!t1 || staticKeyword == null, C.ParserErrorCode_MQW, false);
      if (!t1) {
        t1 = J.getInterceptor(body);
        if (!t1.$isEmptyFunctionBody)
          this._reportError$1(U.AnalysisError$con2(this._source, body.get$offset(), t1.get$length(body), C.ParserErrorCode_klg, []));
      } else if (staticKeyword != null) {
        t1 = J.getInterceptor(body);
        if (!!t1.$isEmptyFunctionBody)
          this._reportError$1(U.AnalysisError$con2(this._source, body.get$offset(), t1.get$length(body), C.ParserErrorCode_kPR, []));
      }
      return N.MethodDeclaration$(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, staticKeyword, returnType, null, null, $name, parameters, body);
    },
    _parseModifiers$0: function() {
      var modifiers, progress, t1, t2;
      modifiers = new S.Modifiers(null, null, null, null, null, null, null);
      for (progress = true; progress;) {
        t1 = this._currentToken;
        t2 = t1._next.type;
        if (t2 === C.TokenType_B6W || t2 === C.TokenType_KoJ || t2 === C.TokenType_MD7)
          return modifiers;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_abstract_true_ABSTRACT_33)) {
          t1 = modifiers.abstractKeyword;
          t2 = this._currentToken;
          if (t1 != null) {
            t1 = t2.get$lexeme();
            this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
            this._currentToken = this._currentToken._next;
          } else {
            this._currentToken = t2._next;
            modifiers.abstractKeyword = t2;
          }
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_const_false_CONST_5)) {
            t1 = modifiers.constKeyword;
            t2 = this._currentToken;
            if (t1 != null) {
              t1 = t2.get$lexeme();
              this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
              this._currentToken = this._currentToken._next;
            } else {
              this._currentToken = t2._next;
              modifiers.constKeyword = t2;
            }
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_external_true_EXTERNAL_38)) {
              t1 = this._currentToken._next.type;
              t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ;
            } else
              t1 = false;
            if (t1) {
              t1 = modifiers.externalKeyword;
              t2 = this._currentToken;
              if (t1 != null) {
                t1 = t2.get$lexeme();
                this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
                this._currentToken = this._currentToken._next;
              } else {
                this._currentToken = t2._next;
                modifiers.externalKeyword = t2;
              }
            } else {
              t1 = this._currentToken;
              if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_factory_true_FACTORY_39)) {
                t1 = this._currentToken._next.type;
                t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ;
              } else
                t1 = false;
              if (t1) {
                t1 = modifiers.factoryKeyword;
                t2 = this._currentToken;
                if (t1 != null) {
                  t1 = t2.get$lexeme();
                  this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
                  this._currentToken = this._currentToken._next;
                } else {
                  this._currentToken = t2._next;
                  modifiers.factoryKeyword = t2;
                }
              } else {
                t1 = this._currentToken;
                if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_final_false_FINAL_13)) {
                  t1 = modifiers.finalKeyword;
                  t2 = this._currentToken;
                  if (t1 != null) {
                    t1 = t2.get$lexeme();
                    this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
                    this._currentToken = this._currentToken._next;
                  } else {
                    this._currentToken = t2._next;
                    modifiers.finalKeyword = t2;
                  }
                } else {
                  t1 = this._currentToken;
                  if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_static_true_STATIC_47)) {
                    t1 = this._currentToken._next.type;
                    t1 = t1 !== C.TokenType_B6W && t1 !== C.TokenType_KoJ;
                  } else
                    t1 = false;
                  if (t1) {
                    t1 = modifiers.staticKeyword;
                    t2 = this._currentToken;
                    if (t1 != null) {
                      t1 = t2.get$lexeme();
                      this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
                      this._currentToken = this._currentToken._next;
                    } else {
                      this._currentToken = t2._next;
                      modifiers.staticKeyword = t2;
                    }
                  } else {
                    t1 = this._currentToken;
                    if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_var_false_VAR_29)) {
                      t1 = modifiers.varKeyword;
                      t2 = this._currentToken;
                      if (t1 != null) {
                        t1 = t2.get$lexeme();
                        this._reportErrorForToken$3(C.ParserErrorCode_KQI, this._currentToken, [t1]);
                        this._currentToken = this._currentToken._next;
                      } else {
                        this._currentToken = t2._next;
                        modifiers.varKeyword = t2;
                      }
                    } else
                      progress = false;
                  }
                }
              }
            }
          }
        }
      }
      return modifiers;
    },
    _parseMultiplicativeExpression$0: function() {
      var t1, token, expression, node, expression0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type._tokenClass === C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseUnaryExpression$0();
      for (; t1 = this._currentToken, t1.type._tokenClass === C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseUnaryExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseNonLabeledStatement$0: function() {
      var commentAndMetadata, t1, t2, afterString, keyword, leftParen, expression, breakKeyword, label, continueKeyword, ifKeyword, leftParenthesis, condition, rightParenthesis, thenStatement, token, elseStatement, elseKeyword, returnType, variableList, afterType, star, awaitToken, statement, modifiers;
      commentAndMetadata = this._parseCommentAndMetadata$0();
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_qFj) {
        t1 = t1._next;
        if (t1.type === C.TokenType_iDZ) {
          afterString = this._skipStringLiteral$1(t1);
          if (afterString != null && afterString.type === C.TokenType_chs) {
            t1 = this.parseExpression2$0();
            t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
            t2._expression = t2.becomeParentOf$1(t1);
            return t2;
          }
        }
        return this.parseBlock$0();
      } else if (t2 === C.TokenType_hLM && !H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword()) {
        keyword = H.interceptedTypeCast(this._currentToken, "$isKeywordToken").keyword;
        t1 = J.getInterceptor(keyword);
        if (t1.$eq(keyword, C.Keyword_assert_false_ASSERT_0)) {
          keyword = this._expectKeyword$1(C.Keyword_assert_false_ASSERT_0);
          leftParen = this._expect$1(C.TokenType_MD7);
          expression = this.parseExpression2$0();
          t1 = J.getInterceptor(expression);
          if (!!t1.$isAssignmentExpression)
            this._reportError$1(U.AnalysisError$con2(this._source, expression.get$offset(), t1.get$length(expression), C.ParserErrorCode_kSZ, []));
          else if (!!t1.$isCascadeExpression)
            this._reportError$1(U.AnalysisError$con2(this._source, expression.get$offset(), t1.get$length(expression), C.ParserErrorCode_8Wd, []));
          else if (!!t1.$isThrowExpression)
            this._reportError$1(U.AnalysisError$con2(this._source, expression.get$offset(), t1.get$length(expression), C.ParserErrorCode_Z3F, []));
          else if (!!t1.$isRethrowExpression)
            this._reportError$1(U.AnalysisError$con2(this._source, expression.get$offset(), t1.get$length(expression), C.ParserErrorCode_gWj, []));
          t1 = new N.AssertStatement(keyword, leftParen, null, this._expect$1(C.TokenType_kC8), this._expect$1(C.TokenType_S8h), null, null);
          t1._condition = t1.becomeParentOf$1(expression);
          return t1;
        } else if (t1.$eq(keyword, C.Keyword_break_false_BREAK_1)) {
          breakKeyword = this._expectKeyword$1(C.Keyword_break_false_BREAK_1);
          label = this._tokenMatchesIdentifier$1(this._currentToken) ? this.parseSimpleIdentifier$0() : null;
          if (!this._inLoop && !this._inSwitch && label == null)
            this._reportErrorForToken$3(C.ParserErrorCode_SFe, breakKeyword, []);
          t1 = new N.BreakStatement(breakKeyword, null, this._expect$1(C.TokenType_S8h), null, null);
          t1._label = t1.becomeParentOf$1(label);
          return t1;
        } else if (t1.$eq(keyword, C.Keyword_continue_false_CONTINUE_6)) {
          continueKeyword = this._expectKeyword$1(C.Keyword_continue_false_CONTINUE_6);
          if (!this._inLoop && !this._inSwitch)
            this._reportErrorForToken$3(C.ParserErrorCode_4AN, continueKeyword, []);
          label = this._tokenMatchesIdentifier$1(this._currentToken) ? this.parseSimpleIdentifier$0() : null;
          if (this._inSwitch && !this._inLoop && label == null)
            this._reportErrorForToken$3(C.ParserErrorCode_bzA, continueKeyword, []);
          t1 = new N.ContinueStatement(continueKeyword, null, this._expect$1(C.TokenType_S8h), null, null);
          t1._label = t1.becomeParentOf$1(label);
          return t1;
        } else if (t1.$eq(keyword, C.Keyword_do_false_DO_8))
          return this._parseDoStatement$0();
        else if (t1.$eq(keyword, C.Keyword_for_false_FOR_15))
          return this._parseForStatement$0();
        else if (t1.$eq(keyword, C.Keyword_if_false_IF_16)) {
          ifKeyword = this._expectKeyword$1(C.Keyword_if_false_IF_16);
          leftParenthesis = this._expect$1(C.TokenType_MD7);
          condition = this.parseExpression2$0();
          rightParenthesis = this._expect$1(C.TokenType_kC8);
          thenStatement = this.parseStatement2$0();
          if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_else_false_ELSE_9)) {
            token = this._currentToken;
            this._currentToken = token._next;
            elseStatement = this.parseStatement2$0();
            elseKeyword = token;
          } else {
            elseKeyword = null;
            elseStatement = null;
          }
          t1 = new N.IfStatement(ifKeyword, leftParenthesis, null, rightParenthesis, null, elseKeyword, null, null, null);
          t1._condition = t1.becomeParentOf$1(condition);
          t1._thenStatement = t1.becomeParentOf$1(thenStatement);
          t1._elseStatement = t1.becomeParentOf$1(elseStatement);
          return t1;
        } else if (t1.$eq(keyword, C.Keyword_rethrow_false_RETHROW_21)) {
          t1 = this._expectKeyword$1(C.Keyword_rethrow_false_RETHROW_21);
          t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
          t2._expression = t2.becomeParentOf$1(new N.RethrowExpression(t1, null, null, null, null));
          return t2;
        } else if (t1.$eq(keyword, C.Keyword_return_false_RETURN_22))
          return this._parseReturnStatement$0();
        else if (t1.$eq(keyword, C.Keyword_switch_false_SWITCH_24))
          return this._parseSwitchStatement$0();
        else if (t1.$eq(keyword, C.Keyword_throw_false_THROW_26)) {
          t1 = this._parseThrowExpression$0();
          t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
          t2._expression = t2.becomeParentOf$1(t1);
          return t2;
        } else if (t1.$eq(keyword, C.Keyword_try_false_TRY_28))
          return this._parseTryStatement$0();
        else if (t1.$eq(keyword, C.Keyword_while_false_WHILE_31))
          return this._parseWhileStatement$0();
        else if (t1.$eq(keyword, C.Keyword_var_false_VAR_29) || t1.$eq(keyword, C.Keyword_final_false_FINAL_13))
          return this._parseVariableDeclarationStatementAfterMetadata$1(commentAndMetadata);
        else if (t1.$eq(keyword, C.Keyword_void_false_VOID_30)) {
          returnType = this.parseReturnType$0();
          if (this._tokenMatchesIdentifier$1(this._currentToken) && this._currentToken._next.matchesAny$1([C.TokenType_MD7, C.TokenType_qFj, C.TokenType_iJT]))
            return this._parseFunctionDeclarationStatementAfterReturnType$2(commentAndMetadata, returnType);
          else {
            if (this._tokenMatchesIdentifier$1(this._currentToken)) {
              if (this._currentToken._next.matchesAny$1([C.TokenType_Azp, C.TokenType_s8I, C.TokenType_S8h])) {
                this._reportError$1(U.AnalysisError$con2(this._source, returnType.get$offset(), returnType.get$length(returnType), C.ParserErrorCode_2Rk, []));
                return this._parseVariableDeclarationStatementAfterMetadata$1(commentAndMetadata);
              }
            } else if (this._currentToken.type === C.TokenType_33I) {
              variableList = this._parseVariableDeclarationListAfterType$3(commentAndMetadata, null, returnType);
              t1 = new N.VariableDeclarationStatement(null, this._expect$1(C.TokenType_S8h), null, null);
              t1._variableList = t1.becomeParentOf$1(variableList);
              return t1;
            }
            this._reportErrorForToken$3(C.ParserErrorCode_AKW, this._currentToken, []);
            t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
            t1.offset = this._currentToken.offset;
            $.get$StringUtilities_INTERNER().toString;
            t1._value = "";
            return new N.EmptyStatement(this._injectToken$1(t1), null, null);
          }
        } else if (t1.$eq(keyword, C.Keyword_const_false_CONST_5)) {
          if (this._currentToken._next.matchesAny$1([C.TokenType_KoJ, C.TokenType_qFj, C.TokenType_AHF, C.TokenType_WFw])) {
            t1 = this.parseExpression2$0();
            t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
            t2._expression = t2.becomeParentOf$1(t1);
            return t2;
          } else {
            t1 = this._currentToken._next;
            if (t1.type === C.TokenType_nrs) {
              afterType = this._skipTypeName$1(t1);
              if (afterType != null) {
                t1 = afterType.type;
                if (t1 !== C.TokenType_MD7)
                  if (t1 === C.TokenType_B6W) {
                    t1 = afterType._next;
                    t1 = t1.type === C.TokenType_nrs && t1._next.type === C.TokenType_MD7;
                  } else
                    t1 = false;
                else
                  t1 = true;
                if (t1) {
                  t1 = this.parseExpression2$0();
                  t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
                  t2._expression = t2.becomeParentOf$1(t1);
                  return t2;
                }
              }
            }
          }
          return this._parseVariableDeclarationStatementAfterMetadata$1(commentAndMetadata);
        } else if (t1.$eq(keyword, C.Keyword_new_false_NEW_19) || t1.$eq(keyword, C.Keyword_true_false_TRUE_27) || t1.$eq(keyword, C.Keyword_false_false_FALSE_12) || t1.$eq(keyword, C.Keyword_null_false_NULL_20) || t1.$eq(keyword, C.Keyword_super_false_SUPER_23) || t1.$eq(keyword, C.Keyword_this_false_THIS_25)) {
          t1 = this.parseExpression2$0();
          t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
          t2._expression = t2.becomeParentOf$1(t1);
          return t2;
        } else {
          this._reportErrorForToken$3(C.ParserErrorCode_AKW, this._currentToken, []);
          t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
          t1.offset = this._currentToken.offset;
          $.get$StringUtilities_INTERNER().toString;
          t1._value = "";
          return new N.EmptyStatement(this._injectToken$1(t1), null, null);
        }
      } else if (this._inGenerator && this._matchesString$1($.Parser__YIELD)) {
        token = this._currentToken;
        star = token._next;
        this._currentToken = star;
        if (star.type === C.TokenType_ph7)
          this._currentToken = star._next;
        else
          star = null;
        expression = this.parseExpression2$0();
        t1 = new N.YieldStatement(token, star, null, this._expect$1(C.TokenType_S8h), null, null);
        t1._expression = t1.becomeParentOf$1(expression);
        return t1;
      } else if (this._inAsync && this._matchesString$1($.Parser__AWAIT)) {
        if (this._tokenMatchesKeyword$2(this._currentToken._next, C.Keyword_for_false_FOR_15))
          return this._parseForStatement$0();
        t1 = this.parseExpression2$0();
        t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
        t2._expression = t2.becomeParentOf$1(t1);
        return t2;
      } else if (this._matchesString$1($.Parser__AWAIT) && this._tokenMatchesKeyword$2(this._currentToken._next, C.Keyword_for_false_FOR_15)) {
        awaitToken = this._currentToken;
        statement = this._parseForStatement$0();
        if (!J.getInterceptor(statement).$isForStatement)
          this._reportErrorForToken$3(C.CompileTimeErrorCode_cWd, awaitToken, []);
        return statement;
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_S8h) {
          this._currentToken = t1._next;
          return new N.EmptyStatement(t1, null, null);
        } else if (this._isInitializedVariableDeclaration$0())
          return this._parseVariableDeclarationStatementAfterMetadata$1(commentAndMetadata);
        else if (this._isFunctionDeclaration$0()) {
          modifiers = this._parseModifiers$0();
          if (modifiers.abstractKeyword != null || modifiers.constKeyword != null || modifiers.externalKeyword != null || modifiers.factoryKeyword != null || modifiers.finalKeyword != null || modifiers.staticKeyword != null || modifiers.varKeyword != null)
            this._reportErrorForToken$3(C.ParserErrorCode_2Zx, this._currentToken, []);
          return this._parseFunctionDeclarationStatementAfterReturnType$2(this._parseCommentAndMetadata$0(), this._parseOptionalReturnType$0());
        } else {
          t1 = this._currentToken;
          if (t1.type === C.TokenType_33I) {
            this._reportErrorForToken$3(C.ParserErrorCode_AKW, t1, []);
            t1 = new K.StringToken(null, C.TokenType_S8h, 0, null, null);
            t1.offset = this._currentToken.offset;
            $.get$StringUtilities_INTERNER().toString;
            t1._value = "";
            return new N.EmptyStatement(this._injectToken$1(t1), null, null);
          } else {
            t1 = this.parseExpression2$0();
            t2 = new N.ExpressionStatement(null, this._expect$1(C.TokenType_S8h), null, null);
            t2._expression = t2.becomeParentOf$1(t1);
            return t2;
          }
        }
      }
    },
    _parseOperator$3: function(commentAndMetadata, externalKeyword, returnType) {
      var t1, token, operatorKeyword, t2, previous, parameters, body;
      t1 = this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_operator_true_OPERATOR_44);
      token = this._currentToken;
      if (t1) {
        this._currentToken = token._next;
        operatorKeyword = token;
      } else {
        this._reportErrorForToken$3(C.ParserErrorCode_5i6, token, []);
        t1 = new S.Parser_SyntheticKeywordToken(C.Keyword_operator_true_OPERATOR_44, C.TokenType_hLM, 0, null, null);
        t1.offset = this._currentToken.offset;
        operatorKeyword = this._injectToken$1(t1);
      }
      t1 = this._currentToken;
      t2 = t1.type.lexeme;
      if (!(t2 === "==" || t2 === "~" || t2 === "[]" || t2 === "[]=" || t2 === "*" || t2 === "/" || t2 === "%" || t2 === "~/" || t2 === "+" || t2 === "-" || t2 === "<<" || t2 === ">>" || t2 === ">=" || t2 === ">" || t2 === "<=" || t2 === "<" || t2 === "&" || t2 === "^" || t2 === "|")) {
        t1 = t1.get$lexeme();
        this._reportErrorForToken$3(C.ParserErrorCode_YeK, this._currentToken, [t1]);
      }
      token = this._currentToken;
      t1 = token._next;
      this._currentToken = t1;
      if (t1.type === C.TokenType_Azp) {
        previous = t1.previous;
        t2 = previous.type;
        if ((t2 === C.TokenType_BLy || t2 === C.TokenType_MMm) && t1.offset === previous.offset + 2) {
          t1 = H.S(previous.get$lexeme()) + H.S(this._currentToken.get$lexeme());
          this._reportErrorForToken$3(C.ParserErrorCode_QCm, this._currentToken, [t1]);
          this._currentToken = this._currentToken._next;
        }
      }
      parameters = this.parseFormalParameterList$0();
      this._validateFormalParameterList$1(parameters);
      body = this._parseFunctionBody$3(true, C.ParserErrorCode_MQW, false);
      if (externalKeyword != null && !J.getInterceptor(body).$isEmptyFunctionBody)
        this._reportErrorForToken$3(C.ParserErrorCode_KIe, this._currentToken, []);
      return N.MethodDeclaration$(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, null, returnType, null, operatorKeyword, new N.SimpleIdentifier(token, null, null, null, null, null, null, null), parameters, body);
    },
    _parseOptionalReturnType$0: function() {
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_void_false_VOID_30))
        return this.parseReturnType$0();
      else {
        if (this._tokenMatchesIdentifier$1(this._currentToken))
          if (!this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_get_true_GET_40))
            if (!this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_set_true_SET_46))
              if (!this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_operator_true_OPERATOR_44))
                var t1 = this._tokenMatchesIdentifier$1(this._currentToken._next) || this._currentToken._next.type === C.TokenType_KoJ;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        if (t1)
          return this.parseReturnType$0();
        else {
          if (this._tokenMatchesIdentifier$1(this._currentToken))
            if (this._currentToken._next.type === C.TokenType_B6W)
              if (this._tokenMatchesIdentifier$1(this._peekAt$1(2)))
                t1 = this._tokenMatchesIdentifier$1(this._peekAt$1(3)) || this._peekAt$1(3).type === C.TokenType_KoJ;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
          if (t1)
            return this.parseReturnType$0();
        }
      }
      return;
    },
    _parsePartDirective$1: function(commentAndMetadata) {
      var partKeyword, token, libraryName, t1, partUri;
      partKeyword = this._expectKeyword$1(C.Keyword_part_true_PART_45);
      if (this._matchesString$1($.Parser__OF)) {
        token = this._currentToken;
        this._currentToken = token._next;
        libraryName = this._parseLibraryName$2(C.ParserErrorCode_wIv, token);
        t1 = new N.PartOfDirective(partKeyword, token, null, this._expect$1(C.TokenType_S8h), null, null, null, null, null);
        t1.AnnotatedNode$2(commentAndMetadata.comment, commentAndMetadata.metadata);
        t1._libraryName = t1.becomeParentOf$1(libraryName);
        return t1;
      }
      partUri = this.parseStringLiteral$0();
      t1 = new N.PartDirective(partKeyword, this._expect$1(C.TokenType_S8h), null, null, null, null, null, null, null, null);
      t1.AnnotatedNode$2(commentAndMetadata.comment, commentAndMetadata.metadata);
      t1._uri = t1.becomeParentOf$1(partUri);
      return t1;
    },
    _parsePostfixExpression$0: function() {
      var operand, t1, t2, argumentList, node, node0, operand0, token;
      operand = this._parseAssignableExpression$1(true);
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_AHF || t2 === C.TokenType_B6W || t2 === C.TokenType_MD7) {
        do {
          if (t1.type === C.TokenType_MD7) {
            argumentList = this.parseArgumentList$0();
            if (!!J.getInterceptor(operand).$isPropertyAccess) {
              node = operand._target;
              t1 = operand.operator;
              node0 = operand._propertyName;
              operand = new N.MethodInvocation(null, t1, null, null, null, null, null, null);
              if (node != null)
                node.set$parent(operand);
              operand._target = node;
              if (node0 != null)
                node0.set$parent(operand);
              operand._methodName = node0;
              if (argumentList != null)
                argumentList.set$parent(operand);
              operand._argumentList = argumentList;
            } else {
              operand0 = new N.FunctionExpressionInvocation(null, null, null, null, null, null, null, null);
              if (operand != null)
                operand.set$parent(operand0);
              operand0._function = operand;
              if (argumentList != null)
                argumentList.set$parent(operand0);
              operand0._argumentList = argumentList;
              operand = operand0;
            }
          } else
            operand = this._parseAssignableSelector$2(operand, true);
          t1 = this._currentToken;
          t2 = t1.type;
        } while (t2 === C.TokenType_AHF || t2 === C.TokenType_B6W || t2 === C.TokenType_MD7);
        return operand;
      }
      t1 = t2.lexeme;
      if (!(t1 === "++" || t1 === "--"))
        return operand;
      this._ensureAssignable$1(operand);
      token = this._currentToken;
      this._currentToken = token._next;
      t1 = new N.PostfixExpression(null, token, null, null, null, null, null, null);
      t1._operand = t1.becomeParentOf$1(operand);
      return t1;
    },
    _parsePrimaryExpression$0: function() {
      var token, value, token0, value0, token1, value1, leftParenthesis, wasInInitializer, expression, rightParenthesis, t1, t2, exception, parameters, body;
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_this_false_THIS_25)) {
        token = this._currentToken;
        this._currentToken = token._next;
        return new N.ThisExpression(token, null, null, null, null);
      } else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_super_false_SUPER_23)) {
        token = this._currentToken;
        this._currentToken = token._next;
        return this._parseAssignableSelector$2(new N.SuperExpression(token, null, null, null, null), false);
      } else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_null_false_NULL_20)) {
        token = this._currentToken;
        this._currentToken = token._next;
        t1 = new N.NullLiteral(null, null, null, null, null);
        t1.literal = token;
        return t1;
      } else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_false_false_FALSE_12)) {
        token = this._currentToken;
        this._currentToken = token._next;
        return new N.BooleanLiteral(token, false, null, null, null, null);
      } else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_true_false_TRUE_27)) {
        token = this._currentToken;
        this._currentToken = token._next;
        return new N.BooleanLiteral(token, true, null, null, null, null);
      } else {
        t1 = this._currentToken;
        t2 = t1.type;
        if (t2 === C.TokenType_EQM) {
          this._currentToken = t1._next;
          token = t1;
          value = 0;
          try {
            value = H.Primitives_parseDouble(token.get$lexeme(), null);
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException)
              ;
            else
              throw exception;
          }

          return new N.DoubleLiteral(token, value, null, null, null, null);
        } else if (t2 === C.TokenType_wEo) {
          this._currentToken = t1._next;
          token0 = t1;
          value0 = null;
          try {
            value0 = H.Primitives_parseInt(J.substring$1$s(token0.get$lexeme(), 2), 16, null);
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException)
              ;
            else
              throw exception;
          }

          return new N.IntegerLiteral(token0, value0, null, null, null, null);
        } else if (t2 === C.TokenType_j1u) {
          this._currentToken = t1._next;
          token1 = t1;
          value1 = null;
          try {
            value1 = H.Primitives_parseInt(token1.get$lexeme(), null, null);
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException)
              ;
            else
              throw exception;
          }

          return new N.IntegerLiteral(token1, value1, null, null, null, null);
        } else if (t2 === C.TokenType_iDZ)
          return this.parseStringLiteral$0();
        else if (t2 === C.TokenType_qFj)
          return this._parseMapLiteral$2(null, null);
        else if (t2 === C.TokenType_AHF || t2 === C.TokenType_WFw)
          return this._parseListLiteral$2(null, null);
        else if (this._tokenMatchesIdentifier$1(t1))
          return this.parsePrefixedIdentifier$0();
        else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_new_false_NEW_19))
          return this._parseInstanceCreationExpression$1(this._expectKeyword$1(C.Keyword_new_false_NEW_19));
        else if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_const_false_CONST_5))
          return this._parseConstExpression$0();
        else {
          t1 = this._currentToken;
          t2 = t1.type;
          if (t2 === C.TokenType_MD7) {
            if (this._isFunctionExpression$1(t1)) {
              parameters = this.parseFormalParameterList$0();
              this._validateFormalParameterList$1(parameters);
              body = this._parseFunctionBody$3(false, C.ParserErrorCode_MQW, true);
              t1 = new N.FunctionExpression(null, null, null, null, null, null, null);
              t1._parameters = t1.becomeParentOf$1(parameters);
              t1._body = t1.becomeParentOf$1(body);
              return t1;
            }
            token = this._currentToken;
            this._currentToken = token._next;
            leftParenthesis = token;
            wasInInitializer = this._inInitializer;
            this._inInitializer = false;
            try {
              expression = this.parseExpression2$0();
              rightParenthesis = this._expect$1(C.TokenType_kC8);
              t1 = new N.ParenthesizedExpression(null, null, null, null, null, null, null);
              t1.ParenthesizedExpression$3(leftParenthesis, expression, rightParenthesis);
              return t1;
            } finally {
              this._inInitializer = wasInInitializer;
            }
          } else if (t2 === C.TokenType_KoJ)
            return this._parseListOrMapLiteral$1(null);
          else if (t2 === C.TokenType_B8J && t1._next.type === C.TokenType_nrs) {
            t1 = t1.get$lexeme();
            this._reportErrorForToken$3(C.ParserErrorCode_udD, this._currentToken, [t1]);
            this._currentToken = this._currentToken._next;
            return this._parsePrimaryExpression$0();
          } else if (this._tokenMatchesKeyword$2(t1, C.Keyword_void_false_VOID_30)) {
            t1 = this._currentToken.get$lexeme();
            this._reportErrorForToken$3(C.ParserErrorCode_udD, this._currentToken, [t1]);
            this._currentToken = this._currentToken._next;
            return this._parsePrimaryExpression$0();
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_mPa)
              return this._parseSymbolLiteral$0();
            else {
              this._reportErrorForToken$3(C.ParserErrorCode_yw2, t1, []);
              return this._createSyntheticIdentifier$0();
            }
          }
        }
      }
    },
    _parseRedirectingConstructorInvocation$0: function() {
      var keyword, period, constructorName, argumentList, t1;
      keyword = this._expectKeyword$1(C.Keyword_this_false_THIS_25);
      period = this._currentToken;
      if (period.type === C.TokenType_B6W) {
        this._currentToken = period._next;
        constructorName = this.parseSimpleIdentifier$0();
      } else {
        period = null;
        constructorName = null;
      }
      argumentList = this.parseArgumentList$0();
      t1 = new N.RedirectingConstructorInvocation(keyword, period, null, null, null, null, null);
      if (constructorName != null)
        constructorName.set$parent(t1);
      t1._constructorName = constructorName;
      if (argumentList != null)
        argumentList.set$parent(t1);
      t1._argumentList = argumentList;
      return t1;
    },
    _parseRelationalExpression$0: function() {
      var t1, token, expression, node, expression0, notOperator;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type._tokenClass === C.TokenClass_7_RELATIONAL_OPERATOR_12) {
        token = this._currentToken;
        t1 = token._next;
        this._currentToken = t1;
        expression = new N.SuperExpression(token, null, null, null, null);
        this._currentToken = t1._next;
        node = this.parseBitwiseOrExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
        return expression0;
      }
      expression = this.parseBitwiseOrExpression$0();
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_as_true_AS_34)) {
        token = this._currentToken;
        this._currentToken = token._next;
        node = this.parseTypeName$0();
        expression0 = new N.AsExpression(null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._expression = expression;
        expression0.asOperator = token;
        node.set$parent(expression0);
        expression0._type = node;
        expression = expression0;
      } else {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_is_false_IS_18)) {
          token = this._currentToken;
          notOperator = token._next;
          this._currentToken = notOperator;
          if (notOperator.type === C.TokenType_kOG)
            this._currentToken = notOperator._next;
          else
            notOperator = null;
          node = this.parseTypeName$0();
          expression0 = new N.IsExpression(null, token, notOperator, null, null, null, null, null);
          if (expression != null)
            expression.set$parent(expression0);
          expression0._expression = expression;
          node.set$parent(expression0);
          expression0._type = node;
          expression = expression0;
        } else {
          t1 = this._currentToken;
          if (t1.type._tokenClass === C.TokenClass_7_RELATIONAL_OPERATOR_12) {
            this._currentToken = t1._next;
            node = this.parseBitwiseOrExpression$0();
            expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
            if (expression != null)
              expression.set$parent(expression0);
            expression0._leftOperand = expression;
            if (node != null)
              node.set$parent(expression0);
            expression0._rightOperand = node;
            expression = expression0;
          }
        }
      }
      return expression;
    },
    _parseReturnStatement$0: function() {
      var returnKeyword, t1, expression;
      returnKeyword = this._expectKeyword$1(C.Keyword_return_false_RETURN_22);
      t1 = this._currentToken;
      if (t1.type === C.TokenType_S8h) {
        this._currentToken = t1._next;
        t1 = new N.ReturnStatement(returnKeyword, null, t1, null, null);
        t1._expression = t1.becomeParentOf$1(null);
        return t1;
      }
      expression = this.parseExpression2$0();
      t1 = new N.ReturnStatement(returnKeyword, null, this._expect$1(C.TokenType_S8h), null, null);
      t1._expression = t1.becomeParentOf$1(expression);
      return t1;
    },
    _parseSetter$4: function(commentAndMetadata, externalKeyword, staticKeyword, returnType) {
      var propertyKeyword, $name, parameters, t1, body;
      propertyKeyword = this._expectKeyword$1(C.Keyword_set_true_SET_46);
      $name = this.parseSimpleIdentifier$0();
      parameters = this.parseFormalParameterList$0();
      this._validateFormalParameterList$1(parameters);
      t1 = externalKeyword == null;
      body = this._parseFunctionBody$3(!t1 || staticKeyword == null, C.ParserErrorCode_Fcu, false);
      if (!t1 && !J.getInterceptor(body).$isEmptyFunctionBody)
        this._reportErrorForToken$3(C.ParserErrorCode_Q2X, this._currentToken, []);
      return N.MethodDeclaration$(commentAndMetadata.comment, commentAndMetadata.metadata, externalKeyword, staticKeyword, returnType, propertyKeyword, null, $name, parameters, body);
    },
    _parseShiftExpression$0: function() {
      var t1, token, expression, node, expression0;
      t1 = this._currentToken;
      if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23) && this._currentToken._next.type._tokenClass === C.TokenClass_11_SHIFT_OPERATOR_13) {
        token = this._currentToken;
        this._currentToken = token._next;
        expression = new N.SuperExpression(token, null, null, null, null);
      } else
        expression = this._parseAdditiveExpression$0();
      for (; t1 = this._currentToken, t1.type._tokenClass === C.TokenClass_11_SHIFT_OPERATOR_13; expression = expression0) {
        this._currentToken = t1._next;
        node = this._parseAdditiveExpression$0();
        expression0 = new N.BinaryExpression(null, t1, null, null, null, null, null, null, null);
        if (expression != null)
          expression.set$parent(expression0);
        expression0._leftOperand = expression;
        if (node != null)
          node.set$parent(expression0);
        expression0._rightOperand = node;
      }
      return expression;
    },
    _parseStatementList$0: function() {
      var statements, statementStart, t1;
      statements = [];
      statements.$builtinTypeInfo = [N.Statement];
      statementStart = this._currentToken;
      t1 = statementStart;
      while (true) {
        t1 = t1.type;
        if (!(t1 !== C.TokenType_EOF_Imi && t1 !== C.TokenType_33I && !this._isSwitchMember$0()))
          break;
        statements.push(this.parseStatement2$0());
        t1 = this._currentToken;
        if (t1 == null ? statementStart == null : t1 === statementStart) {
          this._reportErrorForToken$3(C.ParserErrorCode_udD, t1, [t1.get$lexeme()]);
          t1 = this._currentToken._next;
          this._currentToken = t1;
          statementStart = t1;
        } else
          statementStart = t1;
        t1 = statementStart;
      }
      return statements;
    },
    _parseStringInterpolation$1: function(string) {
      var elements, openToken, wasInInitializer, expression, rightBracket, elements0, t1, hasMore, t2, node, token, expression0, string0, t3;
      elements0 = [];
      elements0.$builtinTypeInfo = [N.InterpolationElement];
      elements = elements0;
      t1 = this._currentToken.type;
      hasMore = t1 === C.TokenType_fld || t1 === C.TokenType_RG0;
      t1 = this._computeStringValue$3(string.get$lexeme(), true, !hasMore);
      t2 = new N.InterpolationString(null, null, null, null);
      t2._ast$_contents = string;
      t2._ast$_value = t1;
      J.add$1$a(elements, t2);
      for (; hasMore;) {
        t1 = this._currentToken;
        if (t1.type === C.TokenType_fld) {
          this._currentToken = t1._next;
          openToken = t1;
          wasInInitializer = this._inInitializer;
          this._inInitializer = false;
          try {
            expression = this.parseExpression2$0();
            rightBracket = this._expect$1(C.TokenType_33I);
            node = expression;
            t1 = new N.InterpolationExpression(openToken, null, rightBracket, null, null);
            if (node != null)
              node.set$parent(t1);
            t1._expression = node;
            J.add$1$a(elements, t1);
          } finally {
            this._inInitializer = wasInInitializer;
          }
        } else {
          t2 = t1._next;
          this._currentToken = t2;
          if (t2.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t2, "$isKeywordToken").keyword, C.Keyword_this_false_THIS_25)) {
            token = this._currentToken;
            this._currentToken = token._next;
            expression0 = new N.ThisExpression(token, null, null, null, null);
          } else
            expression0 = this.parseSimpleIdentifier$0();
          t1 = new N.InterpolationExpression(t1, null, null, null, null);
          expression0.set$parent(t1);
          t1._expression = expression0;
          J.add$1$a(elements, t1);
        }
        string0 = this._currentToken;
        if (string0.type === C.TokenType_iDZ) {
          t1 = string0._next;
          this._currentToken = t1;
          t1 = t1.type;
          hasMore = t1 === C.TokenType_fld || t1 === C.TokenType_RG0;
          t1 = this._computeStringValue$3(string0.get$lexeme(), false, !hasMore);
          t2 = new N.InterpolationString(null, null, null, null);
          t2._ast$_contents = string0;
          t2._ast$_value = t1;
          J.add$1$a(elements, t2);
          string = string0;
        } else
          hasMore = false;
      }
      t1 = new N.StringInterpolation(null, null, null, null, null);
      t2 = N.InterpolationElement;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._elements = t3;
      t3.addAll$1(0, elements);
      return t1;
    },
    _parseSwitchStatement$0: function() {
      var wasInSwitch, definedLabels, keyword, leftParenthesis, expression, rightParenthesis, leftBracket, defaultKeyword, members, labels, identifier, label, colon, caseKeyword, caseExpression, colon0, colon1, rightBracket, t1, labels0, t2, node, token, t3, t4;
      wasInSwitch = this._inSwitch;
      this._inSwitch = true;
      try {
        definedLabels = P.HashSet_HashSet(null, null, null, P.String);
        keyword = this._expectKeyword$1(C.Keyword_switch_false_SWITCH_24);
        leftParenthesis = this._expect$1(C.TokenType_MD7);
        expression = this.parseExpression2$0();
        rightParenthesis = this._expect$1(C.TokenType_kC8);
        leftBracket = this._expect$1(C.TokenType_qFj);
        defaultKeyword = null;
        members = H.setRuntimeTypeInfo([], [N.SwitchMember]);
        while (true) {
          t1 = this._currentToken.type;
          if (!(t1 !== C.TokenType_EOF_Imi && t1 !== C.TokenType_33I))
            break;
          labels0 = [];
          labels0.$builtinTypeInfo = [N.Label];
          labels = labels0;
          while (true) {
            t1 = this._currentToken;
            t2 = t1.type;
            if (t2 !== C.TokenType_nrs)
              t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
            else
              t1 = true;
            if (!(t1 && this._currentToken._next.type === C.TokenType_chs))
              break;
            identifier = this.parseSimpleIdentifier$0();
            label = identifier.get$token().get$lexeme();
            if (J.contains$1$as(definedLabels, label))
              this._reportErrorForToken$3(C.ParserErrorCode_V5x, identifier.get$token(), [label]);
            else
              J.add$1$a(definedLabels, label);
            colon = this._expect$1(C.TokenType_chs);
            node = identifier;
            t1 = new N.Label(null, colon, null, null);
            if (node != null)
              node.set$parent(t1);
            t1._label = node;
            J.add$1$a(labels, t1);
          }
          t1 = this._currentToken;
          if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_case_false_CASE_2)) {
            token = this._currentToken;
            this._currentToken = token._next;
            caseKeyword = token;
            caseExpression = this.parseExpression2$0();
            colon0 = this._expect$1(C.TokenType_chs);
            node = caseExpression;
            t1 = this._parseStatementList$0();
            t2 = new N.SwitchCase(null, null, caseKeyword, colon0, null, null, null);
            t3 = N.Label;
            t4 = [];
            t4.$builtinTypeInfo = [t3];
            t4 = new N.NodeList(t2, t4);
            t4.$builtinTypeInfo = [t3];
            t2._labels = t4;
            t3 = N.Statement;
            t4 = [];
            t4.$builtinTypeInfo = [t3];
            t4 = new N.NodeList(t2, t4);
            t4.$builtinTypeInfo = [t3];
            t2._statements = t4;
            t2._labels.addAll$1(0, labels);
            t2._statements.addAll$1(0, t1);
            if (node != null)
              node.set$parent(t2);
            t2._expression = node;
            J.add$1$a(members, t2);
            if (defaultKeyword != null)
              this._reportErrorForToken$3(C.ParserErrorCode_ef1, caseKeyword, []);
          } else {
            t1 = this._currentToken;
            if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_default_false_DEFAULT_7)) {
              if (defaultKeyword != null)
                this._reportErrorForToken$3(C.ParserErrorCode_QTd, this._currentToken._next, []);
              token = this._currentToken;
              this._currentToken = token._next;
              defaultKeyword = token;
              colon1 = this._expect$1(C.TokenType_chs);
              t1 = this._parseStatementList$0();
              t2 = new N.SwitchDefault(null, defaultKeyword, colon1, null, null, null);
              t3 = N.Label;
              t4 = [];
              t4.$builtinTypeInfo = [t3];
              t4 = new N.NodeList(t2, t4);
              t4.$builtinTypeInfo = [t3];
              t2._labels = t4;
              t3 = N.Statement;
              t4 = [];
              t4.$builtinTypeInfo = [t3];
              t4 = new N.NodeList(t2, t4);
              t4.$builtinTypeInfo = [t3];
              t2._statements = t4;
              t2._labels.addAll$1(0, labels);
              t2._statements.addAll$1(0, t1);
              J.add$1$a(members, t2);
            } else {
              this._reportErrorForToken$3(C.ParserErrorCode_B8J, this._currentToken, []);
              while (true) {
                t1 = this._currentToken;
                t2 = t1.type;
                if (t2 !== C.TokenType_EOF_Imi)
                  if (t2 !== C.TokenType_33I)
                    if (!(t2 === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_case_false_CASE_2))) {
                      t1 = this._currentToken;
                      t1 = !(t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_default_false_DEFAULT_7));
                    } else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
                if (!t1)
                  break;
                this._currentToken = this._currentToken._next;
              }
            }
          }
        }
        rightBracket = this._expect$1(C.TokenType_33I);
        t1 = new N.SwitchStatement(keyword, leftParenthesis, null, rightParenthesis, leftBracket, null, rightBracket, null, null);
        t2 = N.SwitchMember;
        t1._members = H.setRuntimeTypeInfo(new N.NodeList(t1, H.setRuntimeTypeInfo([], [t2])), [t2]);
        t1._expression = t1.becomeParentOf$1(expression);
        t1._members.addAll$1(0, members);
        return t1;
      } finally {
        this._inSwitch = wasInSwitch;
      }
    },
    _parseSymbolLiteral$0: function() {
      var token, components, token0, t1, t2, previous;
      token = this._currentToken;
      this._currentToken = token._next;
      components = H.setRuntimeTypeInfo([], [K.Token]);
      if (this._tokenMatchesIdentifier$1(this._currentToken)) {
        token0 = this._currentToken;
        this._currentToken = token0._next;
        components.push(token0);
        for (; t1 = this._currentToken, t1.type === C.TokenType_B6W;) {
          t1 = t1._next;
          this._currentToken = t1;
          t2 = t1.type;
          if (t2 !== C.TokenType_nrs)
            t1 = t2 === C.TokenType_hLM && H.interceptedTypeCast(t1, "$isKeywordToken").keyword.get$isPseudoKeyword();
          else
            t1 = true;
          token0 = this._currentToken;
          if (t1) {
            this._currentToken = token0._next;
            components.push(token0);
          } else {
            this._reportErrorForToken$3(C.ParserErrorCode_yw2, token0, []);
            t1 = this._currentToken;
            t2 = new K.StringToken(null, C.TokenType_nrs, 0, null, null);
            t2.offset = t1.offset;
            $.get$StringUtilities_INTERNER().toString;
            t2._value = "";
            previous = t1.previous;
            t2._next = t1;
            t1.previous = t2;
            previous._next = t2;
            t2.previous = previous;
            components.push(t2);
            break;
          }
        }
      } else if (this._currentToken.type.get$isOperator()) {
        token0 = this._currentToken;
        this._currentToken = token0._next;
        components.push(token0);
      } else {
        t1 = this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_void_false_VOID_30);
        token0 = this._currentToken;
        if (t1) {
          this._currentToken = token0._next;
          components.push(token0);
        } else {
          this._reportErrorForToken$3(C.ParserErrorCode_yw2, token0, []);
          t1 = new K.StringToken(null, C.TokenType_nrs, 0, null, null);
          t1.offset = this._currentToken.offset;
          $.get$StringUtilities_INTERNER().toString;
          t1._value = "";
          components.push(this._injectToken$1(t1));
        }
      }
      return new N.SymbolLiteral(token, P.List_List$from(components, true, null), null, null, null, null);
    },
    _parseThrowExpression$0: function() {
      var keyword, t1, t2;
      keyword = this._expectKeyword$1(C.Keyword_throw_false_THROW_26);
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_S8h || t2 === C.TokenType_kC8) {
        this._reportErrorForToken$3(C.ParserErrorCode_6Hm, t1, []);
        t1 = new N.ThrowExpression(keyword, null, null, null, null, null);
        t1._expression = t1.becomeParentOf$1(this._createSyntheticIdentifier$0());
        return t1;
      }
      t1 = new N.ThrowExpression(keyword, null, null, null, null, null);
      t1._expression = t1.becomeParentOf$1(this.parseExpression2$0());
      return t1;
    },
    _parseThrowExpressionWithoutCascade$0: function() {
      var keyword, t1, t2;
      keyword = this._expectKeyword$1(C.Keyword_throw_false_THROW_26);
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_S8h || t2 === C.TokenType_kC8) {
        this._reportErrorForToken$3(C.ParserErrorCode_6Hm, t1, []);
        t1 = new N.ThrowExpression(keyword, null, null, null, null, null);
        t1._expression = t1.becomeParentOf$1(this._createSyntheticIdentifier$0());
        return t1;
      }
      t1 = new N.ThrowExpression(keyword, null, null, null, null, null);
      t1._expression = t1.becomeParentOf$1(this.parseExpressionWithoutCascade$0());
      return t1;
    },
    _parseTryStatement$0: function() {
      var tryKeyword, body, catchClauses, t1, t2, token, exceptionType, onKeyword, leftParenthesis, exceptionParameter, comma, stackTraceParameter, rightParenthesis, catchKeyword, catchBody, finallyClause, finallyKeyword;
      tryKeyword = this._expectKeyword$1(C.Keyword_try_false_TRY_28);
      body = this.parseBlock$0();
      catchClauses = H.setRuntimeTypeInfo([], [N.CatchClause]);
      while (true) {
        t1 = $.Parser__ON;
        t2 = this._currentToken;
        if (!(t2.type === C.TokenType_nrs && t2.get$lexeme() === t1)) {
          t1 = this._currentToken;
          t1 = t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_catch_false_CATCH_3);
        } else
          t1 = true;
        if (!t1)
          break;
        t1 = $.Parser__ON;
        t2 = this._currentToken;
        if (t2.type === C.TokenType_nrs && t2.get$lexeme() === t1) {
          token = this._currentToken;
          this._currentToken = token._next;
          exceptionType = this.parseTypeName$0();
          onKeyword = token;
        } else {
          onKeyword = null;
          exceptionType = null;
        }
        t1 = this._currentToken;
        if (t1.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t1, "$isKeywordToken").keyword, C.Keyword_catch_false_CATCH_3)) {
          token = this._currentToken;
          this._currentToken = token._next;
          leftParenthesis = this._expect$1(C.TokenType_MD7);
          exceptionParameter = this.parseSimpleIdentifier$0();
          comma = this._currentToken;
          if (comma.type === C.TokenType_s8I) {
            this._currentToken = comma._next;
            stackTraceParameter = this.parseSimpleIdentifier$0();
          } else {
            comma = null;
            stackTraceParameter = null;
          }
          rightParenthesis = this._expect$1(C.TokenType_kC8);
          catchKeyword = token;
        } else {
          catchKeyword = null;
          leftParenthesis = null;
          exceptionParameter = null;
          comma = null;
          stackTraceParameter = null;
          rightParenthesis = null;
        }
        catchBody = this.parseBlock$0();
        t1 = new N.CatchClause(onKeyword, null, catchKeyword, null, null, comma, null, null, null, null, null);
        if (exceptionType != null)
          exceptionType.set$parent(t1);
        t1._exceptionType = exceptionType;
        t1._leftParenthesis = leftParenthesis;
        if (exceptionParameter != null)
          exceptionParameter.set$parent(t1);
        t1._exceptionParameter = exceptionParameter;
        if (stackTraceParameter != null)
          stackTraceParameter.set$parent(t1);
        t1._stackTraceParameter = stackTraceParameter;
        t1._rightParenthesis = rightParenthesis;
        catchBody.set$parent(t1);
        t1._body = catchBody;
        catchClauses.push(t1);
      }
      if (this._tokenMatchesKeyword$2(this._currentToken, C.Keyword_finally_false_FINALLY_14)) {
        token = this._currentToken;
        this._currentToken = token._next;
        finallyClause = this.parseBlock$0();
        finallyKeyword = token;
      } else {
        if (catchClauses.length === 0)
          this._reportErrorForToken$3(C.ParserErrorCode_P98, this._currentToken, []);
        finallyClause = null;
        finallyKeyword = null;
      }
      t1 = new N.TryStatement(tryKeyword, null, null, finallyKeyword, null, null, null);
      t1.TryStatement$5(tryKeyword, body, catchClauses, finallyKeyword, finallyClause);
      return t1;
    },
    _parseTypeAlias$1: function(commentAndMetadata) {
      var keyword, next, t1, typeAlias;
      keyword = this._expectKeyword$1(C.Keyword_typedef_true_TYPEDEF_48);
      if (this._tokenMatchesIdentifier$1(this._currentToken)) {
        next = this._currentToken._next;
        t1 = next.type;
        if (t1 === C.TokenType_KoJ) {
          next = this._skipTypeParameterList$1(next);
          if (next != null && next.type === C.TokenType_Azp) {
            typeAlias = this._parseClassTypeAlias$3(commentAndMetadata, null, keyword);
            this._reportErrorForToken$3(C.ParserErrorCode_gPO, keyword, []);
            return typeAlias;
          }
        } else if (t1 === C.TokenType_Azp) {
          typeAlias = this._parseClassTypeAlias$3(commentAndMetadata, null, keyword);
          this._reportErrorForToken$3(C.ParserErrorCode_gPO, keyword, []);
          return typeAlias;
        }
      }
      return this._parseFunctionTypeAlias$2(commentAndMetadata, keyword);
    },
    _parseUnaryExpression$0: function() {
      var t1, t2, t3, t4, node, offset, firstOperator, secondOperator, node0, token, expression;
      t1 = this._currentToken;
      t2 = t1.type;
      if (t2 === C.TokenType_O9i || t2 === C.TokenType_kOG || t2 === C.TokenType_gmZ) {
        t2 = t1._next;
        this._currentToken = t2;
        if (t2.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t2, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23)) {
          t2 = this._currentToken;
          t3 = t2._next;
          t4 = t3.type;
          if (t4 === C.TokenType_AHF || t4 === C.TokenType_B6W) {
            node = this._parseUnaryExpression$0();
            t1 = new N.PrefixExpression(t1, null, null, null, null, null, null, null);
            if (node != null)
              node.set$parent(t1);
            t1._operand = node;
            return t1;
          }
          this._currentToken = t3;
          node = new N.SuperExpression(t2, null, null, null, null);
          t1 = new N.PrefixExpression(t1, null, null, null, null, null, null, null);
          node.set$parent(t1);
          t1._operand = node;
          return t1;
        }
        node = this._parseUnaryExpression$0();
        t1 = new N.PrefixExpression(t1, null, null, null, null, null, null, null);
        if (node != null)
          node.set$parent(t1);
        t1._operand = node;
        return t1;
      } else {
        t3 = t2.lexeme;
        if (t3 === "++" || t3 === "--") {
          t3 = t1._next;
          this._currentToken = t3;
          if (t3.type === C.TokenType_hLM && J.$eq(H.interceptedTypeCast(t3, "$isKeywordToken").keyword, C.Keyword_super_false_SUPER_23)) {
            t3 = this._currentToken;
            t4 = t3._next.type;
            if (t4 === C.TokenType_AHF || t4 === C.TokenType_B6W) {
              node = this._parseUnaryExpression$0();
              t1 = new N.PrefixExpression(t1, null, null, null, null, null, null, null);
              if (node != null)
                node.set$parent(t1);
              t1._operand = node;
              return t1;
            }
            if (t2 === C.TokenType_itQ) {
              offset = t1.offset;
              firstOperator = new K.Token(C.TokenType_O9i, 0, null, null);
              firstOperator.offset = offset;
              secondOperator = new K.Token(C.TokenType_O9i, 0, null, null);
              secondOperator.offset = offset + 1;
              secondOperator._next = t3;
              t3.previous = secondOperator;
              firstOperator._next = secondOperator;
              secondOperator.previous = firstOperator;
              t1 = t1.previous;
              t1._next = firstOperator;
              firstOperator.previous = t1;
              this._currentToken = t3._next;
              node = new N.SuperExpression(t3, null, null, null, null);
              node0 = new N.PrefixExpression(secondOperator, null, null, null, null, null, null, null);
              node.set$parent(node0);
              node0._operand = node;
              t1 = new N.PrefixExpression(firstOperator, null, null, null, null, null, null, null);
              node0.set$parent(t1);
              t1._operand = node0;
              return t1;
            } else {
              t2 = t1.get$lexeme();
              this._reportErrorForToken$3(C.ParserErrorCode_YkH, this._currentToken, [t2]);
              token = this._currentToken;
              this._currentToken = token._next;
              node = new N.SuperExpression(token, null, null, null, null);
              t1 = new N.PrefixExpression(t1, null, null, null, null, null, null, null);
              node.set$parent(t1);
              t1._operand = node;
              return t1;
            }
          }
          node = this._parseAssignableExpression$1(false);
          t1 = new N.PrefixExpression(t1, null, null, null, null, null, null, null);
          if (node != null)
            node.set$parent(t1);
          t1._operand = node;
          return t1;
        } else if (t2 === C.TokenType_Jeb) {
          this._reportErrorForToken$3(C.ParserErrorCode_yw2, t1, []);
          return this._createSyntheticIdentifier$0();
        } else {
          t3 = $.Parser__AWAIT;
          if (t2 === C.TokenType_nrs && t1.get$lexeme() === t3) {
            token = this._currentToken;
            this._currentToken = token._next;
            expression = this._parseUnaryExpression$0();
            t1 = new N.AwaitExpression(token, null, null, null, null, null);
            if (expression != null)
              expression.set$parent(t1);
            t1._expression = expression;
            return t1;
          }
        }
      }
      return this._parsePostfixExpression$0();
    },
    _parseVariableDeclaration$0: function() {
      var commentAndMetadata, $name, equals, initializer, node, t1, t2, t3;
      commentAndMetadata = this._parseCommentAndMetadata$0();
      $name = this.parseSimpleIdentifier$0();
      equals = this._currentToken;
      if (equals.type === C.TokenType_Azp) {
        this._currentToken = equals._next;
        initializer = this.parseExpression2$0();
      } else {
        equals = null;
        initializer = null;
      }
      node = commentAndMetadata.comment;
      t1 = new N.VariableDeclaration(null, equals, null, null, null, null, null);
      t2 = N.Annotation;
      t3 = [];
      t3.$builtinTypeInfo = [t2];
      t3 = new N.NodeList(t1, t3);
      t3.$builtinTypeInfo = [t2];
      t1._metadata = t3;
      if (node != null)
        node.set$parent(t1);
      t1._comment = node;
      t1._metadata.addAll$1(0, commentAndMetadata.metadata);
      $name.set$parent(t1);
      t1._name = $name;
      if (initializer != null)
        initializer.set$parent(t1);
      t1._initializer = initializer;
      return t1;
    },
    _parseVariableDeclarationListAfterMetadata$1: function(commentAndMetadata) {
      var holder = this._parseFinalConstVarOrType$1(false);
      return this._parseVariableDeclarationListAfterType$3(commentAndMetadata, holder.keyword, holder.type);
    },
    _parseVariableDeclarationListAfterType$3: function(commentAndMetadata, keyword, type) {
      var variables, t1, t2;
      if (type != null && keyword != null && this._tokenMatchesKeyword$2(keyword, C.Keyword_var_false_VAR_29))
        this._reportErrorForToken$3(C.ParserErrorCode_Xlp, keyword, []);
      variables = H.setRuntimeTypeInfo([], [N.VariableDeclaration]);
      variables.push(this._parseVariableDeclaration$0());
      for (; t1 = this._currentToken, t1.type === C.TokenType_s8I;) {
        this._currentToken = t1._next;
        variables.push(this._parseVariableDeclaration$0());
      }
      t1 = commentAndMetadata != null;
      t2 = t1 ? commentAndMetadata.comment : null;
      return N.VariableDeclarationList$(t2, t1 ? commentAndMetadata.metadata : null, keyword, type, variables);
    },
    _parseVariableDeclarationStatementAfterMetadata$1: function(commentAndMetadata) {
      var variableList, t1;
      variableList = this._parseVariableDeclarationListAfterMetadata$1(commentAndMetadata);
      t1 = new N.VariableDeclarationStatement(null, this._expect$1(C.TokenType_S8h), null, null);
      t1._variableList = t1.becomeParentOf$1(variableList);
      return t1;
    },
    _parseWhileStatement$0: function() {
      var wasInLoop, keyword, leftParenthesis, condition, rightParenthesis, body, t1;
      wasInLoop = this._inLoop;
      this._inLoop = true;
      try {
        keyword = this._expectKeyword$1(C.Keyword_while_false_WHILE_31);
        leftParenthesis = this._expect$1(C.TokenType_MD7);
        condition = this.parseExpression2$0();
        rightParenthesis = this._expect$1(C.TokenType_kC8);
        body = this.parseStatement2$0();
        t1 = new N.WhileStatement(keyword, leftParenthesis, null, rightParenthesis, null, null, null);
        t1._condition = t1.becomeParentOf$1(condition);
        t1._body = t1.becomeParentOf$1(body);
        return t1;
      } finally {
        this._inLoop = wasInLoop;
      }
    },
    _peekAt$1: function(distance) {
      var token, i;
      token = this._currentToken;
      for (i = 0; i < distance; ++i)
        token = token._next;
      return token;
    },
    _reportError$1: function(error) {
      if (this._errorListenerLock !== 0)
        return;
      this._errorListener.errors.push(error);
    },
    _reportErrorForToken$3: function(errorCode, token, $arguments) {
      if (J.$eq(token.get$type(), C.TokenType_EOF_Imi))
        token = token.get$previous();
      this._reportError$1(U.AnalysisError$con2(this._source, token.get$offset(), P.max(J.get$length$as(token), 1), errorCode, $arguments));
    },
    _skipBlock$0: function() {
      var t1, endToken, endToken0;
      t1 = this._currentToken;
      H.interceptedTypeCast(t1, "$isBeginToken");
      endToken = t1.endToken;
      if (endToken == null) {
        endToken = t1._next;
        for (; endToken == null ? t1 != null : endToken !== t1; t1 = endToken, endToken = endToken0) {
          this._currentToken = endToken;
          endToken0 = endToken._next;
        }
        this._reportErrorForToken$3(C.ParserErrorCode_s8i, t1.previous, ["}"]);
      } else
        this._currentToken = endToken._next;
    },
    _skipFinalConstVarOrType$1: function(startToken) {
      var next, next2, t1;
      if (this._tokenMatchesKeyword$2(startToken, C.Keyword_final_false_FINAL_13) || this._tokenMatchesKeyword$2(startToken, C.Keyword_const_false_CONST_5)) {
        next = startToken._next;
        if (this._tokenMatchesIdentifier$1(next)) {
          next2 = next._next;
          if (!this._tokenMatchesIdentifier$1(next2)) {
            t1 = next2.type;
            t1 = t1 === C.TokenType_KoJ || t1 === C.TokenType_B6W;
          } else
            t1 = true;
          if (t1)
            return this._skipTypeName$1(next);
          return next;
        }
      } else if (this._tokenMatchesKeyword$2(startToken, C.Keyword_var_false_VAR_29))
        return startToken._next;
      else if (this._tokenMatchesIdentifier$1(startToken)) {
        next = startToken._next;
        if (!this._tokenMatchesIdentifier$1(next)) {
          t1 = next.type;
          if (t1 !== C.TokenType_KoJ)
            if (!this._tokenMatchesKeyword$2(next, C.Keyword_this_false_THIS_25))
              if (t1 === C.TokenType_B6W)
                if (this._tokenMatchesIdentifier$1(next._next))
                  if (!this._tokenMatchesIdentifier$1(next._next._next)) {
                    t1 = next._next._next;
                    t1 = t1.type === C.TokenType_KoJ || this._tokenMatchesKeyword$2(t1, C.Keyword_this_false_THIS_25);
                  } else
                    t1 = true;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = true;
          else
            t1 = true;
        } else
          t1 = true;
        if (t1)
          return this._skipReturnType$1(startToken);
      }
      return;
    },
    _skipFormalParameterList$1: function(startToken) {
      var next, t1, afterParameters, afterType;
      if (startToken.type !== C.TokenType_MD7)
        return;
      next = startToken._next;
      if (next.type === C.TokenType_kC8)
        return next._next;
      if (!next.matchesAny$1([C.TokenType_27D, C.TokenType_AHF, C.TokenType_qFj]))
        if (!this._tokenMatchesKeyword$2(next, C.Keyword_void_false_VOID_30))
          t1 = this._tokenMatchesIdentifier$1(next) && next._next.matchesAny$1([C.TokenType_s8I, C.TokenType_kC8]);
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return this._skipPastMatchingToken$1(startToken);
      if (this._tokenMatchesIdentifier$1(next) && next._next.type === C.TokenType_MD7) {
        afterParameters = this._skipFormalParameterList$1(next._next);
        if (afterParameters != null && afterParameters.matchesAny$1([C.TokenType_s8I, C.TokenType_kC8]))
          return this._skipPastMatchingToken$1(startToken);
      }
      afterType = this._skipFinalConstVarOrType$1(next);
      if (afterType == null)
        return;
      if (this._skipSimpleIdentifier$1(afterType) == null)
        return;
      return this._skipPastMatchingToken$1(startToken);
    },
    _skipPastMatchingToken$1: function(startToken) {
      var closeParen;
      if (!startToken.$isBeginToken)
        return;
      closeParen = startToken.endToken;
      if (closeParen == null)
        return;
      return closeParen._next;
    },
    _skipPrefixedIdentifier$1: function(startToken) {
      var token = this._skipSimpleIdentifier$1(startToken);
      if (token == null)
        return;
      else if (token.type !== C.TokenType_B6W)
        return token;
      return this._skipSimpleIdentifier$1(token._next);
    },
    _skipReturnType$1: function(startToken) {
      if (this._tokenMatchesKeyword$2(startToken, C.Keyword_void_false_VOID_30))
        return startToken._next;
      else
        return this._skipTypeName$1(startToken);
    },
    _skipSimpleIdentifier$1: function(startToken) {
      var t1 = startToken.type;
      if (t1 !== C.TokenType_nrs)
        t1 = t1 === C.TokenType_hLM && H.interceptedTypeCast(startToken, "$isKeywordToken").keyword.get$isPseudoKeyword();
      else
        t1 = true;
      if (t1)
        return startToken._next;
      return;
    },
    _skipStringInterpolation$1: function(startToken) {
      var type, token, t1, bracketNestingLevel;
      type = startToken.type;
      token = startToken;
      while (true) {
        t1 = type === C.TokenType_fld;
        if (!(t1 || type === C.TokenType_RG0))
          break;
        if (t1) {
          token = token._next;
          type = token.type;
          for (bracketNestingLevel = 1; bracketNestingLevel > 0;) {
            if (type === C.TokenType_EOF_Imi)
              return;
            else if (type === C.TokenType_qFj)
              ++bracketNestingLevel;
            else if (type === C.TokenType_33I)
              --bracketNestingLevel;
            else if (type === C.TokenType_iDZ) {
              token = this._skipStringLiteral$1(token);
              if (token == null)
                return;
            } else
              token = token._next;
            type = token.type;
          }
          token = token._next;
          token.type;
        } else {
          token = token._next;
          if (token.type !== C.TokenType_nrs)
            return;
          token = token._next;
        }
        type = token.type;
        if (type === C.TokenType_iDZ) {
          token = token._next;
          type = token.type;
        }
      }
      return token;
    },
    _skipStringLiteral$1: function(startToken) {
      var token, type;
      token = startToken;
      while (true) {
        if (!(token != null && token.type === C.TokenType_iDZ))
          break;
        token = token._next;
        type = token.type;
        if (type === C.TokenType_fld || type === C.TokenType_RG0)
          token = this._skipStringInterpolation$1(token);
      }
      if (token == null ? startToken == null : token === startToken)
        return;
      return token;
    },
    _skipTypeArgumentList$1: function(startToken) {
      var token, t1, second;
      if (startToken.type !== C.TokenType_KoJ)
        return;
      token = this._skipTypeName$1(startToken._next);
      if (token == null)
        return;
      for (; t1 = token.type, t1 === C.TokenType_s8I;) {
        token = this._skipTypeName$1(token._next);
        if (token == null)
          return;
      }
      if (t1 === C.TokenType_Bac)
        return token._next;
      else if (t1 === C.TokenType_WFo) {
        second = new K.Token(C.TokenType_Bac, 0, null, null);
        second.offset = token.offset + 1;
        second._next = token._next;
        return second;
      }
      return;
    },
    _skipTypeName$1: function(startToken) {
      var token = this._skipPrefixedIdentifier$1(startToken);
      if (token == null)
        return;
      return token.type === C.TokenType_KoJ ? this._skipTypeArgumentList$1(token) : token;
    },
    _skipTypeParameterList$1: function(startToken) {
      var next, depth, t1, fakeEquals;
      if (startToken.type !== C.TokenType_KoJ)
        return;
      next = startToken._next;
      for (depth = 1; depth > 0;) {
        t1 = next.type;
        if (t1 === C.TokenType_EOF_Imi)
          return;
        else if (t1 === C.TokenType_KoJ)
          ++depth;
        else if (t1 === C.TokenType_Bac)
          --depth;
        else if (t1 === C.TokenType_juX) {
          if (depth === 1) {
            fakeEquals = new K.Token(C.TokenType_Azp, 0, null, null);
            fakeEquals.offset = next.offset + 2;
            fakeEquals._next = next._next;
            return fakeEquals;
          }
          --depth;
        } else if (t1 === C.TokenType_WFo)
          depth -= 2;
        else if (t1 === C.TokenType_y9W) {
          if (depth < 2)
            return;
          else if (depth === 2) {
            fakeEquals = new K.Token(C.TokenType_Azp, 0, null, null);
            fakeEquals.offset = next.offset + 2;
            fakeEquals._next = next._next;
            return fakeEquals;
          }
          depth -= 2;
        }
        next = next._next;
      }
      return next;
    },
    _tokenMatchesIdentifier$1: function(token) {
      var t1 = token.type;
      if (t1 !== C.TokenType_nrs)
        t1 = t1 === C.TokenType_hLM && H.interceptedTypeCast(token, "$isKeywordToken").keyword.get$isPseudoKeyword();
      else
        t1 = true;
      return t1;
    },
    _tokenMatchesKeyword$2: function(token, keyword) {
      return J.$eq(token.get$type(), C.TokenType_hLM) && J.$eq(H.interceptedTypeCast(token, "$isKeywordToken").keyword, keyword);
    },
    _translateCharacter$3: function(builder, lexeme, index) {
      var t1, currentChar, t2, currentIndex, t3, firstDigit, secondDigit, digitCount, value, t4, thirdDigit, fourthDigit;
      if (index < 0)
        H.throwExpression(P.RangeError$value(index));
      t1 = lexeme.length;
      if (index >= t1)
        H.throwExpression(P.RangeError$value(index));
      currentChar = lexeme.charCodeAt(index);
      if (currentChar !== 92) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(currentChar);
        t1._contents += t2;
        return index + 1;
      }
      currentIndex = index + 1;
      if (currentIndex >= t1)
        return t1;
      if (currentIndex < 0)
        H.throwExpression(P.RangeError$value(currentIndex));
      currentChar = lexeme.charCodeAt(currentIndex);
      if (currentChar === 110) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(10);
        t1._contents += t2;
      } else if (currentChar === 114) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(13);
        t1._contents += t2;
      } else if (currentChar === 102) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(12);
        t1._contents += t2;
      } else if (currentChar === 98) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(8);
        t1._contents += t2;
      } else if (currentChar === 116) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(9);
        t1._contents += t2;
      } else if (currentChar === 118) {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(11);
        t1._contents += t2;
      } else if (currentChar === 120) {
        t2 = currentIndex + 2;
        if (t2 >= t1) {
          this._reportErrorForToken$3(C.ParserErrorCode_89t, this._currentToken, []);
          return t1;
        }
        t3 = currentIndex + 1;
        if (t3 < 0)
          H.throwExpression(P.RangeError$value(t3));
        if (t3 >= t1)
          H.throwExpression(P.RangeError$value(t3));
        firstDigit = lexeme.charCodeAt(t3);
        if (t2 < 0)
          H.throwExpression(P.RangeError$value(t2));
        secondDigit = lexeme.charCodeAt(t2);
        if (!this._isHexDigit$1(firstDigit) || !this._isHexDigit$1(secondDigit))
          this._reportErrorForToken$3(C.ParserErrorCode_89t, this._currentToken, []);
        else {
          t1 = L.Character_digit(firstDigit, 16);
          t2 = L.Character_digit(secondDigit, 16);
          t3 = builder.sb;
          t2 = H.Primitives_stringFromCharCode((t1 << 4 >>> 0) + t2);
          t3._contents += t2;
        }
        return currentIndex + 3;
      } else if (currentChar === 117) {
        ++currentIndex;
        if (currentIndex >= t1) {
          this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
          return t1;
        }
        if (currentIndex < 0)
          H.throwExpression(P.RangeError$value(currentIndex));
        currentChar = lexeme.charCodeAt(currentIndex);
        if (currentChar === 123) {
          ++currentIndex;
          if (currentIndex >= t1) {
            this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
            return t1;
          }
          if (currentIndex < 0)
            H.throwExpression(P.RangeError$value(currentIndex));
          currentChar = lexeme.charCodeAt(currentIndex);
          for (digitCount = 0, value = 0; currentChar !== 125;) {
            if (!this._isHexDigit$1(currentChar)) {
              this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
              ++currentIndex;
              while (true) {
                if (currentIndex < t1) {
                  if (currentIndex < 0)
                    H.throwExpression(P.RangeError$value(currentIndex));
                  if (currentIndex >= t1)
                    H.throwExpression(P.RangeError$value(currentIndex));
                  t2 = lexeme.charCodeAt(currentIndex) !== 125;
                } else
                  t2 = false;
                if (!t2)
                  break;
                ++currentIndex;
              }
              return currentIndex + 1;
            }
            ++digitCount;
            value = (value << 4 >>> 0) + L.Character_digit(currentChar, 16);
            ++currentIndex;
            if (currentIndex >= t1) {
              this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
              return t1;
            }
            if (currentIndex < 0)
              H.throwExpression(P.RangeError$value(currentIndex));
            currentChar = lexeme.charCodeAt(currentIndex);
          }
          if (digitCount < 1 || digitCount > 6)
            this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
          t1 = currentIndex + 1;
          this._appendScalarValue$5(builder, C.JSString_methods.substring$2(lexeme, index, t1), value, index, currentIndex);
          return t1;
        } else {
          t2 = currentIndex + 3;
          if (t2 >= t1) {
            this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
            return t1;
          }
          t3 = currentIndex + 1;
          if (t3 < 0)
            H.throwExpression(P.RangeError$value(t3));
          if (t3 >= t1)
            H.throwExpression(P.RangeError$value(t3));
          secondDigit = lexeme.charCodeAt(t3);
          t4 = currentIndex + 2;
          if (t4 < 0)
            H.throwExpression(P.RangeError$value(t4));
          if (t4 >= t1)
            H.throwExpression(P.RangeError$value(t4));
          thirdDigit = lexeme.charCodeAt(t4);
          if (t2 < 0)
            H.throwExpression(P.RangeError$value(t2));
          fourthDigit = lexeme.charCodeAt(t2);
          if (!this._isHexDigit$1(currentChar) || !this._isHexDigit$1(secondDigit) || !this._isHexDigit$1(thirdDigit) || !this._isHexDigit$1(fourthDigit))
            this._reportErrorForToken$3(C.ParserErrorCode_AiQ, this._currentToken, []);
          else
            this._appendScalarValue$5(builder, C.JSString_methods.substring$2(lexeme, index, t3), (((L.Character_digit(currentChar, 16) << 4 >>> 0) + L.Character_digit(secondDigit, 16) << 4 >>> 0) + L.Character_digit(thirdDigit, 16) << 4 >>> 0) + L.Character_digit(fourthDigit, 16), index, t2);
          return currentIndex + 4;
        }
      } else {
        t1 = builder.sb;
        t2 = H.Primitives_stringFromCharCode(currentChar);
        t1._contents += t2;
      }
      return currentIndex + 1;
    },
    _validateFormalParameterList$1: function(parameterList) {
      var t1, t2, parameter, t3;
      for (t1 = parameterList._parameters, t1 = t1.get$iterator(t1), t2 = this._source; t1.moveNext$0();) {
        parameter = t1._current;
        if (!!J.getInterceptor(parameter).$isFieldFormalParameter) {
          t3 = parameter._identifier;
          this._reportError$1(U.AnalysisError$con2(t2, t3.get$offset(), J.get$length$as(t3), C.ParserErrorCode_izs, []));
        }
      }
    },
    _validateModifiersForConstructor$1: function(modifiers) {
      var t1, externalKeyword, constKeyword, factoryKeyword;
      t1 = modifiers.abstractKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_4MH, t1, []);
      t1 = modifiers.finalKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_U44, t1, []);
      t1 = modifiers.staticKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_L9F, t1, []);
      t1 = modifiers.varKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_IAC, t1, []);
      externalKeyword = modifiers.externalKeyword;
      constKeyword = modifiers.constKeyword;
      factoryKeyword = modifiers.factoryKeyword;
      t1 = externalKeyword != null;
      if (t1 && constKeyword != null && constKeyword.offset < externalKeyword.offset)
        this._reportErrorForToken$3(C.ParserErrorCode_st1, externalKeyword, []);
      if (t1 && factoryKeyword != null && factoryKeyword.offset < externalKeyword.offset)
        this._reportErrorForToken$3(C.ParserErrorCode_k8F, externalKeyword, []);
      return constKeyword;
    },
    _validateModifiersForField$1: function(modifiers) {
      var t1, staticKeyword, constKeyword, finalKeyword, varKeyword;
      if (modifiers.abstractKeyword != null)
        this._reportErrorForToken$3(C.ParserErrorCode_4MH, this._currentToken, []);
      t1 = modifiers.externalKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_bbS, t1, []);
      t1 = modifiers.factoryKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_ot1, t1, []);
      staticKeyword = modifiers.staticKeyword;
      constKeyword = modifiers.constKeyword;
      finalKeyword = modifiers.finalKeyword;
      varKeyword = modifiers.varKeyword;
      if (constKeyword != null) {
        if (finalKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_gQW, finalKeyword, []);
        if (varKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_2nU, varKeyword, []);
        if (staticKeyword != null && constKeyword.offset < staticKeyword.offset)
          this._reportErrorForToken$3(C.ParserErrorCode_XPt, staticKeyword, []);
      } else if (finalKeyword != null) {
        if (varKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_mZp, varKeyword, []);
        if (staticKeyword != null && finalKeyword.offset < staticKeyword.offset)
          this._reportErrorForToken$3(C.ParserErrorCode_52A, staticKeyword, []);
      } else if (varKeyword != null && staticKeyword != null && varKeyword.offset < staticKeyword.offset)
        this._reportErrorForToken$3(C.ParserErrorCode_dFE, staticKeyword, []);
      return this._lexicallyFirst$1([constKeyword, finalKeyword, varKeyword]);
    },
    _validateModifiersForGetterOrSetterOrMethod$1: function(modifiers) {
      var t1, externalKeyword, staticKeyword;
      if (modifiers.abstractKeyword != null)
        this._reportErrorForToken$3(C.ParserErrorCode_4MH, this._currentToken, []);
      t1 = modifiers.constKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_yzJ, t1, []);
      t1 = modifiers.factoryKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_ot1, t1, []);
      t1 = modifiers.finalKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_QOI, t1, []);
      t1 = modifiers.varKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_aNH, t1, []);
      externalKeyword = modifiers.externalKeyword;
      staticKeyword = modifiers.staticKeyword;
      if (externalKeyword != null && staticKeyword != null && staticKeyword.offset < externalKeyword.offset)
        this._reportErrorForToken$3(C.ParserErrorCode_ato0, externalKeyword, []);
    },
    _validateModifiersForOperator$1: function(modifiers) {
      var t1;
      if (modifiers.abstractKeyword != null)
        this._reportErrorForToken$3(C.ParserErrorCode_4MH, this._currentToken, []);
      t1 = modifiers.constKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_yzJ, t1, []);
      t1 = modifiers.factoryKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_ot1, t1, []);
      t1 = modifiers.finalKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_QOI, t1, []);
      t1 = modifiers.staticKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_i78, t1, []);
      t1 = modifiers.varKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_aNH, t1, []);
    },
    _validateModifiersForTopLevelDeclaration$1: function(modifiers) {
      var t1 = modifiers.factoryKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_wMa, t1, []);
      t1 = modifiers.staticKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_xEW, t1, []);
    },
    _validateModifiersForTopLevelFunction$1: function(modifiers) {
      var t1;
      this._validateModifiersForTopLevelDeclaration$1(modifiers);
      if (modifiers.abstractKeyword != null)
        this._reportErrorForToken$3(C.ParserErrorCode_H37, this._currentToken, []);
      t1 = modifiers.constKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_eWW, t1, []);
      t1 = modifiers.finalKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_I1c, t1, []);
      t1 = modifiers.varKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_aNH, t1, []);
    },
    _validateModifiersForTopLevelVariable$1: function(modifiers) {
      var t1, constKeyword, finalKeyword, varKeyword;
      this._validateModifiersForTopLevelDeclaration$1(modifiers);
      if (modifiers.abstractKeyword != null)
        this._reportErrorForToken$3(C.ParserErrorCode_8FR, this._currentToken, []);
      t1 = modifiers.externalKeyword;
      if (t1 != null)
        this._reportErrorForToken$3(C.ParserErrorCode_bbS, t1, []);
      constKeyword = modifiers.constKeyword;
      finalKeyword = modifiers.finalKeyword;
      varKeyword = modifiers.varKeyword;
      if (constKeyword != null) {
        if (finalKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_gQW, finalKeyword, []);
        if (varKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_2nU, varKeyword, []);
      } else if (finalKeyword != null)
        if (varKeyword != null)
          this._reportErrorForToken$3(C.ParserErrorCode_mZp, varKeyword, []);
      return this._lexicallyFirst$1([constKeyword, finalKeyword, varKeyword]);
    },
    static: {"^": "Parser_ASYNC,Parser__AWAIT,Parser__HIDE,Parser__OF,Parser__ON,Parser__NATIVE,Parser__SHOW,Parser_SYNC,Parser__YIELD"}
  },
  ParserErrorCode: {
    "^": "Enum;errorSeverity,message<,correction<,name,ordinal",
    get$type: function() {
      return C.ErrorType_JmU;
    },
    $isParserErrorCode: true,
    $asEnum: function() {
      return [S.ParserErrorCode];
    },
    static: {"^": "ParserErrorCode_ABSTRACT_CLASS_MEMBER,ParserErrorCode_ABSTRACT_ENUM,ParserErrorCode_ABSTRACT_STATIC_METHOD,ParserErrorCode_ABSTRACT_TOP_LEVEL_FUNCTION,ParserErrorCode_ABSTRACT_TOP_LEVEL_VARIABLE,ParserErrorCode_ABSTRACT_TYPEDEF,ParserErrorCode_ASSERT_DOES_NOT_TAKE_ASSIGNMENT,ParserErrorCode_ASSERT_DOES_NOT_TAKE_CASCADE,ParserErrorCode_ASSERT_DOES_NOT_TAKE_THROW,ParserErrorCode_ASSERT_DOES_NOT_TAKE_RETHROW,ParserErrorCode_BREAK_OUTSIDE_OF_LOOP,ParserErrorCode_CONST_AND_FINAL,ParserErrorCode_CONST_AND_VAR,ParserErrorCode_CONST_CLASS,ParserErrorCode_CONST_CONSTRUCTOR_WITH_BODY,ParserErrorCode_CONST_ENUM,ParserErrorCode_CONST_FACTORY,ParserErrorCode_CONST_METHOD,ParserErrorCode_CONST_TYPEDEF,ParserErrorCode_CONSTRUCTOR_WITH_RETURN_TYPE,ParserErrorCode_CONTINUE_OUTSIDE_OF_LOOP,ParserErrorCode_CONTINUE_WITHOUT_LABEL_IN_CASE,ParserErrorCode_DEFERRED_IMPORTS_NOT_SUPPORTED,ParserErrorCode_DEPRECATED_CLASS_TYPE_ALIAS,ParserErrorCode_DIRECTIVE_AFTER_DECLARATION,ParserErrorCode_DUPLICATE_LABEL_IN_SWITCH_STATEMENT,ParserErrorCode_DUPLICATED_MODIFIER,ParserErrorCode_EMPTY_ENUM_BODY,ParserErrorCode_EQUALITY_CANNOT_BE_EQUALITY_OPERAND,ParserErrorCode_EXPECTED_CASE_OR_DEFAULT,ParserErrorCode_EXPECTED_CLASS_MEMBER,ParserErrorCode_EXPECTED_EXECUTABLE,ParserErrorCode_EXPECTED_LIST_OR_MAP_LITERAL,ParserErrorCode_EXPECTED_STRING_LITERAL,ParserErrorCode_EXPECTED_TOKEN,ParserErrorCode_EXPECTED_TYPE_NAME,ParserErrorCode_EXPORT_DIRECTIVE_AFTER_PART_DIRECTIVE,ParserErrorCode_EXTERNAL_AFTER_CONST,ParserErrorCode_EXTERNAL_AFTER_FACTORY,ParserErrorCode_EXTERNAL_AFTER_STATIC,ParserErrorCode_EXTERNAL_CLASS,ParserErrorCode_EXTERNAL_CONSTRUCTOR_WITH_BODY,ParserErrorCode_EXTERNAL_ENUM,ParserErrorCode_EXTERNAL_FIELD,ParserErrorCode_EXTERNAL_GETTER_WITH_BODY,ParserErrorCode_EXTERNAL_METHOD_WITH_BODY,ParserErrorCode_EXTERNAL_OPERATOR_WITH_BODY,ParserErrorCode_EXTERNAL_SETTER_WITH_BODY,ParserErrorCode_EXTERNAL_TYPEDEF,ParserErrorCode_FACTORY_TOP_LEVEL_DECLARATION,ParserErrorCode_FACTORY_WITHOUT_BODY,ParserErrorCode_FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR,ParserErrorCode_FINAL_AND_VAR,ParserErrorCode_FINAL_CLASS,ParserErrorCode_FINAL_CONSTRUCTOR,ParserErrorCode_FINAL_ENUM,ParserErrorCode_FINAL_METHOD,ParserErrorCode_FINAL_TYPEDEF,ParserErrorCode_FUNCTION_TYPED_PARAMETER_VAR,ParserErrorCode_GETTER_IN_FUNCTION,ParserErrorCode_GETTER_WITH_PARAMETERS,ParserErrorCode_ILLEGAL_ASSIGNMENT_TO_NON_ASSIGNABLE,ParserErrorCode_IMPLEMENTS_BEFORE_EXTENDS,ParserErrorCode_IMPLEMENTS_BEFORE_WITH,ParserErrorCode_IMPORT_DIRECTIVE_AFTER_PART_DIRECTIVE,ParserErrorCode_INITIALIZED_VARIABLE_IN_FOR_EACH,ParserErrorCode_INVALID_AWAIT_IN_FOR,ParserErrorCode_INVALID_CODE_POINT,ParserErrorCode_INVALID_COMMENT_REFERENCE,ParserErrorCode_INVALID_HEX_ESCAPE,ParserErrorCode_INVALID_OPERATOR,ParserErrorCode_INVALID_OPERATOR_FOR_SUPER,ParserErrorCode_INVALID_STAR_AFTER_ASYNC,ParserErrorCode_INVALID_SYNC,ParserErrorCode_INVALID_UNICODE_ESCAPE,ParserErrorCode_LIBRARY_DIRECTIVE_NOT_FIRST,ParserErrorCode_LOCAL_FUNCTION_DECLARATION_MODIFIER,ParserErrorCode_MISSING_ASSIGNABLE_SELECTOR,ParserErrorCode_MISSING_CATCH_OR_FINALLY,ParserErrorCode_MISSING_CLASS_BODY,ParserErrorCode_MISSING_CLOSING_PARENTHESIS,ParserErrorCode_MISSING_CONST_FINAL_VAR_OR_TYPE,ParserErrorCode_MISSING_ENUM_BODY,ParserErrorCode_MISSING_EXPRESSION_IN_THROW,ParserErrorCode_MISSING_FUNCTION_BODY,ParserErrorCode_MISSING_FUNCTION_PARAMETERS,ParserErrorCode_MISSING_GET,ParserErrorCode_MISSING_IDENTIFIER,ParserErrorCode_MISSING_KEYWORD_OPERATOR,ParserErrorCode_MISSING_NAME_IN_LIBRARY_DIRECTIVE,ParserErrorCode_MISSING_NAME_IN_PART_OF_DIRECTIVE,ParserErrorCode_MISSING_PREFIX_IN_DEFERRED_IMPORT,ParserErrorCode_MISSING_STAR_AFTER_SYNC,ParserErrorCode_MISSING_STATEMENT,ParserErrorCode_MISSING_TERMINATOR_FOR_PARAMETER_GROUP,ParserErrorCode_MISSING_TYPEDEF_PARAMETERS,ParserErrorCode_MISSING_VARIABLE_IN_FOR_EACH,ParserErrorCode_MIXED_PARAMETER_GROUPS,ParserErrorCode_MULTIPLE_EXTENDS_CLAUSES,ParserErrorCode_MULTIPLE_IMPLEMENTS_CLAUSES,ParserErrorCode_MULTIPLE_LIBRARY_DIRECTIVES,ParserErrorCode_MULTIPLE_NAMED_PARAMETER_GROUPS,ParserErrorCode_MULTIPLE_PART_OF_DIRECTIVES,ParserErrorCode_MULTIPLE_POSITIONAL_PARAMETER_GROUPS,ParserErrorCode_MULTIPLE_VARIABLES_IN_FOR_EACH,ParserErrorCode_MULTIPLE_WITH_CLAUSES,ParserErrorCode_NAMED_FUNCTION_EXPRESSION,ParserErrorCode_NAMED_PARAMETER_OUTSIDE_GROUP,ParserErrorCode_NATIVE_CLAUSE_IN_NON_SDK_CODE,ParserErrorCode_NATIVE_FUNCTION_BODY_IN_NON_SDK_CODE,ParserErrorCode_NON_CONSTRUCTOR_FACTORY,ParserErrorCode_NON_IDENTIFIER_LIBRARY_NAME,ParserErrorCode_NON_PART_OF_DIRECTIVE_IN_PART,ParserErrorCode_NON_USER_DEFINABLE_OPERATOR,ParserErrorCode_NORMAL_BEFORE_OPTIONAL_PARAMETERS,ParserErrorCode_POSITIONAL_AFTER_NAMED_ARGUMENT,ParserErrorCode_POSITIONAL_PARAMETER_OUTSIDE_GROUP,ParserErrorCode_REDIRECTION_IN_NON_FACTORY_CONSTRUCTOR,ParserErrorCode_SETTER_IN_FUNCTION,ParserErrorCode_STATIC_AFTER_CONST,ParserErrorCode_STATIC_AFTER_FINAL,ParserErrorCode_STATIC_AFTER_VAR,ParserErrorCode_STATIC_CONSTRUCTOR,ParserErrorCode_STATIC_GETTER_WITHOUT_BODY,ParserErrorCode_STATIC_OPERATOR,ParserErrorCode_STATIC_SETTER_WITHOUT_BODY,ParserErrorCode_STATIC_TOP_LEVEL_DECLARATION,ParserErrorCode_SWITCH_HAS_CASE_AFTER_DEFAULT_CASE,ParserErrorCode_SWITCH_HAS_MULTIPLE_DEFAULT_CASES,ParserErrorCode_TOP_LEVEL_OPERATOR,ParserErrorCode_UNEXPECTED_TERMINATOR_FOR_PARAMETER_GROUP,ParserErrorCode_UNEXPECTED_TOKEN,ParserErrorCode_WITH_BEFORE_EXTENDS,ParserErrorCode_WITH_WITHOUT_EXTENDS,ParserErrorCode_WRONG_SEPARATOR_FOR_NAMED_PARAMETER,ParserErrorCode_WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER,ParserErrorCode_WRONG_TERMINATOR_FOR_PARAMETER_GROUP,ParserErrorCode_VAR_AND_TYPE,ParserErrorCode_VAR_AS_TYPE_NAME,ParserErrorCode_VAR_CLASS,ParserErrorCode_VAR_ENUM,ParserErrorCode_VAR_RETURN_TYPE,ParserErrorCode_VAR_TYPEDEF,ParserErrorCode_VOID_PARAMETER,ParserErrorCode_VOID_VARIABLE,ParserErrorCode_values"}
  },
  Parser_SyntheticKeywordToken: {
    "^": "KeywordToken;keyword,type,offset,previous,_next",
    get$length: function(_) {
      return 0;
    }
  }
}],
["engine.scanner", "package:analyzer/src/generated/scanner.dart", , K, {
  "^": "",
  BeginToken: {
    "^": "Token;endToken<,type,offset,previous,_next",
    BeginToken$2: function(type, offset) {
    },
    $isBeginToken: true,
    static: {BeginToken$: function(type, offset) {
        var t1 = new K.BeginToken(null, type, 0, null, null);
        t1.offset = offset;
        t1.BeginToken$2(type, offset);
        return t1;
      }}
  },
  BeginTokenWithComment: {
    "^": "BeginToken;_precedingComment,endToken,type,offset,previous,_next",
    get$precedingComments: function() {
      return this._precedingComment;
    }
  },
  CharSequenceReader: {
    "^": "Object;_sequence,_stringLength,_charOffset",
    advance$0: function() {
      var t1, t2;
      t1 = this._charOffset + 1;
      t2 = this._stringLength;
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 >= t2)
        return -1;
      this._charOffset = t1;
      return J.codeUnitAt$1$s(this._sequence, t1);
    },
    get$offset: function() {
      return this._charOffset;
    },
    getString$2: function(start, endDelta) {
      return J.substring$2$s(this._sequence, start, this._charOffset + 1 + endDelta);
    },
    peek$0: function() {
      var t1, t2, t3, t4;
      t1 = this._charOffset;
      t2 = this._sequence;
      t3 = J.getInterceptor$as(t2);
      t4 = t3.get$length(t2);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (t1 + 1 >= t4)
        return -1;
      return t3.codeUnitAt$1(t2, this._charOffset + 1);
    }
  },
  Keyword: {
    "^": "Enum;syntax<,isPseudoKeyword<,name,ordinal",
    $isKeyword: true,
    $asEnum: function() {
      return [K.Keyword];
    },
    static: {"^": "Keyword_ASSERT,Keyword_BREAK,Keyword_CASE,Keyword_CATCH,Keyword_CLASS,Keyword_CONST,Keyword_CONTINUE,Keyword_DEFAULT,Keyword_DO,Keyword_ELSE,Keyword_ENUM,Keyword_EXTENDS,Keyword_FALSE,Keyword_FINAL,Keyword_FINALLY,Keyword_FOR,Keyword_IF,Keyword_IN,Keyword_IS,Keyword_NEW,Keyword_NULL,Keyword_RETHROW,Keyword_RETURN,Keyword_SUPER,Keyword_SWITCH,Keyword_THIS,Keyword_THROW,Keyword_TRUE,Keyword_TRY,Keyword_VAR,Keyword_VOID,Keyword_WHILE,Keyword_WITH,Keyword_ABSTRACT,Keyword_AS,Keyword_DEFERRED,Keyword_DYNAMIC,Keyword_EXPORT,Keyword_EXTERNAL,Keyword_FACTORY,Keyword_GET,Keyword_IMPLEMENTS,Keyword_IMPORT,Keyword_LIBRARY,Keyword_OPERATOR,Keyword_PART,Keyword_SET,Keyword_STATIC,Keyword_TYPEDEF,Keyword_values,Keyword_keywords", Keyword__createKeywordMap: function() {
        var result, t1, keyword;
        result = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, K.Keyword);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_Z1y, 49, 0, null), [H.getTypeArgumentByIndex(C.List_Z1y, 0)]); t1.moveNext$0();) {
          keyword = t1._current;
          result.$indexSet(0, keyword.get$syntax(), keyword);
        }
        return result;
      }}
  },
  KeywordState: {
    "^": "Object;_table,_keyword",
    keyword$0: [function() {
      return this._keyword;
    }, "call$0", "get$keyword", 0, 0, 18],
    $isKeywordState: true,
    static: {"^": "KeywordState__EMPTY_TABLE,KeywordState_KEYWORD_STATE", KeywordState__computeKeywordStateTable: function(start, strings, offset, $length) {
        var result, t1, t2, t3, i, chunk, chunkStart, isLeaf, t4, t5, c;
        result = Array(26);
        result.$builtinTypeInfo = [K.KeywordState];
        for (t1 = offset + $length, t2 = strings.length, t3 = start + 1, i = offset, chunk = 0, chunkStart = -1, isLeaf = false; i < t1; ++i) {
          if (i < 0 || i >= t2)
            return H.ioore(strings, i);
          t4 = strings[i];
          t5 = t4.length;
          if (t5 === start)
            isLeaf = true;
          if (t5 > start) {
            t4.toString;
            if (start >= t5)
              H.throwExpression(P.RangeError$value(start));
            c = t4.charCodeAt(start);
            if (chunk !== c) {
              if (chunkStart !== -1) {
                t4 = chunk - 97;
                t5 = K.KeywordState__computeKeywordStateTable(t3, strings, chunkStart, i - chunkStart);
                if (t4 < 0 || t4 >= 26)
                  return H.ioore(result, t4);
                result[t4] = t5;
              }
              chunkStart = i;
              chunk = c;
            }
          }
        }
        if (chunkStart !== -1) {
          t4 = chunk - 97;
          t1 = K.KeywordState__computeKeywordStateTable(t3, strings, chunkStart, t1 - chunkStart);
          if (t4 < 0 || t4 >= 26)
            return H.ioore(result, t4);
          result[t4] = t1;
        } else {
          t1 = $.get$KeywordState__EMPTY_TABLE();
          if (offset < 0 || offset >= t2)
            return H.ioore(strings, offset);
          t2 = strings[offset];
          t1 = new K.KeywordState(t1, null);
          t1._keyword = t2 == null ? null : $.get$Keyword_keywords().$index(0, t2);
          return t1;
        }
        if (isLeaf) {
          if (offset < 0 || offset >= t2)
            return H.ioore(strings, offset);
          t1 = strings[offset];
          t2 = new K.KeywordState(result, null);
          t2._keyword = t1 == null ? null : $.get$Keyword_keywords().$index(0, t1);
          return t2;
        } else {
          t1 = new K.KeywordState(result, null);
          t1._keyword = null;
          return t1;
        }
      }, KeywordState__createKeywordStateTable: function() {
        var strings, t1, i, t2;
        strings = H.setRuntimeTypeInfo(Array(49), [P.String]);
        for (t1 = strings.length, i = 0; i < 49; ++i) {
          t2 = C.List_Z1y[i];
          if (i >= t1)
            return H.ioore(strings, i);
          strings[i] = t2.syntax;
        }
        H.IterableMixinWorkaround_sortList(strings, null);
        return K.KeywordState__computeKeywordStateTable(0, strings, 0, t1);
      }}
  },
  KeywordToken: {
    "^": "Token;keyword<,type,offset,previous,_next",
    get$lexeme: function() {
      return this.keyword.get$syntax();
    },
    $isKeywordToken: true
  },
  KeywordTokenWithComment: {
    "^": "KeywordToken;_precedingComment,keyword,type,offset,previous,_next",
    get$precedingComments: function() {
      return this._precedingComment;
    }
  },
  Scanner: {
    "^": "Object;source,_reader,_scanner$_errorListener,_preserveComments,_tokens,_tail,_firstComment,_lastComment,_tokenStart,_lineStarts,_groupingStack,_stackEnd,_hasUnmatchedGroups",
    setSourceStart$2: function(line, column) {
      var offset, t1, i;
      offset = this._reader.get$offset();
      if (line < 1 || column < 1 || offset < 0 || line + column - 2 >= offset)
        return;
      for (t1 = this._lineStarts, i = 2; i < line; ++i)
        t1.push(1);
      t1.push(offset - column + 1);
    },
    tokenize$0: function() {
      var instrumentation, tokenCounter, next, t1, eofToken;
      $.get$Instrumentation__CURRENT_LOGGER().toString;
      instrumentation = $.get$Instrumentation__NULL_INSTRUMENTATION_BUILDER();
      tokenCounter = 0;
      try {
        t1 = this._reader;
        next = t1.advance$0();
        for (; !J.$eq(next, -1);) {
          tokenCounter = J.$add$ns(tokenCounter, 1);
          next = this.bigSwitch$1(next);
        }
        if (this._firstComment == null) {
          eofToken = new K.Token(C.TokenType_EOF_Imi, 0, null, null);
          eofToken.offset = t1.get$offset() + 1;
        } else {
          t1 = t1.get$offset();
          eofToken = new K.TokenWithComment(this._firstComment, C.TokenType_EOF_Imi, 0, null, null);
          eofToken.offset = t1 + 1;
          this._firstComment = null;
          this._lastComment = null;
        }
        eofToken._next = eofToken;
        eofToken.previous = eofToken;
        t1 = this._tail;
        t1._next = eofToken;
        eofToken.previous = t1;
        this._tail = eofToken;
        if (this._stackEnd >= 0)
          this._hasUnmatchedGroups = true;
        instrumentation.toString;
        t1 = this._tokens._next;
        return t1;
      } finally {
        instrumentation.toString;
      }
    },
    bigSwitch$1: function(next) {
      var t1, peek, start;
      t1 = this._reader;
      this._tokenStart = t1.get$offset();
      if (next === 13) {
        next = t1.advance$0();
        if (next === 10)
          next = t1.advance$0();
        this._lineStarts.push(t1.get$offset());
        return next;
      } else if (next === 10) {
        next = t1.advance$0();
        this._lineStarts.push(t1.get$offset());
        return next;
      } else if (next === 9 || next === 32)
        return t1.advance$0();
      if (next === 114) {
        peek = t1.peek$0();
        if (peek === 34 || peek === 39) {
          start = t1.get$offset();
          return this._tokenizeString$3(t1.advance$0(), start, true);
        }
      }
      if (typeof next !== "number")
        return H.iae(next);
      if (97 <= next && next <= 122)
        return this._tokenizeKeywordOrIdentifier$2(next, true);
      if (65 <= next && next <= 90 || next === 95 || next === 36)
        return this._tokenizeIdentifier$3(next, t1.get$offset(), true);
      if (next === 60)
        return this._tokenizeLessThan$1(next);
      if (next === 62)
        return this._tokenizeGreaterThan$1(next);
      if (next === 61)
        return this._tokenizeEquals$1(next);
      if (next === 33)
        return this._tokenizeExclamation$1(next);
      if (next === 43)
        return this._tokenizePlus$1(next);
      if (next === 45)
        return this._tokenizeMinus$1(next);
      if (next === 42)
        return this._select$3(61, C.TokenType_gMg, C.TokenType_ph7);
      if (next === 37)
        return this._select$3(61, C.TokenType_0, C.TokenType_Nws);
      if (next === 38)
        return this._tokenizeAmpersand$1(next);
      if (next === 124)
        return this._tokenizeBar$1(next);
      if (next === 94)
        return this._select$3(61, C.TokenType_KiG, C.TokenType_ub9);
      if (next === 91)
        return this._tokenizeOpenSquareBracket$1(next);
      if (next === 126)
        return this._tokenizeTilde$1(next);
      if (next === 92) {
        this._appendTokenOfType$1(C.TokenType_6pl);
        return t1.advance$0();
      }
      if (next === 35)
        return this._tokenizeTag$1(next);
      if (next === 40) {
        this._appendBeginToken$1(C.TokenType_MD7);
        return t1.advance$0();
      }
      if (next === 41) {
        this._appendEndToken$2(C.TokenType_kC8, C.TokenType_MD7);
        return t1.advance$0();
      }
      if (next === 44) {
        this._appendTokenOfType$1(C.TokenType_s8I);
        return t1.advance$0();
      }
      if (next === 58) {
        this._appendTokenOfType$1(C.TokenType_chs);
        return t1.advance$0();
      }
      if (next === 59) {
        this._appendTokenOfType$1(C.TokenType_S8h);
        return t1.advance$0();
      }
      if (next === 63) {
        this._appendTokenOfType$1(C.TokenType_B8J);
        return t1.advance$0();
      }
      if (next === 93) {
        this._appendEndToken$2(C.TokenType_58K, C.TokenType_AHF);
        return t1.advance$0();
      }
      if (next === 96) {
        this._appendTokenOfType$1(C.TokenType_cdS);
        return t1.advance$0();
      }
      if (next === 123) {
        this._appendBeginToken$1(C.TokenType_qFj);
        return t1.advance$0();
      }
      if (next === 125) {
        this._appendEndToken$2(C.TokenType_33I, C.TokenType_qFj);
        return t1.advance$0();
      }
      if (next === 47)
        return this._tokenizeSlashOrComment$1(next);
      if (next === 64) {
        this._appendTokenOfType$1(C.TokenType_27D);
        return t1.advance$0();
      }
      if (next === 34 || next === 39)
        return this._tokenizeString$3(next, t1.get$offset(), false);
      if (next === 46)
        return this._tokenizeDotOrNumber$1(next);
      if (next === 48)
        return this._tokenizeHexOrNumber$1(next);
      if (49 <= next && next <= 57)
        return this._tokenizeNumber$1(next);
      if (next === -1)
        return -1;
      this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_mk7, [next]));
      return t1.advance$0();
    },
    _appendBeginToken$1: function(type) {
      var t1, t2, token;
      t1 = this._firstComment;
      t2 = this._tokenStart;
      if (t1 == null)
        token = K.BeginToken$(type, t2);
      else {
        token = new K.BeginTokenWithComment(t1, null, type, 0, null, null);
        token.offset = t2;
        token.BeginToken$2(type, t2);
        this._firstComment = null;
        this._lastComment = null;
      }
      t1 = this._tail;
      t1._next = token;
      token.previous = t1;
      this._tail = token;
      this._groupingStack.push(token);
      ++this._stackEnd;
    },
    _appendCommentToken$2: function(type, value) {
      var t1, t2, t3;
      if (!this._preserveComments)
        return;
      t1 = this._firstComment;
      t2 = this._tokenStart;
      if (t1 == null) {
        t1 = new K.StringToken(null, type, 0, null, null);
        t1.offset = t2;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = value;
        this._firstComment = t1;
        this._lastComment = t1;
      } else {
        t1 = this._lastComment;
        t3 = new K.StringToken(null, type, 0, null, null);
        t3.offset = t2;
        $.get$StringUtilities_INTERNER().toString;
        t3._value = value;
        t1._next = t3;
        t3.previous = t1;
        this._lastComment = t3;
      }
    },
    _appendEndToken$2: function(type, beginType) {
      var t1, t2, token, begin;
      t1 = this._firstComment;
      t2 = this._tokenStart;
      if (t1 == null) {
        token = new K.Token(type, 0, null, null);
        token.offset = t2;
      } else {
        token = new K.TokenWithComment(t1, type, 0, null, null);
        token.offset = t2;
        this._firstComment = null;
        this._lastComment = null;
      }
      t1 = this._tail;
      t1._next = token;
      token.previous = t1;
      this._tail = token;
      t1 = this._stackEnd;
      if (t1 >= 0) {
        t2 = this._groupingStack;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        begin = t2[t1];
        if (begin.type === beginType) {
          begin.endToken = token;
          this._stackEnd = t1 - 1;
          C.JSArray_methods.removeAt$1(t2, t1);
        }
      }
    },
    _appendStringToken$2: function(type, value) {
      var t1, t2, t3;
      t1 = this._firstComment;
      t2 = this._tail;
      t3 = this._tokenStart;
      if (t1 == null) {
        t1 = new K.StringToken(null, type, 0, null, null);
        t1.offset = t3;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = value;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
      } else {
        t1 = new K.StringTokenWithComment(t1, null, type, 0, null, null);
        t1.offset = t3;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = value;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
        this._firstComment = null;
        this._lastComment = null;
      }
    },
    _appendStringTokenWithOffset$3: function(type, value, offset) {
      var t1, t2, t3;
      t1 = this._firstComment;
      t2 = this._tail;
      t3 = this._tokenStart;
      if (t1 == null) {
        t1 = new K.StringToken(null, type, 0, null, null);
        t1.offset = t3 + offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = value;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
      } else {
        t1 = new K.StringTokenWithComment(t1, null, type, 0, null, null);
        t1.offset = t3 + offset;
        $.get$StringUtilities_INTERNER().toString;
        t1._value = value;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
        this._firstComment = null;
        this._lastComment = null;
      }
    },
    _appendTokenOfType$1: function(type) {
      var t1, t2, t3;
      t1 = this._firstComment;
      t2 = this._tail;
      t3 = this._tokenStart;
      if (t1 == null) {
        t1 = new K.Token(type, 0, null, null);
        t1.offset = t3;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
      } else {
        t1 = new K.TokenWithComment(t1, type, 0, null, null);
        t1.offset = t3;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
        this._firstComment = null;
        this._lastComment = null;
      }
    },
    _appendTokenOfTypeWithOffset$2: function(type, offset) {
      var t1, t2;
      t1 = this._firstComment;
      t2 = this._tail;
      if (t1 == null) {
        t1 = new K.Token(type, 0, null, null);
        t1.offset = offset;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
      } else {
        t1 = new K.TokenWithComment(t1, type, 0, null, null);
        t1.offset = offset;
        t2._next = t1;
        t1.previous = t2;
        this._tail = t1;
        this._firstComment = null;
        this._lastComment = null;
      }
    },
    _findTokenMatchingClosingBraceInInterpolationExpression$0: function() {
      var t1, t2, begin, t3;
      for (t1 = this._groupingStack; t2 = this._stackEnd, t2 >= 0;) {
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        begin = t1[t2];
        t3 = begin.type;
        if (t3 === C.TokenType_qFj || t3 === C.TokenType_fld)
          return begin;
        this._hasUnmatchedGroups = true;
        this._stackEnd = t2 - 1;
        C.JSArray_methods.removeAt$1(t1, t2);
      }
      return;
    },
    _select$3: function(choice, yesType, noType) {
      var t1, next;
      t1 = this._reader;
      next = t1.advance$0();
      if (next === choice) {
        this._appendTokenOfType$1(yesType);
        return t1.advance$0();
      } else {
        this._appendTokenOfType$1(noType);
        return next;
      }
    },
    _selectWithOffset$4: function(choice, yesType, noType, offset) {
      var t1, next;
      t1 = this._reader;
      next = t1.advance$0();
      if (next === choice) {
        this._appendTokenOfTypeWithOffset$2(yesType, offset);
        return t1.advance$0();
      } else {
        this._appendTokenOfTypeWithOffset$2(noType, offset);
        return next;
      }
    },
    _tokenizeAmpersand$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (next === 38) {
        this._appendTokenOfType$1(C.TokenType_qbp);
        return t1.advance$0();
      } else if (next === 61) {
        this._appendTokenOfType$1(C.TokenType_s0y);
        return t1.advance$0();
      } else {
        this._appendTokenOfType$1(C.TokenType_0GE);
        return next;
      }
    },
    _tokenizeBar$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (next === 124) {
        this._appendTokenOfType$1(C.TokenType_Mxr);
        return t1.advance$0();
      } else if (next === 61) {
        this._appendTokenOfType$1(C.TokenType_OP6);
        return t1.advance$0();
      } else {
        this._appendTokenOfType$1(C.TokenType_aPH);
        return next;
      }
    },
    _tokenizeDotOrNumber$1: function(next) {
      var t1, start;
      t1 = this._reader;
      start = t1.get$offset();
      next = t1.advance$0();
      if (48 <= next && next <= 57)
        return this._tokenizeFractionPart$2(next, start);
      else if (46 === next)
        return this._select$3(46, C.TokenType_76y, C.TokenType_mGg);
      else {
        this._appendTokenOfType$1(C.TokenType_B6W);
        return next;
      }
    },
    _tokenizeEquals$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (next === 61) {
        this._appendTokenOfType$1(C.TokenType_BLy);
        return t1.advance$0();
      } else if (next === 62) {
        this._appendTokenOfType$1(C.TokenType_iJT);
        return t1.advance$0();
      }
      this._appendTokenOfType$1(C.TokenType_Azp);
      return next;
    },
    _tokenizeExclamation$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (next === 61) {
        this._appendTokenOfType$1(C.TokenType_MMm);
        return t1.advance$0();
      }
      this._appendTokenOfType$1(C.TokenType_kOG);
      return next;
    },
    _tokenizeExponent$1: function(next) {
      var t1, hasDigits;
      if (next === 43 || next === 45)
        next = this._reader.advance$0();
      for (t1 = this._reader, hasDigits = false; true; hasDigits = true) {
        if (48 <= next && next <= 57)
          ;
        else {
          if (!hasDigits)
            this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_Ucj, []));
          return next;
        }
        next = t1.advance$0();
      }
    },
    _tokenizeFractionPart$2: function(next, start) {
      var t1, done, hasDigit;
      $LOOP$0:
        for (t1 = this._reader, done = false, hasDigit = false; !done;) {
          if (typeof next !== "number")
            return H.iae(next);
          if (48 <= next && next <= 57)
            ;
          else if (101 === next || 69 === next) {
            next = this._tokenizeExponent$1(t1.advance$0());
            done = true;
            hasDigit = true;
            continue $LOOP$0;
          } else {
            done = true;
            continue $LOOP$0;
          }
          next = t1.advance$0();
          hasDigit = true;
        }
      if (!hasDigit) {
        this._appendStringToken$2(C.TokenType_j1u, t1.getString$2(start, -2));
        if (46 === next)
          return this._selectWithOffset$4(46, C.TokenType_76y, C.TokenType_mGg, t1.get$offset() - 1);
        this._appendTokenOfTypeWithOffset$2(C.TokenType_B6W, t1.get$offset() - 1);
        return this.bigSwitch$1(next);
      }
      if (typeof next !== "number")
        return next.$lt();
      this._appendStringToken$2(C.TokenType_EQM, t1.getString$2(start, next < 0 ? 0 : -1));
      return next;
    },
    _tokenizeGreaterThan$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (61 === next) {
        this._appendTokenOfType$1(C.TokenType_juX);
        return t1.advance$0();
      } else if (62 === next) {
        next = t1.advance$0();
        if (61 === next) {
          this._appendTokenOfType$1(C.TokenType_y9W);
          return t1.advance$0();
        } else {
          this._appendTokenOfType$1(C.TokenType_WFo);
          return next;
        }
      } else {
        this._appendTokenOfType$1(C.TokenType_Bac);
        return next;
      }
    },
    _tokenizeHex$1: function(next) {
      var t1, t2, hasDigits, t3;
      t1 = this._reader;
      t2 = t1.get$offset();
      for (hasDigits = false; true; hasDigits = true) {
        next = t1.advance$0();
        if (!(48 <= next && next <= 57))
          if (!(65 <= next && next <= 70))
            t3 = 97 <= next && next <= 102;
          else
            t3 = true;
        else
          t3 = true;
        if (t3)
          ;
        else {
          if (!hasDigits)
            this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_EfF, []));
          t3 = next < 0 ? 0 : -1;
          this._appendStringToken$2(C.TokenType_wEo, t1.getString$2(t2 - 1, t3));
          return next;
        }
      }
    },
    _tokenizeHexOrNumber$1: function(next) {
      var t1, x;
      t1 = this._reader;
      x = t1.peek$0();
      if (x === 120 || x === 88) {
        t1.advance$0();
        return this._tokenizeHex$1(x);
      }
      return this._tokenizeNumber$1(next);
    },
    _tokenizeIdentifier$3: function(next, start, allowDollar) {
      var t1, t2;
      t1 = this._reader;
      while (true) {
        if (typeof next !== "number")
          return H.iae(next);
        if (!(97 <= next && next <= 122))
          if (!(65 <= next && next <= 90))
            if (!(48 <= next && next <= 57))
              if (next !== 95)
                t2 = next === 36 && allowDollar;
              else
                t2 = true;
            else
              t2 = true;
          else
            t2 = true;
        else
          t2 = true;
        if (!t2)
          break;
        next = t1.advance$0();
      }
      this._appendStringToken$2(C.TokenType_nrs, t1.getString$2(start, next < 0 ? 0 : -1));
      return next;
    },
    _tokenizeInterpolatedExpression$2: function(next, start) {
      var t1, begin, t2;
      this._appendBeginToken$1(C.TokenType_fld);
      t1 = this._reader;
      next = t1.advance$0();
      for (; next !== -1;)
        if (next === 125) {
          begin = this._findTokenMatchingClosingBraceInInterpolationExpression$0();
          if (begin == null) {
            this._tokenStart = t1.get$offset();
            this._appendTokenOfType$1(C.TokenType_33I);
            next = t1.advance$0();
            this._tokenStart = t1.get$offset();
            return next;
          } else {
            t2 = begin.type;
            if (t2 === C.TokenType_qFj) {
              this._tokenStart = t1.get$offset();
              this._appendEndToken$2(C.TokenType_33I, C.TokenType_qFj);
              next = t1.advance$0();
              this._tokenStart = t1.get$offset();
            } else if (t2 === C.TokenType_fld) {
              this._tokenStart = t1.get$offset();
              this._appendEndToken$2(C.TokenType_33I, C.TokenType_fld);
              next = t1.advance$0();
              this._tokenStart = t1.get$offset();
              return next;
            }
          }
        } else
          next = this.bigSwitch$1(next);
      return next;
    },
    _tokenizeKeywordOrIdentifier$2: function(next, allowDollar) {
      var state, t1, start, t2, t3, t4;
      state = $.get$KeywordState_KEYWORD_STATE();
      t1 = this._reader;
      start = t1.get$offset();
      while (true) {
        t2 = state != null;
        if (t2) {
          if (typeof next !== "number")
            return H.iae(next);
          t3 = 97 <= next && next <= 122;
        } else
          t3 = false;
        if (!t3)
          break;
        t2 = state._table;
        if (typeof next !== "number")
          return next.$sub();
        t3 = next - 97;
        t2.length;
        if (t3 < 0 || t3 >= 26)
          return H.ioore(t2, t3);
        state = t2[t3];
        next = t1.advance$0();
      }
      if (!t2 || state._keyword == null)
        return this._tokenizeIdentifier$3(next, start, allowDollar);
      if (typeof next !== "number")
        return H.iae(next);
      if (!(65 <= next && next <= 90))
        t1 = 48 <= next && next <= 57 || next === 95 || next === 36;
      else
        t1 = true;
      if (t1)
        return this._tokenizeIdentifier$3(next, start, allowDollar);
      else if (next < 128) {
        t1 = state._keyword;
        t2 = this._firstComment;
        t3 = this._tail;
        t4 = this._tokenStart;
        if (t2 == null) {
          t1 = new K.KeywordToken(t1, C.TokenType_hLM, 0, null, null);
          t1.offset = t4;
          t3._next = t1;
          t1.previous = t3;
          this._tail = t1;
        } else {
          t1 = new K.KeywordTokenWithComment(t2, t1, C.TokenType_hLM, 0, null, null);
          t1.offset = t4;
          t3._next = t1;
          t1.previous = t3;
          this._tail = t1;
          this._firstComment = null;
          this._lastComment = null;
        }
        return next;
      } else
        return this._tokenizeIdentifier$3(next, start, allowDollar);
    },
    _tokenizeLessThan$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (61 === next) {
        this._appendTokenOfType$1(C.TokenType_HxB);
        return t1.advance$0();
      } else if (60 === next)
        return this._select$3(61, C.TokenType_mil, C.TokenType_G3y);
      else {
        this._appendTokenOfType$1(C.TokenType_KoJ);
        return next;
      }
    },
    _tokenizeMinus$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (next === 45) {
        this._appendTokenOfType$1(C.TokenType_itQ);
        return t1.advance$0();
      } else if (next === 61) {
        this._appendTokenOfType$1(C.TokenType_M2b);
        return t1.advance$0();
      } else {
        this._appendTokenOfType$1(C.TokenType_O9i);
        return next;
      }
    },
    _tokenizeMultiLineComment$1: function(next) {
      var t1, t2, nesting;
      t1 = this._reader;
      next = t1.advance$0();
      for (t2 = this._lineStarts, nesting = 1; true;)
        if (-1 === next) {
          this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_gc6, []));
          this._appendCommentToken$2(C.TokenType_dMx, t1.getString$2(this._tokenStart, 0));
          return next;
        } else if (42 === next) {
          next = t1.advance$0();
          if (47 === next) {
            --nesting;
            if (0 === nesting) {
              this._appendCommentToken$2(C.TokenType_dMx, t1.getString$2(this._tokenStart, 0));
              return t1.advance$0();
            } else
              next = t1.advance$0();
          }
        } else if (47 === next) {
          next = t1.advance$0();
          if (42 === next) {
            next = t1.advance$0();
            ++nesting;
          }
        } else if (next === 13) {
          next = t1.advance$0();
          if (next === 10)
            next = t1.advance$0();
          t2.push(t1.get$offset());
        } else if (next === 10) {
          t2.push(t1.get$offset());
          next = t1.advance$0();
        } else
          next = t1.advance$0();
    },
    _tokenizeMultiLineRawString$2: function(quoteChar, start) {
      var t1, next, t2;
      t1 = this._reader;
      next = t1.advance$0();
      $outer$0:
        for (t2 = this._lineStarts; next !== -1;) {
          for (; next !== quoteChar;) {
            next = t1.advance$0();
            if (next === -1)
              break $outer$0;
            else if (next === 13) {
              next = t1.advance$0();
              if (next === 10)
                next = t1.advance$0();
              t2.push(t1.get$offset());
            } else if (next === 10) {
              t2.push(t1.get$offset());
              next = t1.advance$0();
            }
          }
          next = t1.advance$0();
          if (next === quoteChar) {
            next = t1.advance$0();
            if (next === quoteChar) {
              this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
              return t1.advance$0();
            }
          }
        }
      this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_SNa, []));
      this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
      return t1.advance$0();
    },
    _tokenizeMultiLineString$3: function(quoteChar, start, raw) {
      var t1, next, t2;
      if (raw)
        return this._tokenizeMultiLineRawString$2(quoteChar, start);
      t1 = this._reader;
      next = t1.advance$0();
      for (t2 = this._lineStarts; next !== -1;) {
        if (next === 36) {
          this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, -1));
          next = this._tokenizeStringInterpolation$1(start);
          this._tokenStart = t1.get$offset();
          start = t1.get$offset();
          continue;
        }
        if (next == null ? quoteChar == null : next === quoteChar) {
          next = t1.advance$0();
          if (next === quoteChar) {
            next = t1.advance$0();
            if (next === quoteChar) {
              this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
              return t1.advance$0();
            }
          }
          continue;
        }
        if (next === 92) {
          next = t1.advance$0();
          if (next === -1)
            break;
          if (next === 13) {
            next = t1.advance$0();
            if (next === 10)
              next = t1.advance$0();
            t2.push(t1.get$offset());
          } else if (next === 10) {
            t2.push(t1.get$offset());
            next = t1.advance$0();
          } else
            next = t1.advance$0();
        } else if (next === 13) {
          next = t1.advance$0();
          if (next === 10)
            next = t1.advance$0();
          t2.push(t1.get$offset());
        } else if (next === 10) {
          t2.push(t1.get$offset());
          next = t1.advance$0();
        } else
          next = t1.advance$0();
      }
      this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_SNa, []));
      if (start === t1.get$offset())
        this._appendStringTokenWithOffset$3(C.TokenType_iDZ, "", 1);
      else
        this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
      return t1.advance$0();
    },
    _tokenizeNumber$1: function(next) {
      var t1, start;
      t1 = this._reader;
      start = t1.get$offset();
      for (; true;) {
        next = t1.advance$0();
        if (48 <= next && next <= 57)
          continue;
        else if (next === 46)
          return this._tokenizeFractionPart$2(t1.advance$0(), start);
        else if (next === 101 || next === 69)
          return this._tokenizeFractionPart$2(next, start);
        else {
          this._appendStringToken$2(C.TokenType_j1u, t1.getString$2(start, next < 0 ? 0 : -1));
          return next;
        }
      }
    },
    _tokenizeOpenSquareBracket$1: function(next) {
      next = this._reader.advance$0();
      if (next === 93)
        return this._select$3(61, C.TokenType_Esm, C.TokenType_WFw);
      else {
        this._appendBeginToken$1(C.TokenType_AHF);
        return next;
      }
    },
    _tokenizePlus$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (43 === next) {
        this._appendTokenOfType$1(C.TokenType_6Vn);
        return t1.advance$0();
      } else if (61 === next) {
        this._appendTokenOfType$1(C.TokenType_VcG);
        return t1.advance$0();
      } else {
        this._appendTokenOfType$1(C.TokenType_Jeb);
        return next;
      }
    },
    _tokenizeSingleLineComment$1: function(next) {
      var t1;
      for (t1 = this._reader; true;) {
        next = t1.advance$0();
        if (-1 === next) {
          this._appendCommentToken$2(C.TokenType_Aec, t1.getString$2(this._tokenStart, 0));
          return next;
        } else if (10 === next || 13 === next) {
          this._appendCommentToken$2(C.TokenType_Aec, t1.getString$2(this._tokenStart, -1));
          return next;
        }
      }
    },
    _tokenizeSingleLineRawString$3: function(next, quoteChar, start) {
      var t1 = this._reader;
      next = t1.advance$0();
      for (; next !== -1;) {
        if (next === quoteChar) {
          this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
          return t1.advance$0();
        } else if (next === 13 || next === 10) {
          this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_SNa, []));
          this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, -1));
          return t1.advance$0();
        }
        next = t1.advance$0();
      }
      this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_SNa, []));
      this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
      return t1.advance$0();
    },
    _tokenizeSingleLineString$3: function(next, quoteChar, start) {
      var t1, t2;
      for (t1 = this._reader; next == null ? quoteChar != null : next !== quoteChar;) {
        if (next === 92)
          next = t1.advance$0();
        else if (next === 36) {
          this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, -1));
          next = this._tokenizeStringInterpolation$1(start);
          this._tokenStart = t1.get$offset();
          start = t1.get$offset();
          continue;
        }
        if (typeof next !== "number")
          return next.$le();
        if (next <= 13)
          t2 = next === 10 || next === 13 || next === -1;
        else
          t2 = false;
        if (t2) {
          this._scanner$_errorListener.onError$1(U.AnalysisError$con2(this.source, t1.get$offset(), 1, C.ScannerErrorCode_SNa, []));
          if (start === t1.get$offset())
            this._appendStringTokenWithOffset$3(C.TokenType_iDZ, "", 1);
          else if (next === -1)
            this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
          else
            this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, -1));
          return t1.advance$0();
        }
        next = t1.advance$0();
      }
      this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, 0));
      return t1.advance$0();
    },
    _tokenizeSlashOrComment$1: function(next) {
      var t1 = this._reader;
      next = t1.advance$0();
      if (42 === next)
        return this._tokenizeMultiLineComment$1(next);
      else if (47 === next)
        return this._tokenizeSingleLineComment$1(next);
      else if (61 === next) {
        this._appendTokenOfType$1(C.TokenType_qz3);
        return t1.advance$0();
      } else {
        this._appendTokenOfType$1(C.TokenType_kOu);
        return next;
      }
    },
    _tokenizeString$3: function(next, start, raw) {
      var t1, next0;
      t1 = this._reader;
      next0 = t1.advance$0();
      if (next === next0) {
        next0 = t1.advance$0();
        if (next === next0)
          return this._tokenizeMultiLineString$3(next, start, raw);
        else {
          this._appendStringToken$2(C.TokenType_iDZ, t1.getString$2(start, -1));
          return next0;
        }
      }
      if (raw)
        return this._tokenizeSingleLineRawString$3(next0, next, start);
      else
        return this._tokenizeSingleLineString$3(next0, next, start);
    },
    _tokenizeStringInterpolation$1: function(start) {
      var t1, next, t2;
      t1 = this._reader;
      this._tokenStart = t1.get$offset();
      next = t1.advance$0();
      if (next === 123)
        return this._tokenizeInterpolatedExpression$2(next, start);
      else {
        this._appendStringTokenWithOffset$3(C.TokenType_RG0, "$", 0);
        if (!(65 <= next && next <= 90))
          t2 = 97 <= next && next <= 122 || next === 95;
        else
          t2 = true;
        if (t2) {
          this._tokenStart = t1.get$offset();
          next = this._tokenizeKeywordOrIdentifier$2(next, false);
        }
        this._tokenStart = t1.get$offset();
        return next;
      }
    },
    _tokenizeTag$1: function(next) {
      var t1 = this._reader;
      if (t1.get$offset() === 0)
        if (t1.peek$0() === 33) {
          do
            next = t1.advance$0();
          while (next !== 10 && next !== 13 && next > 0);
          this._appendStringToken$2(C.TokenType_ato, t1.getString$2(this._tokenStart, 0));
          return next;
        }
      this._appendTokenOfType$1(C.TokenType_mPa);
      return t1.advance$0();
    },
    _tokenizeTilde$1: function(next) {
      next = this._reader.advance$0();
      if (next === 47)
        return this._select$3(61, C.TokenType_8sC, C.TokenType_SSe);
      else {
        this._appendTokenOfType$1(C.TokenType_gmZ);
        return next;
      }
    },
    Scanner$3: function(source, _reader, _errorListener) {
      var t1 = new K.Token(C.TokenType_EOF_Imi, 0, null, null);
      t1.offset = -1;
      this._tokens = t1;
      t1._next = t1;
      t1.previous = t1;
      this._tail = t1;
      this._tokenStart = -1;
      this._lineStarts.push(0);
    },
    static: {Scanner$: function(source, _reader, _errorListener) {
        var t1 = new K.Scanner(source, _reader, _errorListener, true, null, null, null, null, 0, H.setRuntimeTypeInfo([], [P.$int]), H.setRuntimeTypeInfo([], [K.BeginToken]), -1, false);
        t1.Scanner$3(source, _reader, _errorListener);
        return t1;
      }}
  },
  ScannerErrorCode: {
    "^": "Enum;message<,correction<,name,ordinal",
    get$type: function() {
      return C.ErrorType_JmU;
    },
    $isScannerErrorCode: true,
    $asEnum: function() {
      return [K.ScannerErrorCode];
    },
    static: {"^": "ScannerErrorCode_ILLEGAL_CHARACTER,ScannerErrorCode_MISSING_DIGIT,ScannerErrorCode_MISSING_HEX_DIGIT,ScannerErrorCode_MISSING_QUOTE,ScannerErrorCode_UNTERMINATED_MULTI_LINE_COMMENT,ScannerErrorCode_UNTERMINATED_STRING_LITERAL,ScannerErrorCode_values"}
  },
  StringToken: {
    "^": "Token;_value,type,offset,previous,_next",
    get$lexeme: function() {
      return this._value;
    }
  },
  StringTokenWithComment: {
    "^": "StringToken;_precedingComment,_value,type,offset,previous,_next",
    get$precedingComments: function() {
      return this._precedingComment;
    }
  },
  SubSequenceReader: {
    "^": "CharSequenceReader;_offsetDelta,_sequence,_stringLength,_charOffset",
    get$offset: function() {
      return this._offsetDelta + K.CharSequenceReader.prototype.get$offset.call(this);
    },
    getString$2: function(start, endDelta) {
      return K.CharSequenceReader.prototype.getString$2.call(this, start - this._offsetDelta, endDelta);
    }
  },
  SyntheticStringToken: {
    "^": "StringToken;_value,type,offset,previous,_next"
  },
  Token: {
    "^": "Object;type<,offset<,previous<,_next<",
    get$length: function(_) {
      return this.get$lexeme().length;
    },
    get$lexeme: function() {
      return this.type.lexeme;
    },
    get$precedingComments: function() {
      return;
    },
    matchesAny$1: function(types) {
      var t1, t2;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]), t2 = this.type; t1.moveNext$0();)
        if (t2 === t1._current)
          return true;
      return false;
    },
    toString$0: function(_) {
      return this.get$lexeme();
    },
    $isToken: true
  },
  TokenClass: {
    "^": "Enum;precedence,name,ordinal",
    $isTokenClass: true,
    $asEnum: function() {
      return [K.TokenClass];
    },
    static: {"^": "TokenClass_NO_CLASS,TokenClass_ADDITIVE_OPERATOR,TokenClass_ASSIGNMENT_OPERATOR,TokenClass_BITWISE_AND_OPERATOR,TokenClass_BITWISE_OR_OPERATOR,TokenClass_BITWISE_XOR_OPERATOR,TokenClass_CASCADE_OPERATOR,TokenClass_CONDITIONAL_OPERATOR,TokenClass_EQUALITY_OPERATOR,TokenClass_LOGICAL_AND_OPERATOR,TokenClass_LOGICAL_OR_OPERATOR,TokenClass_MULTIPLICATIVE_OPERATOR,TokenClass_RELATIONAL_OPERATOR,TokenClass_SHIFT_OPERATOR,TokenClass_UNARY_POSTFIX_OPERATOR,TokenClass_UNARY_PREFIX_OPERATOR,TokenClass_values"}
  },
  TokenType: {
    "^": "Enum;_tokenClass,lexeme<,name,ordinal",
    get$isOperator: function() {
      return this._tokenClass !== C.TokenClass_0_NO_CLASS_0 && this !== C.TokenType_MD7 && this !== C.TokenType_AHF && this !== C.TokenType_B6W;
    },
    $isTokenType: true,
    $asEnum: function() {
      return [K.TokenType];
    },
    static: {"^": "TokenType_EOF,TokenType_DOUBLE,TokenType_HEXADECIMAL,TokenType_IDENTIFIER,TokenType_INT,TokenType_KEYWORD,TokenType_MULTI_LINE_COMMENT,TokenType_SCRIPT_TAG,TokenType_SINGLE_LINE_COMMENT,TokenType_STRING,TokenType_AMPERSAND,TokenType_AMPERSAND_AMPERSAND,TokenType_AMPERSAND_EQ,TokenType_AT,TokenType_BANG,TokenType_BANG_EQ,TokenType_BAR,TokenType_BAR_BAR,TokenType_BAR_EQ,TokenType_COLON,TokenType_COMMA,TokenType_CARET,TokenType_CARET_EQ,TokenType_CLOSE_CURLY_BRACKET,TokenType_CLOSE_PAREN,TokenType_CLOSE_SQUARE_BRACKET,TokenType_EQ,TokenType_EQ_EQ,TokenType_FUNCTION,TokenType_GT,TokenType_GT_EQ,TokenType_GT_GT,TokenType_GT_GT_EQ,TokenType_HASH,TokenType_INDEX,TokenType_INDEX_EQ,TokenType_IS,TokenType_LT,TokenType_LT_EQ,TokenType_LT_LT,TokenType_LT_LT_EQ,TokenType_MINUS,TokenType_MINUS_EQ,TokenType_MINUS_MINUS,TokenType_OPEN_CURLY_BRACKET,TokenType_OPEN_PAREN,TokenType_OPEN_SQUARE_BRACKET,TokenType_PERCENT,TokenType_PERCENT_EQ,TokenType_PERIOD,TokenType_PERIOD_PERIOD,TokenType_PLUS,TokenType_PLUS_EQ,TokenType_PLUS_PLUS,TokenType_QUESTION,TokenType_SEMICOLON,TokenType_SLASH,TokenType_SLASH_EQ,TokenType_STAR,TokenType_STAR_EQ,TokenType_STRING_INTERPOLATION_EXPRESSION,TokenType_STRING_INTERPOLATION_IDENTIFIER,TokenType_TILDE,TokenType_TILDE_SLASH,TokenType_TILDE_SLASH_EQ,TokenType_BACKPING,TokenType_BACKSLASH,TokenType_PERIOD_PERIOD_PERIOD,TokenType_values"}
  },
  TokenType_EOF0: {
    "^": "TokenType;_tokenClass,lexeme,name,ordinal",
    toString$0: function(_) {
      return "-eof-";
    }
  },
  TokenWithComment: {
    "^": "Token;_precedingComment,type,offset,previous,_next",
    get$precedingComments: function() {
      return this._precedingComment;
    }
  }
}],
["engine.sdk", "package:analyzer/src/generated/sdk.dart", , G, {
  "^": "",
  DartSdk: {
    "^": "Object;",
    $isDartSdk: true
  }
}],
["engine.utilities.dart", "package:analyzer/src/generated/utilities_dart.dart", , Z, {
  "^": "",
  ParameterKind: {
    "^": "Enum;isOptional,name,ordinal",
    $isParameterKind: true,
    $asEnum: function() {
      return [Z.ParameterKind];
    },
    static: {"^": "ParameterKind_REQUIRED,ParameterKind_POSITIONAL,ParameterKind_NAMED,ParameterKind_values"}
  }
}],
["interner", "package:analyzer/src/generated/interner.dart", , T, {
  "^": "",
  NullInterner: {
    "^": "Object;"
  }
}],
["java.core", "package:analyzer/src/generated/java_core.dart", , L, {
  "^": "",
  Character_digit: function(codePoint, radix) {
    if (radix !== 16)
      throw H.wrapException(P.ArgumentError$("only radix == 16 is supported"));
    if (48 <= codePoint && codePoint <= 57)
      return codePoint - 48;
    if (65 <= codePoint && codePoint <= 70)
      return 10 + (codePoint - 65);
    if (97 <= codePoint && codePoint <= 102)
      return 10 + (codePoint - 97);
    return -1;
  },
  Character_toChars: function(codePoint) {
    var offset;
    if (codePoint < 0 || codePoint > 1114111)
      throw H.wrapException(L.IllegalArgumentException$("", null));
    if (codePoint < 65536)
      return H.Primitives_stringFromCharCode(codePoint);
    offset = codePoint - 65536;
    return H.Primitives_stringFromCharCodes([((offset & 2147483647) >>> 10) + 55296, (offset & 1023) + 56320]);
  },
  JavaString_indexOf: function(target, str, fromIndex) {
    if (fromIndex > target.length)
      return -1;
    return C.JSString_methods.indexOf$2(target, str, fromIndex < 0 ? 0 : fromIndex);
  },
  formatList: function(pattern, args) {
    var t1 = H.JSSyntaxRegExp_makeNative("\\{(\\d+)\\}", false, true, false);
    pattern.toString;
    return H.stringReplaceAllFuncUnchecked(pattern, new H.JSSyntaxRegExp("\\{(\\d+)\\}", t1, null, null), new L.formatList_closure(args), null);
  },
  PrintWriter: {
    "^": "Object;"
  },
  PrintStringWriter: {
    "^": "PrintWriter;_sb",
    toString$0: function(_) {
      return this._sb._contents;
    }
  },
  JavaException: {
    "^": "Object;",
    toString$0: function(_) {
      return H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null)) + ": " + this.message + " " + H.S(this.cause);
    }
  },
  IllegalArgumentException: {
    "^": "JavaException;message,cause",
    static: {IllegalArgumentException$: function(message, cause) {
        return new L.IllegalArgumentException(message, cause);
      }}
  },
  IllegalStateException: {
    "^": "JavaException;message,cause",
    static: {IllegalStateException$: function(message) {
        return new L.IllegalStateException(message, null);
      }}
  },
  JavaStringBuilder: {
    "^": "Object;sb",
    toString$0: function(_) {
      return this.sb._contents;
    },
    get$length: function(_) {
      return this.sb._contents.length;
    }
  },
  Enum: {
    "^": "Object;name<,ordinal<",
    get$hashCode: function(_) {
      return this.ordinal;
    },
    toString$0: function(_) {
      return this.name;
    },
    compareTo$1: function(_, other) {
      return this.ordinal - other.get$ordinal();
    }
  },
  formatList_closure: {
    "^": "Closure:13;args_0",
    call$1: function(match) {
      var index, t1, arg;
      index = H.Primitives_parseInt(match.group$1(1), null, null);
      t1 = this.args_0;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      arg = t1[index];
      return arg != null ? J.toString$0(arg) : null;
    }
  }
}],
["java.engine", "package:analyzer/src/generated/java_engine.dart", , X, {
  "^": "",
  StringUtilities_endsWith3: function(str, c1, c2, c3) {
    var $length = str.length;
    return $length >= 3 && C.JSString_methods.codeUnitAt$1(str, $length - 3) === c1 && C.JSString_methods.codeUnitAt$1(str, $length - 2) === c2 && C.JSString_methods.codeUnitAt$1(str, $length - 1) === c3;
  },
  StringUtilities_startsWith3: function(str, start, c1, c2, c3) {
    var t1, t2;
    t1 = str.length;
    if (t1 - start >= 3) {
      if (start >= t1)
        H.throwExpression(P.RangeError$value(start));
      if (str.charCodeAt(start) === c1) {
        t2 = start + 1;
        if (t2 >= t1)
          H.throwExpression(P.RangeError$value(t2));
        if (str.charCodeAt(t2) === c2) {
          t2 = start + 2;
          if (t2 >= t1)
            H.throwExpression(P.RangeError$value(t2));
          t1 = str.charCodeAt(t2) === c3;
        } else
          t1 = false;
      } else
        t1 = false;
    } else
      t1 = false;
    return t1;
  },
  StringUtilities_startsWith4: function(str, start, c1, c2, c3, c4) {
    return str.length - start >= 4 && J.getInterceptor$s(str).codeUnitAt$1(str, start) === c1 && C.JSString_methods.codeUnitAt$1(str, start + 1) === c2 && C.JSString_methods.codeUnitAt$1(str, start + 2) === c3 && C.JSString_methods.codeUnitAt$1(str, start + 3) === c4;
  },
  StringUtilities_indexOf2: function(str, start, c1, c2) {
    var t1, last, index, t2;
    t1 = str.length;
    last = t1 - 1;
    for (index = start; index < last;) {
      if (index < 0)
        H.throwExpression(P.RangeError$value(index));
      if (index >= t1)
        H.throwExpression(P.RangeError$value(index));
      if (str.charCodeAt(index) === c1) {
        t2 = index + 1;
        if (t2 < 0)
          H.throwExpression(P.RangeError$value(t2));
        if (t2 >= t1)
          H.throwExpression(P.RangeError$value(t2));
        t2 = str.charCodeAt(t2) === c2;
      } else
        t2 = false;
      if (t2)
        return index;
      ++index;
    }
    return -1;
  },
  StringUtilities_indexOfFirstNotLetterDigit: function(string, startIndex) {
    var last, index, c, t1;
    last = string.length;
    for (index = startIndex; index < last;) {
      if (index < 0)
        H.throwExpression(P.RangeError$value(index));
      if (index >= last)
        H.throwExpression(P.RangeError$value(index));
      c = string.charCodeAt(index);
      if (!(c >= 65 && c <= 90))
        t1 = c >= 97 && c <= 122;
      else
        t1 = true;
      if (!t1)
        t1 = c >= 48 && c <= 57;
      else
        t1 = true;
      if (!t1)
        return index;
      ++index;
    }
    return last;
  }
}],
["", "parser_driver.dart", , L, {
  "^": "",
  main: [function(args) {
    var t1, src, exports, errorListener, reader, token, unit, visitor;
    t1 = J.getInterceptor$as(args);
    src = t1.$index(args, 0);
    exports = t1.$index(args, 1);
    errorListener = new L._ErrorCollector(H.setRuntimeTypeInfo([], [U.AnalysisError]));
    reader = new K.CharSequenceReader(src, 0, 0);
    reader._stringLength = J.get$length$as(src);
    reader._charOffset = -1;
    token = K.Scanner$(null, reader, errorListener).tokenize$0();
    unit = new S.Parser(null, errorListener, 0, true, $.AnalysisOptionsImpl_DEFAULT_ENABLE_ASYNC, $.AnalysisOptionsImpl_DEFAULT_ENABLE_DEFERRED_LOADING, $.AnalysisOptionsImpl_DEFAULT_ENABLE_ENUM, null, false, false, false, false, false).parseCompilationUnit$1(token);
    visitor = H.setRuntimeTypeInfo(new N.GeneralizingAstVisitor(), [null]);
    unit.toString;
    visitor.visitCompilationUnit$1(unit);
    exports.set$errors(errorListener.errors);
  }, "call$1", "main$closure", 2, 0, 10],
  _ErrorCollector: {
    "^": "AnalysisErrorListener;errors?",
    onError$1: function(error) {
      return this.errors.push(error);
    }
  }
},
1],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
;(function() {
  var TRUE = !0, _;
  _ = P.String;
  _.$isString = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.String];
  _.$isObject = TRUE;
  _ = P.num;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = K.TokenType;
  _.$isComparable = TRUE;
  _.$asComparable = [K.TokenType];
  _.$isObject = TRUE;
  _ = K.TokenClass;
  _.$isComparable = TRUE;
  _.$asComparable = [K.TokenClass];
  _.$isObject = TRUE;
  _ = K.Keyword;
  _.$isKeyword = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [K.Keyword];
  _.$isObject = TRUE;
  _ = S.ParserErrorCode;
  _.$isComparable = TRUE;
  _.$asComparable = [S.ParserErrorCode];
  _.$isObject = TRUE;
  _ = U.ErrorSeverity;
  _.$isComparable = TRUE;
  _.$asComparable = [U.ErrorSeverity];
  _.$isObject = TRUE;
  P.Object.$isObject = TRUE;
  _ = U.ErrorType;
  _.$isComparable = TRUE;
  _.$asComparable = [U.ErrorType];
  _.$isObject = TRUE;
  _ = P.Match;
  _.$isMatch = TRUE;
  _.$isObject = TRUE;
  _ = U.CompileTimeErrorCode;
  _.$isComparable = TRUE;
  _.$asComparable = [U.CompileTimeErrorCode];
  _.$isObject = TRUE;
  _ = Z.ParameterKind;
  _.$isComparable = TRUE;
  _.$asComparable = [Z.ParameterKind];
  _.$isObject = TRUE;
  _ = N.CommentType;
  _.$isComparable = TRUE;
  _.$asComparable = [N.CommentType];
  _.$isObject = TRUE;
  _ = K.ScannerErrorCode;
  _.$isComparable = TRUE;
  _.$asComparable = [K.ScannerErrorCode];
  _.$isObject = TRUE;
  _ = P.Duration;
  _.$isComparable = TRUE;
  _.$asComparable = [P.Duration];
  _.$isObject = TRUE;
  U.AnalysisError.$isObject = TRUE;
  _ = N.Directive;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.CompilationUnitMember;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.AstNode;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.VariableDeclaration;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.Annotation;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.Expression;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  G.DartSdk.$isObject = TRUE;
  T.SdkCachePartition.$isObject = TRUE;
  _ = N.TypeName;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  K.Token.$isObject = TRUE;
  _ = N.Statement;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.Label;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.CatchClause;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.SwitchMember;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.FormalParameter;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.MapLiteralEntry;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.StringLiteral;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = P.$int;
  _.$is$int = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = N.InterpolationElement;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.EnumConstantDeclaration;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.TypeParameter;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.ClassMember;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.ConstructorInitializer;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.Combinator;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.SimpleIdentifier;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  _ = N.CommentReference;
  _.$isAstNode = TRUE;
  _.$isObject = TRUE;
  K.BeginToken.$isObject = TRUE;
  _ = P.List;
  _.$isList = TRUE;
  _.$isObject = TRUE;
  _ = K.KeywordState;
  _.$isKeywordState = TRUE;
  _.$isObject = TRUE;
  H.RawReceivePortImpl.$isObject = TRUE;
  H._IsolateEvent.$isObject = TRUE;
  H._IsolateContext.$isObject = TRUE;
  _ = P.Symbol;
  _.$isSymbol = TRUE;
  _.$isObject = TRUE;
  _ = P.Comparable;
  _.$isComparable = TRUE;
  _.$isObject = TRUE;
  _ = P.bool;
  _.$isbool = TRUE;
  _.$isObject = TRUE;
  _ = U.InstrumentationBuilder;
  _.$isInstrumentationBuilder = TRUE;
  _.$isObject = TRUE;
  _ = P.StackTrace;
  _.$isStackTrace = TRUE;
  _.$isObject = TRUE;
  _ = P._EventSink;
  _.$is_EventSink = TRUE;
  _.$isObject = TRUE;
  _ = P.Future;
  _.$isFuture = TRUE;
  _.$isObject = TRUE;
  _ = P._DelayedEvent;
  _.$is_DelayedEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.StreamSubscription;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
})();
;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$a = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$as = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$as = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string")
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$as(receiver).$index(receiver, a0);
};
J.$indexSet$a = function(receiver, a0, a1) {
  if (receiver.constructor == Array && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$a(receiver).$indexSet(receiver, a0, a1);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.add$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).add$1(receiver, a0);
};
J.addAll$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).addAll$1(receiver, a0);
};
J.codeUnitAt$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.contains$1$as = function(receiver, a0) {
  return J.getInterceptor$as(receiver).contains$1(receiver, a0);
};
J.forEach$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).forEach$1(receiver, a0);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$isEmpty$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$isEmpty(receiver);
};
J.get$iterator$a = function(receiver) {
  return J.getInterceptor$a(receiver).get$iterator(receiver);
};
J.get$length$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$length(receiver);
};
J.remove$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).remove$1(receiver, a0);
};
J.substring$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).substring$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
C.JSArray_methods = J.JSArray.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C__RootZone = new P._RootZone();
C.CommentType_DOCUMENTATION_2 = new N.CommentType("DOCUMENTATION", 2);
C.CompileTimeErrorCode_cWd = new U.CompileTimeErrorCode("The asynchronous for-in can only be used in a function marked with async or async*", null, "ASYNC_FOR_IN_WRONG_CONTEXT", 3);
C.Duration_0 = new P.Duration(0);
C.ErrorSeverity_E_error_ERROR_3 = new U.ErrorSeverity("E", "error", "ERROR", 3);
C.ErrorType_JmU = new U.ErrorType(C.ErrorSeverity_E_error_ERROR_3, "SYNTACTIC_ERROR", 7);
C.ErrorType_U01 = new U.ErrorType(C.ErrorSeverity_E_error_ERROR_3, "COMPILE_TIME_ERROR", 2);
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.Keyword_abstract_true_ABSTRACT_33 = new K.Keyword("abstract", true, "ABSTRACT", 33);
C.Keyword_as_true_AS_34 = new K.Keyword("as", true, "AS", 34);
C.Keyword_assert_false_ASSERT_0 = new K.Keyword("assert", false, "ASSERT", 0);
C.Keyword_break_false_BREAK_1 = new K.Keyword("break", false, "BREAK", 1);
C.Keyword_case_false_CASE_2 = new K.Keyword("case", false, "CASE", 2);
C.Keyword_catch_false_CATCH_3 = new K.Keyword("catch", false, "CATCH", 3);
C.Keyword_class_false_CLASS_4 = new K.Keyword("class", false, "CLASS", 4);
C.Keyword_const_false_CONST_5 = new K.Keyword("const", false, "CONST", 5);
C.Keyword_continue_false_CONTINUE_6 = new K.Keyword("continue", false, "CONTINUE", 6);
C.Keyword_default_false_DEFAULT_7 = new K.Keyword("default", false, "DEFAULT", 7);
C.Keyword_deferred_true_DEFERRED_35 = new K.Keyword("deferred", true, "DEFERRED", 35);
C.Keyword_do_false_DO_8 = new K.Keyword("do", false, "DO", 8);
C.Keyword_else_false_ELSE_9 = new K.Keyword("else", false, "ELSE", 9);
C.Keyword_enum_false_ENUM_10 = new K.Keyword("enum", false, "ENUM", 10);
C.Keyword_export_true_EXPORT_37 = new K.Keyword("export", true, "EXPORT", 37);
C.Keyword_extends_false_EXTENDS_11 = new K.Keyword("extends", false, "EXTENDS", 11);
C.Keyword_external_true_EXTERNAL_38 = new K.Keyword("external", true, "EXTERNAL", 38);
C.Keyword_factory_true_FACTORY_39 = new K.Keyword("factory", true, "FACTORY", 39);
C.Keyword_false_false_FALSE_12 = new K.Keyword("false", false, "FALSE", 12);
C.Keyword_final_false_FINAL_13 = new K.Keyword("final", false, "FINAL", 13);
C.Keyword_finally_false_FINALLY_14 = new K.Keyword("finally", false, "FINALLY", 14);
C.Keyword_for_false_FOR_15 = new K.Keyword("for", false, "FOR", 15);
C.Keyword_get_true_GET_40 = new K.Keyword("get", true, "GET", 40);
C.Keyword_if_false_IF_16 = new K.Keyword("if", false, "IF", 16);
C.Keyword_implements_true_IMPLEMENTS_41 = new K.Keyword("implements", true, "IMPLEMENTS", 41);
C.Keyword_import_true_IMPORT_42 = new K.Keyword("import", true, "IMPORT", 42);
C.Keyword_in_false_IN_17 = new K.Keyword("in", false, "IN", 17);
C.Keyword_is_false_IS_18 = new K.Keyword("is", false, "IS", 18);
C.Keyword_library_true_LIBRARY_43 = new K.Keyword("library", true, "LIBRARY", 43);
C.Keyword_new_false_NEW_19 = new K.Keyword("new", false, "NEW", 19);
C.Keyword_null_false_NULL_20 = new K.Keyword("null", false, "NULL", 20);
C.Keyword_operator_true_OPERATOR_44 = new K.Keyword("operator", true, "OPERATOR", 44);
C.Keyword_part_true_PART_45 = new K.Keyword("part", true, "PART", 45);
C.Keyword_rethrow_false_RETHROW_21 = new K.Keyword("rethrow", false, "RETHROW", 21);
C.Keyword_return_false_RETURN_22 = new K.Keyword("return", false, "RETURN", 22);
C.Keyword_set_true_SET_46 = new K.Keyword("set", true, "SET", 46);
C.Keyword_static_true_STATIC_47 = new K.Keyword("static", true, "STATIC", 47);
C.Keyword_super_false_SUPER_23 = new K.Keyword("super", false, "SUPER", 23);
C.Keyword_switch_false_SWITCH_24 = new K.Keyword("switch", false, "SWITCH", 24);
C.Keyword_this_false_THIS_25 = new K.Keyword("this", false, "THIS", 25);
C.Keyword_throw_false_THROW_26 = new K.Keyword("throw", false, "THROW", 26);
C.Keyword_true_false_TRUE_27 = new K.Keyword("true", false, "TRUE", 27);
C.Keyword_try_false_TRY_28 = new K.Keyword("try", false, "TRY", 28);
C.Keyword_typedef_true_TYPEDEF_48 = new K.Keyword("typedef", true, "TYPEDEF", 48);
C.Keyword_var_false_VAR_29 = new K.Keyword("var", false, "VAR", 29);
C.Keyword_void_false_VOID_30 = new K.Keyword("void", false, "VOID", 30);
C.Keyword_while_false_WHILE_31 = new K.Keyword("while", false, "WHILE", 31);
C.Keyword_with_false_WITH_32 = new K.Keyword("with", false, "WITH", 32);
C.Keyword_dynamic_true_DYNAMIC_36 = new K.Keyword("dynamic", true, "DYNAMIC", 36);
Isolate.makeConstantList = function(list) {
  list.immutable$list = init;
  list.fixed$length = init;
  return list;
};
;
C.List_Z1y = Isolate.makeConstantList([C.Keyword_assert_false_ASSERT_0, C.Keyword_break_false_BREAK_1, C.Keyword_case_false_CASE_2, C.Keyword_catch_false_CATCH_3, C.Keyword_class_false_CLASS_4, C.Keyword_const_false_CONST_5, C.Keyword_continue_false_CONTINUE_6, C.Keyword_default_false_DEFAULT_7, C.Keyword_do_false_DO_8, C.Keyword_else_false_ELSE_9, C.Keyword_enum_false_ENUM_10, C.Keyword_extends_false_EXTENDS_11, C.Keyword_false_false_FALSE_12, C.Keyword_final_false_FINAL_13, C.Keyword_finally_false_FINALLY_14, C.Keyword_for_false_FOR_15, C.Keyword_if_false_IF_16, C.Keyword_in_false_IN_17, C.Keyword_is_false_IS_18, C.Keyword_new_false_NEW_19, C.Keyword_null_false_NULL_20, C.Keyword_rethrow_false_RETHROW_21, C.Keyword_return_false_RETURN_22, C.Keyword_super_false_SUPER_23, C.Keyword_switch_false_SWITCH_24, C.Keyword_this_false_THIS_25, C.Keyword_throw_false_THROW_26, C.Keyword_true_false_TRUE_27, C.Keyword_try_false_TRY_28, C.Keyword_var_false_VAR_29, C.Keyword_void_false_VOID_30, C.Keyword_while_false_WHILE_31, C.Keyword_with_false_WITH_32, C.Keyword_abstract_true_ABSTRACT_33, C.Keyword_as_true_AS_34, C.Keyword_deferred_true_DEFERRED_35, C.Keyword_dynamic_true_DYNAMIC_36, C.Keyword_export_true_EXPORT_37, C.Keyword_external_true_EXTERNAL_38, C.Keyword_factory_true_FACTORY_39, C.Keyword_get_true_GET_40, C.Keyword_implements_true_IMPLEMENTS_41, C.Keyword_import_true_IMPORT_42, C.Keyword_library_true_LIBRARY_43, C.Keyword_operator_true_OPERATOR_44, C.Keyword_part_true_PART_45, C.Keyword_set_true_SET_46, C.Keyword_static_true_STATIC_47, C.Keyword_typedef_true_TYPEDEF_48]);
C.ParameterKind_false_REQUIRED_0 = new Z.ParameterKind(false, "REQUIRED", 0);
C.ParameterKind_true_NAMED_2 = new Z.ParameterKind(true, "NAMED", 2);
C.ParameterKind_true_POSITIONAL_1 = new Z.ParameterKind(true, "POSITIONAL", 1);
C.ParserErrorCode_0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "An enum must declare at least one constant name", null, "EMPTY_ENUM_BODY", 27);
C.ParserErrorCode_2Rk = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Variables cannot have a type of 'void'", null, "VOID_VARIABLE", 144);
C.ParserErrorCode_2Zx = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Local function declarations cannot specify any modifier", null, "LOCAL_FUNCTION_DECLARATION_MODIFIER", 76);
C.ParserErrorCode_2nU = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Members cannot be declared to be both 'const' and 'var'", null, "CONST_AND_VAR", 12);
C.ParserErrorCode_2to = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected a class member", null, "EXPECTED_CLASS_MEMBER", 30);
C.ParserErrorCode_43h = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "There is no '{0}' to open a parameter group", null, "UNEXPECTED_TERMINATOR_FOR_PARAMETER_GROUP", 130);
C.ParserErrorCode_4AN = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A continue statement cannot be used outside of a loop or switch statement", null, "CONTINUE_OUTSIDE_OF_LOOP", 20);
C.ParserErrorCode_4CA = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected a type name", null, "EXPECTED_TYPE_NAME", 35);
C.ParserErrorCode_4MH = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Members of classes cannot be declared to be 'abstract'", null, "ABSTRACT_CLASS_MEMBER", 0);
C.ParserErrorCode_4e8 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "An enum definition must have a body with at least one constant name", null, "MISSING_ENUM_BODY", 82);
C.ParserErrorCode_52A = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'static' should be before the modifier 'final'", null, "STATIC_AFTER_FINAL", 120);
C.ParserErrorCode_5i6 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Operator declarations must be preceeded by the keyword 'operator'", null, "MISSING_KEYWORD_OPERATOR", 88);
C.ParserErrorCode_6Hm = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Throw expressions must compute the object to be thrown", null, "MISSING_EXPRESSION_IN_THROW", 83);
C.ParserErrorCode_7FR = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected a list or map literal", null, "EXPECTED_LIST_OR_MAP_LITERAL", 32);
C.ParserErrorCode_86y = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The extends clause must be before the implements clause", null, "IMPLEMENTS_BEFORE_EXTENDS", 62);
C.ParserErrorCode_89t = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "An escape sequence starting with '\\x' must be followed by 2 hexidecimal digits", null, "INVALID_HEX_ESCAPE", 69);
C.ParserErrorCode_8FR = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Top-level variables cannot be declared to be 'abstract'", null, "ABSTRACT_TOP_LEVEL_VARIABLE", 4);
C.ParserErrorCode_8G7 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Only one library directive may be declared in a file", null, "MULTIPLE_LIBRARY_DIRECTIVES", 100);
C.ParserErrorCode_8Gl = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Classes cannot be declared to be 'var'", null, "VAR_CLASS", 139);
C.ParserErrorCode_8Gy = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A 'static' getter must have a body", null, "STATIC_GETTER_WITHOUT_BODY", 123);
C.ParserErrorCode_8WR = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Enums cannot be declared to be 'const'", null, "CONST_ENUM", 15);
C.ParserErrorCode_8Wd = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Assert cannot be called on cascade", null, "ASSERT_DOES_NOT_TAKE_CASCADE", 7);
C.ParserErrorCode_8Wd0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The loop variable in a for-each loop cannot be initialized", null, "INITIALIZED_VARIABLE_IN_FOR_EACH", 65);
C.ParserErrorCode_8hp = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Illegal assignment to non-assignable expression", null, "ILLEGAL_ASSIGNMENT_TO_NON_ASSIGNABLE", 61);
C.ParserErrorCode_ACQ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'async*' is not allowed for an expression function body", "Convert the body to a block.", "INVALID_STAR_AFTER_ASYNC", 72);
C.ParserErrorCode_AKW = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected a statement", null, "MISSING_STATEMENT", 93);
C.ParserErrorCode_AbH = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A loop variable must be declared in a for-each loop before the 'in', but none were found", null, "MISSING_VARIABLE_IN_FOR_EACH", 96);
C.ParserErrorCode_AeS = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Positional arguments must occur before named arguments", null, "POSITIONAL_AFTER_NAMED_ARGUMENT", 115);
C.ParserErrorCode_Aec = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A class definition must have a body, even if it is empty", null, "MISSING_CLASS_BODY", 79);
C.ParserErrorCode_AiQ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "An escape sequence starting with '\\u' must be followed by 4 hexidecimal digits or from 1 to 6 digits between '{' and '}'", null, "INVALID_UNICODE_ESCAPE", 74);
C.ParserErrorCode_B8J = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected 'case' or 'default'", null, "EXPECTED_CASE_OR_DEFAULT", 29);
C.ParserErrorCode_C8a = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The library directive must appear before all other directives", null, "LIBRARY_DIRECTIVE_NOT_FIRST", 75);
C.ParserErrorCode_CeS = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Each class definition can have at most one extends clause", null, "MULTIPLE_EXTENDS_CLAUSES", 98);
C.ParserErrorCode_Dn4 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected a method, getter, setter or operator declaration", null, "EXPECTED_EXECUTABLE", 31);
C.ParserErrorCode_ECL = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Equality expression cannot be operand of another equality expression.", null, "EQUALITY_CANNOT_BE_EQUALITY_OPERAND", 28);
C.ParserErrorCode_ECL0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Each class definition can have at most one with clause", null, "MULTIPLE_WITH_CLAUSES", 105);
C.ParserErrorCode_ECO = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Deferred imports must have a prefix", null, "MISSING_PREFIX_IN_DEFERRED_IMPORT", 91);
C.ParserErrorCode_EuH = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Enums cannot be declared to be 'abstract'", null, "ABSTRACT_ENUM", 1);
C.ParserErrorCode_FCG = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Directives must appear before any declarations", null, "DIRECTIVE_AFTER_DECLARATION", 24);
C.ParserErrorCode_Fcu = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A 'static' setter must have a body", null, "STATIC_SETTER_WITHOUT_BODY", 125);
C.ParserErrorCode_GRv = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Named parameters must be enclosed in curly braces ('{' and '}')", null, "NAMED_PARAMETER_OUTSIDE_GROUP", 107);
C.ParserErrorCode_H31 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The default value of a named parameter should be preceeded by ':'", null, "WRONG_SEPARATOR_FOR_NAMED_PARAMETER", 134);
C.ParserErrorCode_H37 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Top-level functions cannot be declared to be 'abstract'", null, "ABSTRACT_TOP_LEVEL_FUNCTION", 3);
C.ParserErrorCode_H9g = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'await' is not allowed for a normal 'for' statement", "Remove the keyword or use a for-each statement.", "INVALID_AWAIT_IN_FOR", 66);
C.ParserErrorCode_I1c = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Classes cannot be declared to be 'final'", null, "FINAL_CLASS", 53);
C.ParserErrorCode_IAC = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Constructors cannot have a return type", null, "CONSTRUCTOR_WITH_RETURN_TYPE", 19);
C.ParserErrorCode_IRN = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "External constructors cannot have a body", null, "EXTERNAL_CONSTRUCTOR_WITH_BODY", 41);
C.ParserErrorCode_IkF = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'sync' is not allowed for an exrpression function body", "Convert the body to a block.", "INVALID_SYNC", 73);
C.ParserErrorCode_KIe = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "External operators cannot have a body", null, "EXTERNAL_OPERATOR_WITH_BODY", 46);
C.ParserErrorCode_KQI = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier '{0}' was already specified.", null, "DUPLICATED_MODIFIER", 26);
C.ParserErrorCode_L9F = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Constructors cannot be static", null, "STATIC_CONSTRUCTOR", 122);
C.ParserErrorCode_MEg = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'sync' must be followed by a star ('*')", "Remove the modifier or add a star.", "MISSING_STAR_AFTER_SYNC", 92);
C.ParserErrorCode_MQW = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A function body must be provided", null, "MISSING_FUNCTION_BODY", 84);
C.ParserErrorCode_MUB = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected a string literal", null, "EXPECTED_STRING_LITERAL", 33);
C.ParserErrorCode_MUw = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The with clause must be before the implements clause", null, "IMPLEMENTS_BEFORE_WITH", 63);
C.ParserErrorCode_MUw0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The name of a library must be an identifier", null, "NON_IDENTIFIER_LIBRARY_NAME", 111);
C.ParserErrorCode_O1c = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Enums cannot be declared to be 'external'", null, "EXTERNAL_ENUM", 42);
C.ParserErrorCode_ODT = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Cannot have both positional and named parameters in a single parameter list", null, "MIXED_PARAMETER_GROUPS", 97);
C.ParserErrorCode_Odg = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The closing parenthesis is missing", null, "MISSING_CLOSING_PARENTHESIS", 80);
C.ParserErrorCode_P98 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A try statement must have either a catch or finally clause", null, "MISSING_CATCH_OR_FINALLY", 78);
C.ParserErrorCode_PEK = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The default value of a positional parameter should be preceeded by '='", null, "WRONG_SEPARATOR_FOR_POSITIONAL_PARAMETER", 135);
C.ParserErrorCode_Q2X = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "External setters cannot have a body", null, "EXTERNAL_SETTER_WITH_BODY", 47);
C.ParserErrorCode_Q2X0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "External getters cannot have a body", null, "EXTERNAL_GETTER_WITH_BODY", 44);
C.ParserErrorCode_QCm = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The string '{0}' is not a valid operator", null, "INVALID_OPERATOR", 70);
C.ParserErrorCode_QOI = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Getters, setters and methods cannot be declared to be 'final'", null, "FINAL_METHOD", 56);
C.ParserErrorCode_QTd = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The 'default' case can only be declared once", null, "SWITCH_HAS_MULTIPLE_DEFAULT_CASES", 128);
C.ParserErrorCode_SFe = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A break statement cannot be used outside of a loop or switch statement", null, "BREAK_OUTSIDE_OF_LOOP", 10);
C.ParserErrorCode_Smp = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Cannot have multiple groups of positional parameters in a single parameter list", null, "MULTIPLE_POSITIONAL_PARAMETER_GROUPS", 103);
C.ParserErrorCode_Svc = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Cannot have multiple groups of named parameters in a single parameter list", null, "MULTIPLE_NAMED_PARAMETER_GROUPS", 101);
C.ParserErrorCode_TlH = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Setters cannot be defined within methods or functions", null, "SETTER_IN_FUNCTION", 118);
C.ParserErrorCode_U44 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A constructor cannot be declared to be 'final'", null, "FINAL_CONSTRUCTOR", 54);
C.ParserErrorCode_UV6 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Classes cannot be declared to be 'external'", null, "EXTERNAL_CLASS", 40);
C.ParserErrorCode_UW6 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Type aliases cannot be declared to be 'final'", null, "FINAL_TYPEDEF", 57);
C.ParserErrorCode_V5x = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The label {0} was already used in this switch statement", null, "DUPLICATE_LABEL_IN_SWITCH_STATEMENT", 25);
C.ParserErrorCode_WTB = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Positional parameters must be enclosed in square brackets ('[' and ']')", null, "POSITIONAL_PARAMETER_OUTSIDE_GROUP", 116);
C.ParserErrorCode_WXJ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Each class definition can have at most one implements clause", null, "MULTIPLE_IMPLEMENTS_CLAUSES", 99);
C.ParserErrorCode_XLl = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Export directives must preceed part directives", null, "EXPORT_DIRECTIVE_AFTER_PART_DIRECTIVE", 36);
C.ParserErrorCode_XPt = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'static' should be before the modifier 'const'", null, "STATIC_AFTER_CONST", 119);
C.ParserErrorCode_Xlp = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Variables cannot be declared using both 'var' and a type name; remove the 'var'", null, "VAR_AND_TYPE", 137);
C.ParserErrorCode_YCv = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Deferred imports are not supported by default", null, "DEFERRED_IMPORTS_NOT_SUPPORTED", 22);
C.ParserErrorCode_YeK = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The operator '{0}' is not user definable", null, "NON_USER_DEFINABLE_OPERATOR", 113);
C.ParserErrorCode_YkH = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The operator '{0}' cannot be used with 'super'", null, "INVALID_OPERATOR_FOR_SUPER", 71);
C.ParserErrorCode_Z3F = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Assert cannot be called on throws", null, "ASSERT_DOES_NOT_TAKE_THROW", 8);
C.ParserErrorCode_a94 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "There is no '{0}' to close the parameter group", null, "MISSING_TERMINATOR_FOR_PARAMETER_GROUP", 94);
C.ParserErrorCode_aNH = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The return type cannot be 'var'", null, "VAR_RETURN_TYPE", 141);
C.ParserErrorCode_aRy = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The escape sequence '{0}' is not a valid code point", null, "INVALID_CODE_POINT", 67);
C.ParserErrorCode_aZ8 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Type aliases for functions must have an explicit list of parameters", null, "MISSING_TYPEDEF_PARAMETERS", 95);
C.ParserErrorCode_akP = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A single loop variable must be declared in a for-each loop before the 'in', but {0} were found", null, "MULTIPLE_VARIABLES_IN_FOR_EACH", 104);
C.ParserErrorCode_ato = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Type aliases cannot be declared to be 'const'", null, "CONST_TYPEDEF", 18);
C.ParserErrorCode_ato0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'external' should be before the modifier 'static'", null, "EXTERNAL_AFTER_STATIC", 39);
C.ParserErrorCode_bQP = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Normal parameters must occur before optional parameters", null, "NORMAL_BEFORE_OPTIONAL_PARAMETERS", 114);
C.ParserErrorCode_bbS = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Fields cannot be declared to be 'external'", null, "EXTERNAL_FIELD", 43);
C.ParserErrorCode_bzA = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A continue statement in a switch statement must have a label as a target", null, "CONTINUE_WITHOUT_LABEL_IN_CASE", 21);
C.ParserErrorCode_c1W = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The extends clause must be before the with clause", null, "WITH_BEFORE_EXTENDS", 132);
C.ParserErrorCode_cfF = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Getters cannot be defined within methods or functions", null, "GETTER_IN_FUNCTION", 59);
C.ParserErrorCode_dFE = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'static' should be before the modifier 'var'", null, "STATIC_AFTER_VAR", 121);
C.ParserErrorCode_eWW = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Classes cannot be declared to be 'const'", null, "CONST_CLASS", 13);
C.ParserErrorCode_ef1 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The 'default' case should be the last case in a switch statement", null, "SWITCH_HAS_CASE_AFTER_DEFAULT_CASE", 127);
C.ParserErrorCode_ezM = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected '{0}' to close parameter group", null, "WRONG_TERMINATOR_FOR_PARAMETER_GROUP", 136);
C.ParserErrorCode_gPO = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The 'typedef' mixin application was replaced with 'class'", null, "DEPRECATED_CLASS_TYPE_ALIAS", 23);
C.ParserErrorCode_gQW = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Members cannot be declared to be both 'const' and 'final'", null, "CONST_AND_FINAL", 11);
C.ParserErrorCode_gWj = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Assert cannot be called on rethrows", null, "ASSERT_DOES_NOT_TAKE_RETHROW", 9);
C.ParserErrorCode_gf4 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Only redirecting factory constructors can be declared to be 'const'", null, "CONST_FACTORY", 16);
C.ParserErrorCode_gld = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "A non-redirecting 'factory' constructor must have a body", null, "FACTORY_WITHOUT_BODY", 50);
C.ParserErrorCode_hkG = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Parameters cannot have a type of 'void'", null, "VOID_PARAMETER", 143);
C.ParserErrorCode_i78 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Operators cannot be static", null, "STATIC_OPERATOR", 124);
C.ParserErrorCode_iDZ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "'const' constructors cannot have a body", null, "CONST_CONSTRUCTOR_WITH_BODY", 14);
C.ParserErrorCode_iL9 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Type aliases cannot be declared to be 'var'", null, "VAR_TYPEDEF", 142);
C.ParserErrorCode_if8 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Missing selector such as \".<identifier>\" or \"[0]\"", null, "MISSING_ASSIGNABLE_SELECTOR", 77);
C.ParserErrorCode_izs = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Field initializers can only be used in a constructor", null, "FIELD_INITIALIZER_OUTSIDE_CONSTRUCTOR", 51);
C.ParserErrorCode_jMY = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Type aliases cannot be declared to be 'external'", null, "EXTERNAL_TYPEDEF", 48);
C.ParserErrorCode_k8F = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'external' should be before the modifier 'factory'", null, "EXTERNAL_AFTER_FACTORY", 38);
C.ParserErrorCode_kPR = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Static methods cannot be declared to be 'abstract'", null, "ABSTRACT_STATIC_METHOD", 2);
C.ParserErrorCode_kSZ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Assert cannot be called on an assignment", null, "ASSERT_DOES_NOT_TAKE_ASSIGNMENT", 6);
C.ParserErrorCode_kiY = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Operators must be declared within a class", null, "TOP_LEVEL_OPERATOR", 129);
C.ParserErrorCode_klg = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "External methods cannot have a body", null, "EXTERNAL_METHOD_WITH_BODY", 45);
C.ParserErrorCode_ksx = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Enums cannot be declared to be 'final'", null, "FINAL_ENUM", 55);
C.ParserErrorCode_mBX = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Enums cannot be declared to be 'var'", null, "VAR_ENUM", 140);
C.ParserErrorCode_mZp = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Members cannot be declared to be both 'final' and 'var'", null, "FINAL_AND_VAR", 52);
C.ParserErrorCode_o0y = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Library directives must include a library name", null, "MISSING_NAME_IN_LIBRARY_DIRECTIVE", 89);
C.ParserErrorCode_ot1 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Only constructors can be declared to be a 'factory'", null, "NON_CONSTRUCTOR_FACTORY", 110);
C.ParserErrorCode_p8N = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Only one part-of directive may be declared in a file", null, "MULTIPLE_PART_OF_DIRECTIVES", 102);
C.ParserErrorCode_qN2 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Getters must have the keyword 'get' before the getter name", null, "MISSING_GET", 86);
C.ParserErrorCode_quJ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Only factory constructor can specify '=' redirection.", null, "REDIRECTION_IN_NON_FACTORY_CONSTRUCTOR", 117);
C.ParserErrorCode_r76 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Type aliases cannot be declared to be 'abstract'", null, "ABSTRACT_TYPEDEF", 5);
C.ParserErrorCode_rl2 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The part-of directive must be the only directive in a part", null, "NON_PART_OF_DIRECTIVE_IN_PART", 112);
C.ParserErrorCode_s8i = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected to find '{0}'", null, "EXPECTED_TOKEN", 34);
C.ParserErrorCode_sAF = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Variables must be declared using the keywords 'const', 'final', 'var' or a type name", null, "MISSING_CONST_FINAL_VAR_OR_TYPE", 81);
C.ParserErrorCode_sav = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Functions must have an explicit list of parameters", null, "MISSING_FUNCTION_PARAMETERS", 85);
C.ParserErrorCode_sav0 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Getter should be declared without a parameter list", null, "GETTER_WITH_PARAMETERS", 60);
C.ParserErrorCode_st1 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The modifier 'external' should be before the modifier 'const'", null, "EXTERNAL_AFTER_CONST", 37);
C.ParserErrorCode_ubf = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The with clause cannot be used without an extends clause", null, "WITH_WITHOUT_EXTENDS", 133);
C.ParserErrorCode_udD = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Unexpected token '{0}'", null, "UNEXPECTED_TOKEN", 131);
C.ParserErrorCode_uti = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Function typed parameters cannot specify 'const', 'final' or 'var' instead of return type", null, "FUNCTION_TYPED_PARAMETER_VAR", 58);
C.ParserErrorCode_wIv = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Library directives must include a library name", null, "MISSING_NAME_IN_PART_OF_DIRECTIVE", 90);
C.ParserErrorCode_wMa = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Top-level declarations cannot be declared to be 'factory'", null, "FACTORY_TOP_LEVEL_DECLARATION", 49);
C.ParserErrorCode_xEW = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Top-level declarations cannot be declared to be 'static'", null, "STATIC_TOP_LEVEL_DECLARATION", 126);
C.ParserErrorCode_yHZ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "The keyword 'var' cannot be used as a type name", null, "VAR_AS_TYPE_NAME", 138);
C.ParserErrorCode_yLX = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Import directives must preceed part directives", null, "IMPORT_DIRECTIVE_AFTER_PART_DIRECTIVE", 64);
C.ParserErrorCode_yw2 = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Expected an identifier", null, "MISSING_IDENTIFIER", 87);
C.ParserErrorCode_yzJ = new S.ParserErrorCode(C.ErrorSeverity_E_error_ERROR_3, "Getters, setters and methods cannot be declared to be 'const'", null, "CONST_METHOD", 17);
C.ScannerErrorCode_EfF = new K.ScannerErrorCode("Hexidecimal digit expected", null, "MISSING_HEX_DIGIT", 2);
C.ScannerErrorCode_SNa = new K.ScannerErrorCode("Unterminated string literal", null, "UNTERMINATED_STRING_LITERAL", 5);
C.ScannerErrorCode_Ucj = new K.ScannerErrorCode("Decimal digit expected", null, "MISSING_DIGIT", 1);
C.ScannerErrorCode_gc6 = new K.ScannerErrorCode("Unterminated multi-line comment", null, "UNTERMINATED_MULTI_LINE_COMMENT", 4);
C.ScannerErrorCode_mk7 = new K.ScannerErrorCode("Illegal character {0}", null, "ILLEGAL_CHARACTER", 0);
C.TokenClass_0_NO_CLASS_0 = new K.TokenClass(0, "NO_CLASS", 0);
C.TokenClass_11_SHIFT_OPERATOR_13 = new K.TokenClass(11, "SHIFT_OPERATOR", 13);
C.TokenClass_12_ADDITIVE_OPERATOR_1 = new K.TokenClass(12, "ADDITIVE_OPERATOR", 1);
C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11 = new K.TokenClass(13, "MULTIPLICATIVE_OPERATOR", 11);
C.TokenClass_1_ASSIGNMENT_OPERATOR_2 = new K.TokenClass(1, "ASSIGNMENT_OPERATOR", 2);
C.TokenClass_6_EQUALITY_OPERATOR_8 = new K.TokenClass(6, "EQUALITY_OPERATOR", 8);
C.TokenClass_7_RELATIONAL_OPERATOR_12 = new K.TokenClass(7, "RELATIONAL_OPERATOR", 12);
C.TokenType_0 = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "%=", "PERCENT_EQ", 48);
C.TokenClass_10_BITWISE_AND_OPERATOR_3 = new K.TokenClass(10, "BITWISE_AND_OPERATOR", 3);
C.TokenType_0GE = new K.TokenType(C.TokenClass_10_BITWISE_AND_OPERATOR_3, "&", "AMPERSAND", 10);
C.TokenType_27D = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "@", "AT", 13);
C.TokenType_33I = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "}", "CLOSE_CURLY_BRACKET", 23);
C.TokenType_58K = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "]", "CLOSE_SQUARE_BRACKET", 25);
C.TokenClass_14_UNARY_PREFIX_OPERATOR_15 = new K.TokenClass(14, "UNARY_PREFIX_OPERATOR", 15);
C.TokenType_6Vn = new K.TokenType(C.TokenClass_14_UNARY_PREFIX_OPERATOR_15, "++", "PLUS_PLUS", 53);
C.TokenType_6pl = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "\\", "BACKSLASH", 66);
C.TokenType_76y = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "...", "PERIOD_PERIOD_PERIOD", 67);
C.TokenType_8sC = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "~/=", "TILDE_SLASH_EQ", 64);
C.TokenClass_15_UNARY_POSTFIX_OPERATOR_14 = new K.TokenClass(15, "UNARY_POSTFIX_OPERATOR", 14);
C.TokenType_AHF = new K.TokenType(C.TokenClass_15_UNARY_POSTFIX_OPERATOR_14, "[", "OPEN_SQUARE_BRACKET", 46);
C.TokenType_Aec = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "SINGLE_LINE_COMMENT", 8);
C.TokenType_Azp = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "=", "EQ", 26);
C.TokenType_B6W = new K.TokenType(C.TokenClass_15_UNARY_POSTFIX_OPERATOR_14, ".", "PERIOD", 49);
C.TokenClass_3_CONDITIONAL_OPERATOR_7 = new K.TokenClass(3, "CONDITIONAL_OPERATOR", 7);
C.TokenType_B8J = new K.TokenType(C.TokenClass_3_CONDITIONAL_OPERATOR_7, "?", "QUESTION", 54);
C.TokenType_BLy = new K.TokenType(C.TokenClass_6_EQUALITY_OPERATOR_8, "==", "EQ_EQ", 27);
C.TokenType_Bac = new K.TokenType(C.TokenClass_7_RELATIONAL_OPERATOR_12, ">", "GT", 29);
C.TokenType_EOF_Imi = new K.TokenType_EOF0(C.TokenClass_0_NO_CLASS_0, "", "EOF", 0);
C.TokenType_EQM = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "DOUBLE", 1);
C.TokenType_Esm = new K.TokenType(C.TokenClass_15_UNARY_POSTFIX_OPERATOR_14, "[]=", "INDEX_EQ", 35);
C.TokenType_G3y = new K.TokenType(C.TokenClass_11_SHIFT_OPERATOR_13, "<<", "LT_LT", 39);
C.TokenType_HxB = new K.TokenType(C.TokenClass_7_RELATIONAL_OPERATOR_12, "<=", "LT_EQ", 38);
C.TokenType_Jeb = new K.TokenType(C.TokenClass_12_ADDITIVE_OPERATOR_1, "+", "PLUS", 51);
C.TokenType_KiG = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "^=", "CARET_EQ", 22);
C.TokenType_KoJ = new K.TokenType(C.TokenClass_7_RELATIONAL_OPERATOR_12, "<", "LT", 37);
C.TokenType_M2b = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "-=", "MINUS_EQ", 42);
C.TokenType_MD7 = new K.TokenType(C.TokenClass_15_UNARY_POSTFIX_OPERATOR_14, "(", "OPEN_PAREN", 45);
C.TokenType_MMm = new K.TokenType(C.TokenClass_6_EQUALITY_OPERATOR_8, "!=", "BANG_EQ", 15);
C.TokenClass_4_LOGICAL_OR_OPERATOR_10 = new K.TokenClass(4, "LOGICAL_OR_OPERATOR", 10);
C.TokenType_Mxr = new K.TokenType(C.TokenClass_4_LOGICAL_OR_OPERATOR_10, "||", "BAR_BAR", 17);
C.TokenType_Nws = new K.TokenType(C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11, "%", "PERCENT", 47);
C.TokenType_O9i = new K.TokenType(C.TokenClass_12_ADDITIVE_OPERATOR_1, "-", "MINUS", 41);
C.TokenType_OP6 = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "|=", "BAR_EQ", 18);
C.TokenType_RG0 = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "$", "STRING_INTERPOLATION_IDENTIFIER", 61);
C.TokenType_S8h = new K.TokenType(C.TokenClass_0_NO_CLASS_0, ";", "SEMICOLON", 55);
C.TokenType_SSe = new K.TokenType(C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11, "~/", "TILDE_SLASH", 63);
C.TokenType_VcG = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "+=", "PLUS_EQ", 52);
C.TokenType_WFo = new K.TokenType(C.TokenClass_11_SHIFT_OPERATOR_13, ">>", "GT_GT", 31);
C.TokenType_WFw = new K.TokenType(C.TokenClass_15_UNARY_POSTFIX_OPERATOR_14, "[]", "INDEX", 34);
C.TokenClass_8_BITWISE_OR_OPERATOR_4 = new K.TokenClass(8, "BITWISE_OR_OPERATOR", 4);
C.TokenType_aPH = new K.TokenType(C.TokenClass_8_BITWISE_OR_OPERATOR_4, "|", "BAR", 16);
C.TokenType_ato = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "SCRIPT_TAG", 7);
C.TokenType_cdS = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "`", "BACKPING", 65);
C.TokenType_chs = new K.TokenType(C.TokenClass_0_NO_CLASS_0, ":", "COLON", 19);
C.TokenType_dMx = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "MULTI_LINE_COMMENT", 6);
C.TokenType_fld = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "${", "STRING_INTERPOLATION_EXPRESSION", 60);
C.TokenType_gMg = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "*=", "STAR_EQ", 59);
C.TokenType_gmZ = new K.TokenType(C.TokenClass_14_UNARY_PREFIX_OPERATOR_15, "~", "TILDE", 62);
C.TokenType_hLM = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "KEYWORD", 5);
C.TokenType_iDZ = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "STRING", 9);
C.TokenType_iJT = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "=>", "FUNCTION", 28);
C.TokenType_itQ = new K.TokenType(C.TokenClass_14_UNARY_PREFIX_OPERATOR_15, "--", "MINUS_MINUS", 43);
C.TokenType_j1u = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "INT", 4);
C.TokenType_juX = new K.TokenType(C.TokenClass_7_RELATIONAL_OPERATOR_12, ">=", "GT_EQ", 30);
C.TokenType_kC8 = new K.TokenType(C.TokenClass_0_NO_CLASS_0, ")", "CLOSE_PAREN", 24);
C.TokenType_kOG = new K.TokenType(C.TokenClass_14_UNARY_PREFIX_OPERATOR_15, "!", "BANG", 14);
C.TokenType_kOu = new K.TokenType(C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11, "/", "SLASH", 56);
C.TokenClass_2_CASCADE_OPERATOR_6 = new K.TokenClass(2, "CASCADE_OPERATOR", 6);
C.TokenType_mGg = new K.TokenType(C.TokenClass_2_CASCADE_OPERATOR_6, "..", "PERIOD_PERIOD", 50);
C.TokenType_mPa = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "#", "HASH", 33);
C.TokenType_mil = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "<<=", "LT_LT_EQ", 40);
C.TokenType_nrs = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "IDENTIFIER", 3);
C.TokenType_ph7 = new K.TokenType(C.TokenClass_13_MULTIPLICATIVE_OPERATOR_11, "*", "STAR", 58);
C.TokenType_qFj = new K.TokenType(C.TokenClass_0_NO_CLASS_0, "{", "OPEN_CURLY_BRACKET", 44);
C.TokenClass_5_LOGICAL_AND_OPERATOR_9 = new K.TokenClass(5, "LOGICAL_AND_OPERATOR", 9);
C.TokenType_qbp = new K.TokenType(C.TokenClass_5_LOGICAL_AND_OPERATOR_9, "&&", "AMPERSAND_AMPERSAND", 11);
C.TokenType_qz3 = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "/=", "SLASH_EQ", 57);
C.TokenType_s0y = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, "&=", "AMPERSAND_EQ", 12);
C.TokenType_s8I = new K.TokenType(C.TokenClass_0_NO_CLASS_0, ",", "COMMA", 20);
C.TokenClass_9_BITWISE_XOR_OPERATOR_5 = new K.TokenClass(9, "BITWISE_XOR_OPERATOR", 5);
C.TokenType_ub9 = new K.TokenType(C.TokenClass_9_BITWISE_XOR_OPERATOR_5, "^", "CARET", 21);
C.TokenType_wEo = new K.TokenType(C.TokenClass_0_NO_CLASS_0, null, "HEXADECIMAL", 2);
C.TokenType_y9W = new K.TokenType(C.TokenClass_1_ASSIGNMENT_OPERATOR_2, ">>=", "GT_GT_EQ", 32);
$.libraries_to_load = {};
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.AnalysisOptionsImpl_DEFAULT_ENABLE_ASYNC = false;
$.AnalysisOptionsImpl_DEFAULT_ENABLE_DEFERRED_LOADING = true;
$.AnalysisOptionsImpl_DEFAULT_ENABLE_ENUM = false;
$.Parser_ASYNC = "async";
$.Parser__AWAIT = "await";
$.Parser__HIDE = "hide";
$.Parser__OF = "of";
$.Parser__ON = "on";
$.Parser__NATIVE = "native";
$.Parser__SHOW = "show";
$.Parser_SYNC = "sync";
$.Parser__YIELD = "yield";
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "scheduleImmediateClosure", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
});
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});
Isolate.$lazy($, "_UniqueInstance", "AnalysisEngine__UniqueInstance", "get$AnalysisEngine__UniqueInstance", function() {
  return new T.AnalysisEngine($.get$Logger_NULL(), new T.PartitionManager(P.HashMap_HashMap(null, null, null, G.DartSdk, T.SdkCachePartition)), false, false);
});
Isolate.$lazy($, "NULL", "Logger_NULL", "get$Logger_NULL", function() {
  return new T.Logger_NullLogger();
});
Isolate.$lazy($, "LEXICAL_ORDER", "AstNode_LEXICAL_ORDER", "get$AstNode_LEXICAL_ORDER", function() {
  return new N.closure();
});
Isolate.$lazy($, "_NULL_INSTRUMENTATION_BUILDER", "Instrumentation__NULL_INSTRUMENTATION_BUILDER", "get$Instrumentation__NULL_INSTRUMENTATION_BUILDER", function() {
  return new U.InstrumentationBuilder_Instrumentation_NULL_INSTRUMENTATION_BUILDER();
});
Isolate.$lazy($, "_NULL_LOGGER", "Instrumentation__NULL_LOGGER", "get$Instrumentation__NULL_LOGGER", function() {
  return new U.InstrumentationLogger_Instrumentation_NULL_LOGGER();
});
Isolate.$lazy($, "_CURRENT_LOGGER", "Instrumentation__CURRENT_LOGGER", "get$Instrumentation__CURRENT_LOGGER", function() {
  return $.get$Instrumentation__NULL_LOGGER();
});
Isolate.$lazy($, "keywords", "Keyword_keywords", "get$Keyword_keywords", function() {
  return K.Keyword__createKeywordMap();
});
Isolate.$lazy($, "_EMPTY_TABLE", "KeywordState__EMPTY_TABLE", "get$KeywordState__EMPTY_TABLE", function() {
  return H.setRuntimeTypeInfo(Array(26), [K.KeywordState]);
});
Isolate.$lazy($, "KEYWORD_STATE", "KeywordState_KEYWORD_STATE", "get$KeywordState_KEYWORD_STATE", function() {
  return K.KeywordState__createKeywordStateTable();
});
Isolate.$lazy($, "INTERNER", "StringUtilities_INTERNER", "get$StringUtilities_INTERNER", function() {
  return new T.NullInterner();
});

init.metadata = [{func: "dynamic__String", args: [P.String]},
{func: "String__Match", ret: P.String, args: [P.Match]},
{func: "String__String", ret: P.String, args: [P.String]},
{func: "void__void_", void: true, args: [{func: "void_", void: true}]},
{func: "void_", void: true},
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "int__Comparable_Comparable", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
{func: "dynamic__List", args: [[P.List, P.String]]},
{func: "args0"},
{func: "args2", args: [null, null]},
{func: "args1", args: [null]},
{func: "dynamic__void_", args: [{func: "void_", void: true}]},
{func: "dynamic__Symbol_dynamic", args: [P.Symbol, null]},
{func: "String__int", ret: P.String, args: [P.$int]},
{func: "dynamic__AstNode_AstNode", args: [N.AstNode, N.AstNode]},
{func: "Keyword_", ret: K.Keyword},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = {};
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties)
        if (hasOwnProperty.call(properties, member))
          object[member] = properties[member];
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = {};
    if (!init.allClasses)
      init.allClasses = {};
    var allClasses = init.allClasses;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      var constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      if (hasOwnProperty.call(collectedClasses, cls)) {
        var desc = collectedClasses[cls];
        if (desc instanceof Array)
          desc = desc[1];
        var classData = desc["^"], supr, name = cls, fields = classData;
        if (typeof classData == "string") {
          var split = classData.split("/");
          if (split.length == 2) {
            name = split[0];
            fields = split[1];
          }
        }
        var s = fields.split(";");
        fields = s[1] == "" ? [] : s[1].split(",");
        supr = s[0];
        split = supr.split(":");
        if (split.length == 2) {
          supr = split[0];
          var functionSignature = split[1];
          if (functionSignature)
            desc.$signature = function(s) {
              return function() {
                return init.metadata[s];
              };
            }(functionSignature);
        }
        if (supr && supr.indexOf("+") > 0) {
          s = supr.split("+");
          supr = s[0];
          var mixin = collectedClasses[s[1]];
          if (mixin instanceof Array)
            mixin = mixin[1];
          for (var d in mixin) {
            if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
              desc[d] = mixin[d];
          }
        }
        if (typeof dart_precompiled != "function") {
          combinedConstructorFunction += defineClass(name, cls, fields);
          constructorsList.push(cls);
        }
        if (supr)
          pendingClasses[cls] = supr;
      }
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = {};
    init.interceptorsByTag = Object.create(null);
    init.leafTags = {};
    function finishClass(cls) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(finishedClasses, cls))
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              if ($[fieldName] === sentinelInProgress)
                $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(function(a) {
      H.startRootIsolate(L.main$closure(), a);
    }, []);
  } else {
    (function(a) {
      H.startRootIsolate(L.main$closure(), a);
    })([]);
  }
});
;
// END invoke [main].
})()

//# sourceMappingURL=out.js.map

});