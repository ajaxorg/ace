/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/* This file was autogenerated from /Users/brian/git-others/turtle.tmbundle/Syntaxes/SPARQL.tmLanguage (uuid: ) */
/****************************************************************************************
 * IT MIGHT NOT BE PERFECT ...But it's a good start from an existing *.tmlanguage file. *
 * fileTypes                                                                            *
 ****************************************************************************************/

define(function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var SPARQLHighlightRules = function() {
    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used
  
  var keywords = (
      "BASE|BIND|PREFIX|SELECT|ASK|CONSTRUCT|DESCRIBE|FROM|NAMED|WHERE|GRAPH|AS|UNION|" +
      "FILTER|HAVING|VALUES|OPTIONAL|SERVICE|SILENT|DATA|ADD|MOVE|COPY|INSERT|DELETE|LOAD|" +
      "INTO|GRAPH|ALL|DEFAULT|CLEAR|CREATE|DROP|WITH|USING|DISTINCT|REDUCED|ORDER|ASC|DESC|OFFSET|" +
      "LIMITED|REDUCED|GROUP|BY|LIMIT|MINUS"
  );
  
  var builtinConstants = (
      "True|False"
  );
  
  var builtinFunctions = (
    "STR|LANG|LANGMATCHES|DATATYPE|BOUND|IRI|URI|BNODE|RAND|ABS|CEIL|FLOOR|ROUND|CONCAT|STRLEN|" +
    "UCASE|LCASE|ENCODE_FOR_URI|CONTAINS|STRSTARTS|STRENDS|STRBEFORE|STRAFTER|YEAR|MONTH|DAY|HOURS|" +
    "MINUTES|SECONDS|TIMEZONE|TZ|NOW|UUID|STRUUID|MD5|SHA1|SHA256|SHA384|SHA512|COALESCE|IF|STRLANG|" +
    "STRDT|sameTerm|isIRI|isURI|isBLANK|isLITERAL|isNUMERIC|COUNT|SUM|MIN|MAX|AVG|SAMPLE|GROUP_CONCAT|" +
    "BOUND|COALESCE|NOT EXISTS|EXISTS|REGEX|SUBSTR|REPLACE"

  );
  
  var keywordMapper = this.createKeywordMapper({
      "constant.language": builtinConstants,
      "keyword.sparql" : keywords,
      "keyword.sparqlfuncs" : builtinFunctions
  }, "identifier", true);

  this.$rules = { start: 
     [ 
       { token: 'keyword.turtle',
         regex: '(?:^|\\s+)(?:@base|@prefix)\\b',
         comment: 'Keywords' },
       { token: 'variable.sparql',
         regex: '(?:\\?[A-Za-z]+)',
         comment: 'Variables'},
       { token: 'string.uri.turtle',
         regex: '<[^<>"{}|^`\\]\\\\]*>',
         comment: 'URI' },
       { token: [ 'constant.language.turtle', 'entity.name.class.turtle' ],
         regex: '(_:)([^\\s]+)',
         comment: 'Blank node' },
       { token: [ 'constant.other.turtle', 'entity.name.class.turtle' ],
         regex: '(\\w*:)([^\\s|/^*?+{}()]*)',
         comment: 'Prefix / prefixed URI' },
       { token: 'entity.name.class.rdfs-type.turtle',
         regex: '\\sa\\s',
         comment: 'The special triple predicate \'a\'' },
       { token: 
          [ 'string.turtle',
            'keyword.operator.turtle',
            'support.type.turtle' ],
         regex: '("[^"]*")(\\^\\^)(<[^<>"{}|^`\\]\\\\]*>|\\w*:[^\\s)]+)',
         comment: 'Typed literal' },
       { token: 
          [ 'string.turtle',
            'string.turtle',
            'string.turtle',
            'keyword.operator.turtle',
            'string.turtle',
            'string.turtle',
            'string.turtle',
            'string.turtle',
            'string.turtle',
            'string.turtle',
            'string.turtle',
            'support.type.turtle' ],
         regex: '(?:(\'\'\')(?:(?:\'|\'\')?(?:[^\'\\\\]|\\\\[tbnrf\\"\']))*(\'\'\')|(""")(?:(?:"|"")?([^"\\\\]|\\\\[tbnrf\\"\']))*(""")|(\')(?:[^\\x22\\x5C\\xA\\xD]|\\\\[tbnrf\\"\'])*(\')|(")(?:[^\\x22\\x5C\\xA\\xD]|\\\\[tbnrf\\"\'])*(")|(\'\'\'.*\'\'\')|(\'[^\']*\'))((?:@[a-zA-Z-]+)?)',
         comment: 'String literal' },
       { token: 'comment.line.number-sign.turtle',
         regex: '#.*$',
         comment: 'Comments' },
       { token: 'constant.numeric.turtle',
         regex: '\\b[+-]?(?:\\d+|[0-9]+\\.[0-9]*|\\.[0-9]+(?:[eE][+-]?\\d+)?)\\b',
         comment: 'Numeric literal' },
       {
         token : keywordMapper,
         regex : "[a-zA-Z_$][a-zA-Z0-9_$]*\\b"
       } ] }
    
    this.normalizeRules();
};

SPARQLHighlightRules.metaData = { fileTypes: [ 'sparql', 'rq' ],
      keyEquivalent: '^~S',
      name: 'SPARQL',
      scopeName: 'source.sparql' }


oop.inherits(SPARQLHighlightRules, TextHighlightRules);

exports.SPARQLHighlightRules = SPARQLHighlightRules;
});