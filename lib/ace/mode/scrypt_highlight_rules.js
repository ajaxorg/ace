/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/* This file was autogenerated from ./tmthemes/tmscrypt.tmLanguage (uuid: ) */
/****************************************************************************************
 * IT MIGHT NOT BE PERFECT ...But it's a good start from an existing *.tmlanguage file. *
 * fileTypes                                                                            *
 ****************************************************************************************/

define(function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;

var scryptHighlightRules = function() {
    // regexp must not have capturing parentheses. Use (?:) instead.
    // regexps are ordered -> the first match is used

    this.$rules = {
        start: [{
            include: "#comments"
        }, {
            include: "#import"
        }, {
            include: "#code"
        }, {
            include: "#numbers"
        }],
        "#comments": [{
            token: "punctuation.definition.comment.scrypt",
            regex: /\/\*/,
            push: [{
                token: "punctuation.definition.comment.scrypt",
                regex: /\*\//,
                next: "pop"
            }, {
                defaultToken: "comment.block.scrypt"
            }]
        }, {
            token: "punctuation.definition.comment.scrypt",
            regex: /\/\//,
            push: [{
                token: "comment.line.scrypt",
                regex: /(?=$)/,
                next: "pop"
            }, {
                defaultToken: "comment.line.scrypt"
            }]
        }],
        "#filepath": [{
            token: "punctuation.separator.scrypt",
            regex: /\"/,
            push: [{
                token: "punctuation.separator.scrypt",
                regex: /\"/,
                next: "pop"
            }, {
                defaultToken: "string.quoted.double.bytes.scrypt"
            }]
        }],
        "#import": [{
            token: ["keyword.other.import.scrypt", "text"],
            regex: /\b(import)(\s)/,
            push: [{
                token: "text",
                regex: /(?=;)/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                include: "#filepath"
            }]
        }],
        "#other-variable": [{
            token: "variable.other.scrypt",
            regex: /\b[_$[:alpha:]][_$[:alnum:]]*\b/
        }],
        "#property-variable": [{
            token: "variable.object.property.scrypt",
            regex: /\b[_$[:alpha:]][_$[:alnum:]]*\b/
        }],
        "#parameter-variable": [{
            token: "variable.other.scrypt",
            regex: /\b[_$[:alpha:]][_$[:alnum:]]*\b/
        }],
        "#primitive-types": [{
            token: "storage.type.primitive.scrypt",
            regex: /\b(?:bool|int|bytes|PrivKey|PubKey|Sig|Ripemd160|Sha1|Sha256|SigHashType|SigHashPreimage|OpCodeType)\b/
        }],
        "#primitive-arrays": [{
            token: ["storage.type.primitive.array.scrypt", "text"],
            regex: /\b(bool|int|bytes|PrivKey|PubKey|Sig|Ripemd160|Sha1|Sha256|SigHashType|SigHashPreimage|OpCodeType)\b(\s*)(?=\[)/,
            push: [{
                token: "text",
                regex: /(?!\s*\[)/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                include: "#numbers"
            }, {
                include: "#parens"
            }]
        }],
        "#auto-types": [{
            token: "storage.type.auto.scrypt",
            regex: /\bauto\b/
        }],
        "#all-types": [{
            include: "#primitive-types"
        }, {
            include: "#auto-types"
        }, {
            token: "entity.name.type.scrypt",
            regex: /\b[A-Z][_$[:alnum:]]*\b/
        }, {
            include: "#keywords"
        }, {
            include: "#numbers"
        }],
        "#keywords": [{
            token: "keyword.control.scrypt",
            regex: /\b(?:return|loop|if|else)\b/
        }, {
            token: "keyword.control.require.scrypt",
            regex: /\brequire\b/
        }, {
            token: "keyword.control.exit.scrypt",
            regex: /\bexit\b/
        }, {
            token: "storage.type.auto.scrypt",
            regex: /\bauto\b/
        }, {
            token: "keyword.other.asm.scrypt",
            regex: /\basm\b/
        }, {
            token: "keyword.operator.new.scrypt",
            regex: /\bnew\b/
        }, {
            token: "keyword.other.struct.scrypt",
            regex: /\bstruct\b/
        }, {
            token: "keyword.other.type.scrypt",
            regex: /\btype\b/
        }, {
            include: "#storage-modifiers"
        }, {
            include: "#operators"
        }, {
            include: "#constant-boolean"
        }, {
            include: "#primitive-types"
        }],
        "#operators": [{
            token: "keyword.operator.logic.scrypt",
            regex: /==|!=|!(?!=)|<(?!<)|<=|>(?!>)|>=|\&\&|\|\||\:(?!=)|\?/
        }, {
            token: "keyword.operator.arithmetic.scrypt",
            regex: /\b(?:\+|\-|\/|\%|\*)\b/
        }, {
            token: "keyword.operator.binary.scrypt",
            regex: /\~|\^|\&|\||<<|>>/
        }, {
            token: "keyword.operator.assignment.scrypt",
            regex: /\:?=/
        }, {
            token: "keyword.operator.seperator.scrypt",
            regex: /\*{3}/
        }],
        "#constant-boolean": [{
            token: "constant.language.boolean.scrypt",
            regex: /\b(?:true|false)\b/
        }],
        "#storage-modifiers": [{
            token: "storage.modifier.scrypt",
            regex: /\b(?:public|private|static|const)\b/
        }],
        "#contract": [{
            token: [
                "keyword.other.contract.scrypt",
                "meta.class.scrypt",
                "entity.name.type.contract.scrypt"
            ],
            regex: /\b(contract|library)(?:(\s+)([_$[:alpha:]][_$[:alnum:]]*))?\b/,
            push: [{
                token: "meta.class.scrypt",
                regex: /(?=})/,
                next: "pop"
            }, {
                include: "#storage-modifiers"
            }, {
                include: "#comments"
            }, {
                include: "#contract-body"
            }, {
                defaultToken: "meta.class.scrypt"
            }]
        }],
        "#contract-body": [{
            token: "meta.class.body.scrypt",
            regex: /\{/,
            push: [{
                token: "meta.class.body.scrypt",
                regex: /(?=})/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                include: "#proerties-and-functions"
            }, {
                include: "#code"
            }, {
                defaultToken: "meta.class.body.scrypt"
            }]
        }],
        "#type-alias": [{
            token: "keyword.other.type.scrypt",
            regex: /\btype\b/,
            push: [{
                token: "meta.definition.alias.scrypt",
                regex: /;/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                include: "#type-alias-name"
            }, {
                include: "#operators"
            }, {
                include: "#numbers"
            }, {
                defaultToken: "meta.definition.alias.scrypt"
            }]
        }],
        "#type-alias-name": [{
            token: ["text", "text", "text"],
            regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)/
        }],
        "#numbers": [{
            token: "constant.numeric.hex.scrypt",
            regex: /\b0[xX][a-fA-F0-9]+\b/
        }, {
            token: "constant.numeric.integer.scrypt",
            regex: /\b\d+(?:\.\d+)?\b/
        }],
        "#bytes": [{
            token: "string.quoted.single.bytes.scrypt",
            regex: /\bb'[0-9a-fA-F]*'/
        }],
        "#special-vars": [{
            token: "variable.language.this.scrypt",
            regex: /\bthis\b/
        }],
        "#proerties-and-functions": [{
            include: "#properties"
        }, {
            include: "#static-properties"
        }, {
            include: "#functions"
        }],
        "#functions": [{
            token: "meta.method.scrypt",
            regex: /(?=[\w].*\s+)(?=(?:[^=\/]|\/(?!\/))+\()/,
            push: [{
                token: "meta.method.scrypt",
                regex: /}|(?=;)/,
                next: "pop"
            }, {
                include: "#contract-constructor"
            }, {
                include: "#contract-function"
            }, {
                defaultToken: "meta.method.scrypt"
            }]
        }],
        "#contract-constructor": [{
            token: [
                "storage.type.function.scrypt",
                "meta.function.scrypt"
            ],
            regex: /\b(constructor)(\s*\()/,
            push: [{
                token: "meta.function.scrypt",
                regex: /\)/,
                next: "pop"
            }, {
                include: "#parameters"
            }, {
                include: "#parens"
            }, {
                include: "#comments"
            }, {
                defaultToken: "meta.function.scrypt"
            }]
        }, {
            include: "#function-body"
        }],
        "#contract-function": [{
            include: "#storage-modifiers"
        }, {
            token: [
                "storage.type.function.scrypt",
                "meta.function.scrypt",
                "entity.name.function.scrypt",
                "meta.function.scrypt"
            ],
            regex: /\b(function)(\s+)([_$[:alpha:]][_$[:alnum:]]*)(\s*\()/,
            push: [{
                token: "meta.function.scrypt",
                regex: /\)/,
                next: "pop"
            }, {
                include: "#parameters"
            }, {
                include: "#parens"
            }, {
                include: "#comments"
            }, {
                defaultToken: "meta.function.scrypt"
            }]
        }, {
            include: "#function-return"
        }, {
            include: "#function-body"
        }, {
            include: "#comments"
        }],
        "#function-body": [{
            token: "punctuation.section.method.begin.bracket.curly.scrypt",
            regex: /\{/,
            push: [{
                token: "meta.definition.function.scrypt",
                regex: /(?=})/,
                next: "pop"
            }, {
                include: "#code"
            }, {
                defaultToken: "meta.definition.function.scrypt"
            }]
        }],
        "#function-return": [{
            token: "keyword.operator.semicolon.scrypt",
            regex: /\:/,
            push: [{
                token: "meta.method.return-type.scrypt",
                regex: /(?=\{)/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                token: ["text", "text", "text"],
                regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)/
            }, {
                defaultToken: "meta.method.return-type.scrypt"
            }]
        }],
        "#parameters": [{
            include: "#storage-modifiers"
        }, {
            token: ["text", "text", "text", "text"],
            regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)(\s*)/,
            push: [{
                token: "text",
                regex: /(?=\)|,)/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                include: "#parameter-variable"
            }]
        }],
        "#global-functions": [{
            token: ["support.function.math.scrypt", "text", "text"],
            regex: /\b(abs|min|max|within|ripemd160|sha1|sha256|hash160|hash256|checkSig|checkMultiSig|num2bin|pack|unpack|len|reverseBytes|repeat)(\s*)(\()/
        }, {
            token: [
                "support.function.subtypes.scrypt",
                "text",
                "text"
            ],
            regex: /\b(PrivKey|PubKey|Sig|Ripemd160|Sha1|Sha256|SigHashType|SigHashPreimage|OpCodeType)(\s*)(\()/
        }],
        "#function-call": [{
            include: "#global-functions"
        }, {
            token: [
                "meta.function-call.scrypt",
                "meta.function-call.scrypt",
                "punctuation.definition.parameters.begin.bracket.round.scrypt"
            ],
            regex: /([_$[:alpha:]][_$[:alnum:]]*)(\s*)(\()/,
            push: [{
                token: "meta.function-call.scrypt",
                regex: /\)/,
                next: "pop"
            }, {
                include: "#code"
            }, {
                defaultToken: "meta.function-call.scrypt"
            }]
        }],
        "#new-contract": [{
            token: [
                "keyword.operator.new.scrypt",
                "meta.new-contract.scrypt",
                "meta.new-contract.scrypt",
                "meta.new-contract.scrypt",
                "meta.new-contract.scrypt"
            ],
            regex: /\b(new)(\s*)([_$[:alpha:]][_$[:alnum:]]*)(\s*)(\()/,
            push: [{
                token: "meta.new-contract.scrypt",
                regex: /\)/,
                next: "pop"
            }, {
                include: "#code"
            }, {
                defaultToken: "meta.new-contract.scrypt"
            }]
        }],
        "#method-call": [{
            token: [
                "meta.method-call.scrypt",
                "meta.method-call.scrypt",
                "punctuation.separator.period.scrypt",
                "meta.method-call.scrypt",
                "entity.name.function.scrypt",
                "meta.method-call.scrypt",
                "punctuation.definition.parameters.begin.bracket.round.scrypt"
            ],
            regex: /([_$[:alpha:]][_$[:alnum:]]*)([^\S$\r]*)(\.)([^\S$\r]*)([_$[:alpha:]][_$[:alnum:]]*)([^\S$\r]*)(\()/,
            push: [{
                token: "meta.method-call.scrypt",
                regex: /\)/,
                next: "pop"
            }, {
                include: "#code"
            }, {
                defaultToken: "meta.method-call.scrypt"
            }]
        }],
        "#struct": [{
            token: [
                "keyword.other.struct.scrypt",
                "meta.definition.struct.scrypt",
                "entity.name.type.struct.scrypt",
                "meta.definition.struct.scrypt",
                "meta.definition.struct.scrypt"
            ],
            regex: /\b(struct)(\s*)([_$[:alpha:]][_$[:alnum:]]*)(\s*)(\{)/,
            push: [{
                token: "meta.definition.struct.scrypt",
                regex: /\}/,
                next: "pop"
            }, {
                include: "#comments"
            }, {
                token: [
                    "text",
                    "text",
                    "text",
                    "text",
                    "variable.object.property.scrypt",
                    "text",
                    "text"
                ],
                regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)(\s+)([_$[:alpha:]][_$[:alnum:]]*)(\s*)(;)/
            }, {
                include: "#keywords"
            }, {
                defaultToken: "meta.definition.struct.scrypt"
            }]
        }],
        "#std-contracts": [{
            include: "#std-opcodes"
        }, {
            include: "#std-sigHash"
        }, {
            token: "entity.name.type.class.scrypt",
            regex: /\b(?:P2PKH|P2PK|Tx|HashPuzzleRipemd160|HashPuzzleSha1|HashPuzzleSha256|HashPuzzleHash160|OpCode|SigHash)\b/
        }],
        "#variable-decl": [{
            token: [
                "meta.definition.variable.scrypt",
                "meta.definition.variable.scrypt",
                "meta.definition.variable.scrypt",
                "meta.definition.variable.scrypt",
                "meta.definition.variable.scrypt",
                "meta.definition.variable.scrypt",
                "keyword.operator.assignment.scrypt"
            ],
            regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)(\s+)([_$[:alpha:]][_$[:alnum:]]*)(\s*)(=)/,
            push: [{
                token: "meta.definition.variable.scrypt",
                regex: /;/,
                next: "pop"
            }, {
                include: "#new-contract"
            }, {
                include: "#expression"
            }, {
                defaultToken: "meta.definition.variable.scrypt"
            }]
        }],
        "#properties": [{
            include: "#storage-modifiers"
        }, {
            token: [
                "text",
                "text",
                "text",
                "text",
                "meta.definition.property.scrypt variable.object.property.scrypt",
                "text",
                "text"
            ],
            regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)(\s+)([_$[:alpha:]][_$[:alnum:]]*)(\s*)(;)/
        }],
        "#static-properties": [{
            include: "#storage-modifiers"
        }, {
            token: [
                "text",
                "text",
                "text",
                "text",
                "meta.definition.property.scrypt variable.object.property.scrypt",
                "text",
                "keyword.operator.assignment.scrypt"
            ],
            regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)((?:(?:\[[\w.]+\])+)?)(\s+)([_$[:alpha:]][_$[:alnum:]]*)(\s*)(=)/,
            push: [{
                token: "text",
                regex: /;/,
                next: "pop"
            }, {
                include: "#expression"
            }]
        }],
        "#properties-reference": [{
            token: [
                "text",
                "text",
                "text",
                "text",
                "variable.object.property.scrypt"
            ],
            regex: /\b([_$[:alpha:]][_$[:alnum:]]*)(\s*)(\.)(\s*)([_$[:alpha:]][_$[:alnum:]]*)\b(?=[^\(\.])/
        }, {
            token: [
                "text",
                "text",
                "variable.object.property.scrypt"
            ],
            regex: /(\.)(\s*)([_$[:alpha:]][_$[:alnum:]]*)\b(?=[^\(])/
        }],
        "#asm-block": [{
            token: ["keyword.other.asm.scrypt", "text", "text"],
            regex: /\b(asm)(\s*)(\{)/,
            push: [{
                token: "text",
                regex: /\}/,
                next: "pop"
            }, {
                token: "variable.parameter.asm.scrypt",
                regex: /\s\$[_$[:alpha:]][_$[:alnum:]]*\b/
            }, {
                token: undefined,
                regex: /\b(OP_PUSHDATA1|OP_PUSHDATA2|OP_PUSHDATA4|OP_0|OP_FALSE|OP_1NEGATE|OP_1|OP_TRUE|OP_2|OP_3|OP_4|OP_5|OP_6|OP_7|OP_8|OP_9|OP_10|OP_11|OP_12|OP_13|OP_14|OP_15|OP_16|OP_1ADD|OP_1SUB|OP_NEGATE|OP_ABS|OP_NOT|OP_0NOTEQUAL|OP_ADD|OP_SUB|OP_MUL|OP_DIV|OP_MOD|OP_LSHIFT|OP_RSHIFT|OP_BOOLAND|OP_BOOLOR|OP_NUMEQUAL|OP_NUMEQUALVERIFY|OP_NUMNOTEQUAL|OP_LESSTHAN|OP_GREATERTHAN|OP_LESSTHANOREQUAL|OP_GREATERTHANOREQUAL|OP_MIN|OP_MAX|OP_WITHIN|OP_CAT|OP_SPLIT|OP_BIN2NUM|OP_NUM2BIN|OP_SIZE|OP_NOP|OP_IF|OP_NOTIF|OP_ELSE|OP_ENDIF|OP_VERIFY|OP_RETURN|OP_TOALTSTACK|OP_FROMALTSTACK|OP_IFDUP|OP_DEPTH|OP_DROP|OP_DUP|OP_NIP|OP_OVER|OP_PICK|OP_ROLL|OP_ROT|OP_SWAP|OP_TUCK|OP_2DROP|OP_2DUP|OP_3DUP|OP_2OVER|OP_2ROT|OP_2SWAP|OP_RIPEMD160|OP_SHA1|OP_SHA256|OP_HASH160|OP_HASH256|OP_CODESEPARATOR|OP_CHECKSIG|OP_CHECKSIGVERIFY|OP_CHECKMULTISIG|OP_CHECKMULTISIGVERIFY|OP_INVERT|OP_AND|OP_OR|OP_XOR|OP_EQUAL|OP_EQUALVERIFY)\b/
            }, {
                include: "#comments"
            }, {
                token: "constant.numeric.hex.scrypt",
                regex: /\b[a-fA-F0-9]+\b/
            }]
        }],
        "#std-opcodes": [{
            token: [
                "entity.name.type.class.scrypt",
                "text",
                "text",
                "text",
                "meta.definition.property.scrypt variable.object.property.scrypt"
            ],
            regex: /\b(OpCode)(\s*)(\.)(\s*)(OP_PUSHDATA1|OP_PUSHDATA2|OP_PUSHDATA4|OP_0|OP_FALSE|OP_1NEGATE|OP_1|OP_TRUE|OP_2|OP_3|OP_4|OP_5|OP_6|OP_7|OP_8|OP_9|OP_10|OP_11|OP_12|OP_13|OP_14|OP_15|OP_16|OP_1ADD|OP_1SUB|OP_NEGATE|OP_ABS|OP_NOT|OP_0NOTEQUAL|OP_ADD|OP_SUB|OP_MUL|OP_DIV|OP_MOD|OP_LSHIFT|OP_RSHIFT|OP_BOOLAND|OP_BOOLOR|OP_NUMEQUAL|OP_NUMEQUALVERIFY|OP_NUMNOTEQUAL|OP_LESSTHAN|OP_GREATERTHAN|OP_LESSTHANOREQUAL|OP_GREATERTHANOREQUAL|OP_MIN|OP_MAX|OP_WITHIN|OP_CAT|OP_SPLIT|OP_BIN2NUM|OP_NUM2BIN|OP_SIZE|OP_NOP|OP_IF|OP_NOTIF|OP_ELSE|OP_ENDIF|OP_VERIFY|OP_RETURN|OP_TOALTSTACK|OP_FROMALTSTACK|OP_IFDUP|OP_DEPTH|OP_DROP|OP_DUP|OP_NIP|OP_OVER|OP_PICK|OP_ROLL|OP_ROT|OP_SWAP|OP_TUCK|OP_2DROP|OP_2DUP|OP_3DUP|OP_2OVER|OP_2ROT|OP_2SWAP|OP_RIPEMD160|OP_SHA1|OP_SHA256|OP_HASH160|OP_HASH256|OP_CODESEPARATOR|OP_CHECKSIG|OP_CHECKSIGVERIFY|OP_CHECKMULTISIG|OP_CHECKMULTISIGVERIFY|OP_INVERT|OP_AND|OP_OR|OP_XOR|OP_EQUAL|OP_EQUALVERIFY)\b/
        }],
        "#std-sigHash": [{
            token: [
                "entity.name.type.class.scrypt",
                "text",
                "text",
                "text",
                "meta.definition.property.scrypt variable.object.property.scrypt"
            ],
            regex: /\b(SigHash)(\s*)(\.)(\s*)(ANYONECANPAY|ALL|FORKID|NONE|SINGLE)\b/
        }],
        "#parens": [{
            token: "punctuation.bracket.round.scrypt",
            regex: /\(/,
            push: [{
                token: "punctuation.bracket.round.scrypt",
                regex: /\)/,
                next: "pop"
            }, {
                include: "#code"
            }]
        }, {
            token: "punctuation.bracket.square.scrypt",
            regex: /\[/,
            push: [{
                token: "punctuation.bracket.square.scrypt",
                regex: /\]/,
                next: "pop"
            }, {
                include: "#code"
            }]
        }, {
            token: "punctuation.bracket.square.scrypt",
            regex: /\{/,
            push: [{
                token: "punctuation.bracket.square.scrypt",
                regex: /\}/,
                next: "pop"
            }, {
                include: "#code"
            }]
        }],
        "#code": [{
            include: "#comments"
        }, {
            include: "#struct"
        }, {
            include: "#type-alias"
        }, {
            include: "#contract"
        }, {
            include: "#parens"
        }, {
            include: "#std-contracts"
        }, {
            include: "#asm-block"
        }, {
            include: "#new-contract"
        }, {
            include: "#method-call"
        }, {
            include: "#function-call"
        }, {
            include: "#variable-decl"
        }, {
            include: "#expression"
        }],
        "#expression": [{
            include: "#comments"
        }, {
            include: "#parens"
        }, {
            include: "#special-vars"
        }, {
            include: "#properties-reference"
        }, {
            include: "#std-contracts"
        }, {
            include: "#method-call"
        }, {
            include: "#function-call"
        }, {
            include: "#numbers"
        }, {
            include: "#bytes"
        }, {
            include: "#keywords"
        }, {
            include: "#other-variable"
        }]
    }
    
    this.normalizeRules();
};

scryptHighlightRules.metaData = {
    name: "scrypt",
    scopeName: "source.scrypt",
    fileTypes: ["scrypt"]
}


oop.inherits(scryptHighlightRules, TextHighlightRules);

exports.scryptHighlightRules = scryptHighlightRules;
});